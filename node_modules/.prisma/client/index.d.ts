
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/index';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model users
 * 
 */
export type users = {
  id: number
  image: string | null
  username: string
  password: string
  isAdmin: boolean
  isSuperUser: boolean
  dateJoined: Date
  name: string
  updatedAt: Date
  isOnline: boolean
}

/**
 * Model vifurushi
 * 
 */
export type vifurushi = {
  id: number
  name: string
  value: number
  usersId: number
}

/**
 * Model vifurushiPrice
 * 
 */
export type vifurushiPrice = {
  id: number
  name: string
  price: number
}

/**
 * Model vifurushiPackage
 * 
 */
export type vifurushiPackage = {
  id: number
  name: string
  value: number
}

/**
 * Model notesDownload
 * 
 */
export type notesDownload = {
  id: number
  name: string
  value: number
  vifurushiPackageId: number
}

/**
 * Model quizExcercises
 * 
 */
export type quizExcercises = {
  id: number
  name: string
  value: number
  vifurushiPackageId: number
}

/**
 * Model examsUnsolvedDownload
 * 
 */
export type examsUnsolvedDownload = {
  id: number
  name: string
  value: number
  vifurushiPackageId: number
}

/**
 * Model examsSolvedDownload
 * 
 */
export type examsSolvedDownload = {
  id: number
  name: string
  value: number
  vifurushiPackageId: number
}

/**
 * Model examAccess
 * 
 */
export type examAccess = {
  id: number
  name: string
  value: number
  vifurushiPackageId: number
}

/**
 * Model booksDownload
 * 
 */
export type booksDownload = {
  id: number
  name: string
  value: number
  vifurushiPackageId: number
}

/**
 * Model purchase
 * 
 */
export type purchase = {
  id: number
  name: string
  value: number
  usersId: number
}

/**
 * Model subject
 * 
 */
export type subject = {
  id: number
  subjectName: string
  subjectDefinition: string
  imageLocation: string | null
  published: boolean
  usersId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model form
 * 
 */
export type form = {
  id: number
  formName: string
  usersId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model topic
 * 
 */
export type topic = {
  id: number
  topicName: string
  topicDefinition: string | null
  published: boolean
  subjectId: number
  formId: number
  usersId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model note
 * 
 */
export type note = {
  id: number
  content: string
  createdAt: Date
  updatedAt: Date
  published: boolean
  subjectId: number
  formId: number
  usersId: number
  topicId: number
}

/**
 * Model notesDownloadable
 * 
 */
export type notesDownloadable = {
  id: number
  link: string
  fileExtension: string
  published: boolean
  formId: number
  subjectId: number
  usersId: number
  name: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model subjectReview
 * 
 */
export type subjectReview = {
  id: number
  subjectName: string
  subjectDefinition: string
  imageLocation: string | null
  published: boolean
  usersId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model formReview
 * 
 */
export type formReview = {
  id: number
  formName: string
  usersId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model topicReview
 * 
 */
export type topicReview = {
  id: number
  topicName: string
  topicDefinition: string | null
  published: boolean
  subjectId: number
  formId: number
  usersId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model review
 * 
 */
export type review = {
  id: number
  name: string
  published: boolean
  topicId: number
  subjectId: number
  formId: number
  createdAt: Date
  updatedAt: Date
  usersId: number
}

/**
 * Model question
 * 
 */
export type question = {
  id: number
  question: string
  published: boolean
  answerDetails: string
  questionFormatId: number
  reviewId: number
  usersId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model questionFormat
 * 
 */
export type questionFormat = {
  id: number
  name: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model answer
 * 
 */
export type answer = {
  id: number
  answer: string
  valid: boolean
  questionId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model subjectExams
 * 
 */
export type subjectExams = {
  id: number
  subjectName: string
  subjectDefinition: string
  imageLocation: string | null
  published: boolean
  usersId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model formExams
 * 
 */
export type formExams = {
  id: number
  formName: string
  usersId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model examType
 * 
 */
export type examType = {
  id: number
  name: string
  definition: string
  published: boolean
  subjectId: number
  formId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model exam
 * 
 */
export type exam = {
  id: number
  description: string
  year: number
  hasAnswers: boolean
  published: boolean
  examTypeId: number
  exam: string
  usersId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model examDownloadable
 * 
 */
export type examDownloadable = {
  id: number
  link: string
  fileExtension: string
  published: boolean
  examId: number
  usersId: number
  name: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model subjectReference
 * 
 */
export type subjectReference = {
  id: number
  subjectName: string
  subjectDefinition: string
  imageLocation: string | null
  published: boolean
  usersId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model formReference
 * 
 */
export type formReference = {
  id: number
  formName: string
  usersId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model reference
 * 
 */
export type reference = {
  id: number
  name: string
  description: string
  data: string
  isPdf: boolean
  published: boolean
  subjectId: number
  usersId: number
  createdAt: Date
  updatedAt: Date
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.users.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.users.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P]): Promise<UnwrapTuple<P>>;

      /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<GlobalReject>;

  /**
   * `prisma.vifurushi`: Exposes CRUD operations for the **vifurushi** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vifurushis
    * const vifurushis = await prisma.vifurushi.findMany()
    * ```
    */
  get vifurushi(): Prisma.vifurushiDelegate<GlobalReject>;

  /**
   * `prisma.vifurushiPrice`: Exposes CRUD operations for the **vifurushiPrice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VifurushiPrices
    * const vifurushiPrices = await prisma.vifurushiPrice.findMany()
    * ```
    */
  get vifurushiPrice(): Prisma.vifurushiPriceDelegate<GlobalReject>;

  /**
   * `prisma.vifurushiPackage`: Exposes CRUD operations for the **vifurushiPackage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VifurushiPackages
    * const vifurushiPackages = await prisma.vifurushiPackage.findMany()
    * ```
    */
  get vifurushiPackage(): Prisma.vifurushiPackageDelegate<GlobalReject>;

  /**
   * `prisma.notesDownload`: Exposes CRUD operations for the **notesDownload** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotesDownloads
    * const notesDownloads = await prisma.notesDownload.findMany()
    * ```
    */
  get notesDownload(): Prisma.notesDownloadDelegate<GlobalReject>;

  /**
   * `prisma.quizExcercises`: Exposes CRUD operations for the **quizExcercises** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuizExcercises
    * const quizExcercises = await prisma.quizExcercises.findMany()
    * ```
    */
  get quizExcercises(): Prisma.quizExcercisesDelegate<GlobalReject>;

  /**
   * `prisma.examsUnsolvedDownload`: Exposes CRUD operations for the **examsUnsolvedDownload** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExamsUnsolvedDownloads
    * const examsUnsolvedDownloads = await prisma.examsUnsolvedDownload.findMany()
    * ```
    */
  get examsUnsolvedDownload(): Prisma.examsUnsolvedDownloadDelegate<GlobalReject>;

  /**
   * `prisma.examsSolvedDownload`: Exposes CRUD operations for the **examsSolvedDownload** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExamsSolvedDownloads
    * const examsSolvedDownloads = await prisma.examsSolvedDownload.findMany()
    * ```
    */
  get examsSolvedDownload(): Prisma.examsSolvedDownloadDelegate<GlobalReject>;

  /**
   * `prisma.examAccess`: Exposes CRUD operations for the **examAccess** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExamAccesses
    * const examAccesses = await prisma.examAccess.findMany()
    * ```
    */
  get examAccess(): Prisma.examAccessDelegate<GlobalReject>;

  /**
   * `prisma.booksDownload`: Exposes CRUD operations for the **booksDownload** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BooksDownloads
    * const booksDownloads = await prisma.booksDownload.findMany()
    * ```
    */
  get booksDownload(): Prisma.booksDownloadDelegate<GlobalReject>;

  /**
   * `prisma.purchase`: Exposes CRUD operations for the **purchase** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Purchases
    * const purchases = await prisma.purchase.findMany()
    * ```
    */
  get purchase(): Prisma.purchaseDelegate<GlobalReject>;

  /**
   * `prisma.subject`: Exposes CRUD operations for the **subject** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subjects
    * const subjects = await prisma.subject.findMany()
    * ```
    */
  get subject(): Prisma.subjectDelegate<GlobalReject>;

  /**
   * `prisma.form`: Exposes CRUD operations for the **form** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Forms
    * const forms = await prisma.form.findMany()
    * ```
    */
  get form(): Prisma.formDelegate<GlobalReject>;

  /**
   * `prisma.topic`: Exposes CRUD operations for the **topic** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Topics
    * const topics = await prisma.topic.findMany()
    * ```
    */
  get topic(): Prisma.topicDelegate<GlobalReject>;

  /**
   * `prisma.note`: Exposes CRUD operations for the **note** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notes
    * const notes = await prisma.note.findMany()
    * ```
    */
  get note(): Prisma.noteDelegate<GlobalReject>;

  /**
   * `prisma.notesDownloadable`: Exposes CRUD operations for the **notesDownloadable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotesDownloadables
    * const notesDownloadables = await prisma.notesDownloadable.findMany()
    * ```
    */
  get notesDownloadable(): Prisma.notesDownloadableDelegate<GlobalReject>;

  /**
   * `prisma.subjectReview`: Exposes CRUD operations for the **subjectReview** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubjectReviews
    * const subjectReviews = await prisma.subjectReview.findMany()
    * ```
    */
  get subjectReview(): Prisma.subjectReviewDelegate<GlobalReject>;

  /**
   * `prisma.formReview`: Exposes CRUD operations for the **formReview** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FormReviews
    * const formReviews = await prisma.formReview.findMany()
    * ```
    */
  get formReview(): Prisma.formReviewDelegate<GlobalReject>;

  /**
   * `prisma.topicReview`: Exposes CRUD operations for the **topicReview** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TopicReviews
    * const topicReviews = await prisma.topicReview.findMany()
    * ```
    */
  get topicReview(): Prisma.topicReviewDelegate<GlobalReject>;

  /**
   * `prisma.review`: Exposes CRUD operations for the **review** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reviews
    * const reviews = await prisma.review.findMany()
    * ```
    */
  get review(): Prisma.reviewDelegate<GlobalReject>;

  /**
   * `prisma.question`: Exposes CRUD operations for the **question** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Questions
    * const questions = await prisma.question.findMany()
    * ```
    */
  get question(): Prisma.questionDelegate<GlobalReject>;

  /**
   * `prisma.questionFormat`: Exposes CRUD operations for the **questionFormat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuestionFormats
    * const questionFormats = await prisma.questionFormat.findMany()
    * ```
    */
  get questionFormat(): Prisma.questionFormatDelegate<GlobalReject>;

  /**
   * `prisma.answer`: Exposes CRUD operations for the **answer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Answers
    * const answers = await prisma.answer.findMany()
    * ```
    */
  get answer(): Prisma.answerDelegate<GlobalReject>;

  /**
   * `prisma.subjectExams`: Exposes CRUD operations for the **subjectExams** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubjectExams
    * const subjectExams = await prisma.subjectExams.findMany()
    * ```
    */
  get subjectExams(): Prisma.subjectExamsDelegate<GlobalReject>;

  /**
   * `prisma.formExams`: Exposes CRUD operations for the **formExams** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FormExams
    * const formExams = await prisma.formExams.findMany()
    * ```
    */
  get formExams(): Prisma.formExamsDelegate<GlobalReject>;

  /**
   * `prisma.examType`: Exposes CRUD operations for the **examType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExamTypes
    * const examTypes = await prisma.examType.findMany()
    * ```
    */
  get examType(): Prisma.examTypeDelegate<GlobalReject>;

  /**
   * `prisma.exam`: Exposes CRUD operations for the **exam** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Exams
    * const exams = await prisma.exam.findMany()
    * ```
    */
  get exam(): Prisma.examDelegate<GlobalReject>;

  /**
   * `prisma.examDownloadable`: Exposes CRUD operations for the **examDownloadable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExamDownloadables
    * const examDownloadables = await prisma.examDownloadable.findMany()
    * ```
    */
  get examDownloadable(): Prisma.examDownloadableDelegate<GlobalReject>;

  /**
   * `prisma.subjectReference`: Exposes CRUD operations for the **subjectReference** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubjectReferences
    * const subjectReferences = await prisma.subjectReference.findMany()
    * ```
    */
  get subjectReference(): Prisma.subjectReferenceDelegate<GlobalReject>;

  /**
   * `prisma.formReference`: Exposes CRUD operations for the **formReference** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FormReferences
    * const formReferences = await prisma.formReference.findMany()
    * ```
    */
  get formReference(): Prisma.formReferenceDelegate<GlobalReject>;

  /**
   * `prisma.reference`: Exposes CRUD operations for the **reference** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more References
    * const references = await prisma.reference.findMany()
    * ```
    */
  get reference(): Prisma.referenceDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export import Metrics = runtime.Metrics
  export import Metric = runtime.Metric
  export import MetricHistogram = runtime.MetricHistogram
  export import MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
   * Prisma Client JS version: 4.1.0
   * Query Engine version: 8d8414deb360336e4698a65aa45a1fbaf1ce13d8
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Buffer
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    users: 'users',
    vifurushi: 'vifurushi',
    vifurushiPrice: 'vifurushiPrice',
    vifurushiPackage: 'vifurushiPackage',
    notesDownload: 'notesDownload',
    quizExcercises: 'quizExcercises',
    examsUnsolvedDownload: 'examsUnsolvedDownload',
    examsSolvedDownload: 'examsSolvedDownload',
    examAccess: 'examAccess',
    booksDownload: 'booksDownload',
    purchase: 'purchase',
    subject: 'subject',
    form: 'form',
    topic: 'topic',
    note: 'note',
    notesDownloadable: 'notesDownloadable',
    subjectReview: 'subjectReview',
    formReview: 'formReview',
    topicReview: 'topicReview',
    review: 'review',
    question: 'question',
    questionFormat: 'questionFormat',
    answer: 'answer',
    subjectExams: 'subjectExams',
    formExams: 'formExams',
    examType: 'examType',
    exam: 'exam',
    examDownloadable: 'examDownloadable',
    subjectReference: 'subjectReference',
    formReference: 'formReference',
    reference: 'reference'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your prisma.schema file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UsersCountOutputType
   */


  export type UsersCountOutputType = {
    exam: number
    examDownloadable: number
    form: number
    formExams: number
    formReference: number
    formReview: number
    note: number
    notesDownloadable: number
    purchase: number
    question: number
    reference: number
    review: number
    subject: number
    subjectExams: number
    subjectReference: number
    subjectReview: number
    topic: number
    topicReview: number
    vifurushi: number
  }

  export type UsersCountOutputTypeSelect = {
    exam?: boolean
    examDownloadable?: boolean
    form?: boolean
    formExams?: boolean
    formReference?: boolean
    formReview?: boolean
    note?: boolean
    notesDownloadable?: boolean
    purchase?: boolean
    question?: boolean
    reference?: boolean
    review?: boolean
    subject?: boolean
    subjectExams?: boolean
    subjectReference?: boolean
    subjectReview?: boolean
    topic?: boolean
    topicReview?: boolean
    vifurushi?: boolean
  }

  export type UsersCountOutputTypeGetPayload<
    S extends boolean | null | undefined | UsersCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? UsersCountOutputType
    : S extends undefined
    ? never
    : S extends UsersCountOutputTypeArgs
    ?'include' extends U
    ? UsersCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof UsersCountOutputType ? UsersCountOutputType[P] : never
  } 
    : UsersCountOutputType
  : UsersCountOutputType




  // Custom InputTypes

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     * 
    **/
    select?: UsersCountOutputTypeSelect | null
  }



  /**
   * Count Type SubjectCountOutputType
   */


  export type SubjectCountOutputType = {
    note: number
    notesDownloadable: number
    topic: number
    forms: number
  }

  export type SubjectCountOutputTypeSelect = {
    note?: boolean
    notesDownloadable?: boolean
    topic?: boolean
    forms?: boolean
  }

  export type SubjectCountOutputTypeGetPayload<
    S extends boolean | null | undefined | SubjectCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? SubjectCountOutputType
    : S extends undefined
    ? never
    : S extends SubjectCountOutputTypeArgs
    ?'include' extends U
    ? SubjectCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof SubjectCountOutputType ? SubjectCountOutputType[P] : never
  } 
    : SubjectCountOutputType
  : SubjectCountOutputType




  // Custom InputTypes

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the SubjectCountOutputType
     * 
    **/
    select?: SubjectCountOutputTypeSelect | null
  }



  /**
   * Count Type FormCountOutputType
   */


  export type FormCountOutputType = {
    note: number
    notesDownloadable: number
    topic: number
    subjects: number
  }

  export type FormCountOutputTypeSelect = {
    note?: boolean
    notesDownloadable?: boolean
    topic?: boolean
    subjects?: boolean
  }

  export type FormCountOutputTypeGetPayload<
    S extends boolean | null | undefined | FormCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? FormCountOutputType
    : S extends undefined
    ? never
    : S extends FormCountOutputTypeArgs
    ?'include' extends U
    ? FormCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof FormCountOutputType ? FormCountOutputType[P] : never
  } 
    : FormCountOutputType
  : FormCountOutputType




  // Custom InputTypes

  /**
   * FormCountOutputType without action
   */
  export type FormCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the FormCountOutputType
     * 
    **/
    select?: FormCountOutputTypeSelect | null
  }



  /**
   * Count Type SubjectReviewCountOutputType
   */


  export type SubjectReviewCountOutputType = {
    review: number
    topic: number
    forms: number
  }

  export type SubjectReviewCountOutputTypeSelect = {
    review?: boolean
    topic?: boolean
    forms?: boolean
  }

  export type SubjectReviewCountOutputTypeGetPayload<
    S extends boolean | null | undefined | SubjectReviewCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? SubjectReviewCountOutputType
    : S extends undefined
    ? never
    : S extends SubjectReviewCountOutputTypeArgs
    ?'include' extends U
    ? SubjectReviewCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof SubjectReviewCountOutputType ? SubjectReviewCountOutputType[P] : never
  } 
    : SubjectReviewCountOutputType
  : SubjectReviewCountOutputType




  // Custom InputTypes

  /**
   * SubjectReviewCountOutputType without action
   */
  export type SubjectReviewCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the SubjectReviewCountOutputType
     * 
    **/
    select?: SubjectReviewCountOutputTypeSelect | null
  }



  /**
   * Count Type FormReviewCountOutputType
   */


  export type FormReviewCountOutputType = {
    review: number
    topic: number
    subjects: number
  }

  export type FormReviewCountOutputTypeSelect = {
    review?: boolean
    topic?: boolean
    subjects?: boolean
  }

  export type FormReviewCountOutputTypeGetPayload<
    S extends boolean | null | undefined | FormReviewCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? FormReviewCountOutputType
    : S extends undefined
    ? never
    : S extends FormReviewCountOutputTypeArgs
    ?'include' extends U
    ? FormReviewCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof FormReviewCountOutputType ? FormReviewCountOutputType[P] : never
  } 
    : FormReviewCountOutputType
  : FormReviewCountOutputType




  // Custom InputTypes

  /**
   * FormReviewCountOutputType without action
   */
  export type FormReviewCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the FormReviewCountOutputType
     * 
    **/
    select?: FormReviewCountOutputTypeSelect | null
  }



  /**
   * Count Type TopicReviewCountOutputType
   */


  export type TopicReviewCountOutputType = {
    review: number
  }

  export type TopicReviewCountOutputTypeSelect = {
    review?: boolean
  }

  export type TopicReviewCountOutputTypeGetPayload<
    S extends boolean | null | undefined | TopicReviewCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? TopicReviewCountOutputType
    : S extends undefined
    ? never
    : S extends TopicReviewCountOutputTypeArgs
    ?'include' extends U
    ? TopicReviewCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof TopicReviewCountOutputType ? TopicReviewCountOutputType[P] : never
  } 
    : TopicReviewCountOutputType
  : TopicReviewCountOutputType




  // Custom InputTypes

  /**
   * TopicReviewCountOutputType without action
   */
  export type TopicReviewCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the TopicReviewCountOutputType
     * 
    **/
    select?: TopicReviewCountOutputTypeSelect | null
  }



  /**
   * Count Type ReviewCountOutputType
   */


  export type ReviewCountOutputType = {
    question: number
  }

  export type ReviewCountOutputTypeSelect = {
    question?: boolean
  }

  export type ReviewCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ReviewCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ReviewCountOutputType
    : S extends undefined
    ? never
    : S extends ReviewCountOutputTypeArgs
    ?'include' extends U
    ? ReviewCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof ReviewCountOutputType ? ReviewCountOutputType[P] : never
  } 
    : ReviewCountOutputType
  : ReviewCountOutputType




  // Custom InputTypes

  /**
   * ReviewCountOutputType without action
   */
  export type ReviewCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ReviewCountOutputType
     * 
    **/
    select?: ReviewCountOutputTypeSelect | null
  }



  /**
   * Count Type QuestionCountOutputType
   */


  export type QuestionCountOutputType = {
    answer: number
  }

  export type QuestionCountOutputTypeSelect = {
    answer?: boolean
  }

  export type QuestionCountOutputTypeGetPayload<
    S extends boolean | null | undefined | QuestionCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? QuestionCountOutputType
    : S extends undefined
    ? never
    : S extends QuestionCountOutputTypeArgs
    ?'include' extends U
    ? QuestionCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof QuestionCountOutputType ? QuestionCountOutputType[P] : never
  } 
    : QuestionCountOutputType
  : QuestionCountOutputType




  // Custom InputTypes

  /**
   * QuestionCountOutputType without action
   */
  export type QuestionCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the QuestionCountOutputType
     * 
    **/
    select?: QuestionCountOutputTypeSelect | null
  }



  /**
   * Count Type QuestionFormatCountOutputType
   */


  export type QuestionFormatCountOutputType = {
    question: number
  }

  export type QuestionFormatCountOutputTypeSelect = {
    question?: boolean
  }

  export type QuestionFormatCountOutputTypeGetPayload<
    S extends boolean | null | undefined | QuestionFormatCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? QuestionFormatCountOutputType
    : S extends undefined
    ? never
    : S extends QuestionFormatCountOutputTypeArgs
    ?'include' extends U
    ? QuestionFormatCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof QuestionFormatCountOutputType ? QuestionFormatCountOutputType[P] : never
  } 
    : QuestionFormatCountOutputType
  : QuestionFormatCountOutputType




  // Custom InputTypes

  /**
   * QuestionFormatCountOutputType without action
   */
  export type QuestionFormatCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the QuestionFormatCountOutputType
     * 
    **/
    select?: QuestionFormatCountOutputTypeSelect | null
  }



  /**
   * Count Type SubjectExamsCountOutputType
   */


  export type SubjectExamsCountOutputType = {
    examType: number
    forms: number
  }

  export type SubjectExamsCountOutputTypeSelect = {
    examType?: boolean
    forms?: boolean
  }

  export type SubjectExamsCountOutputTypeGetPayload<
    S extends boolean | null | undefined | SubjectExamsCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? SubjectExamsCountOutputType
    : S extends undefined
    ? never
    : S extends SubjectExamsCountOutputTypeArgs
    ?'include' extends U
    ? SubjectExamsCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof SubjectExamsCountOutputType ? SubjectExamsCountOutputType[P] : never
  } 
    : SubjectExamsCountOutputType
  : SubjectExamsCountOutputType




  // Custom InputTypes

  /**
   * SubjectExamsCountOutputType without action
   */
  export type SubjectExamsCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the SubjectExamsCountOutputType
     * 
    **/
    select?: SubjectExamsCountOutputTypeSelect | null
  }



  /**
   * Count Type FormExamsCountOutputType
   */


  export type FormExamsCountOutputType = {
    examType: number
    subjects: number
  }

  export type FormExamsCountOutputTypeSelect = {
    examType?: boolean
    subjects?: boolean
  }

  export type FormExamsCountOutputTypeGetPayload<
    S extends boolean | null | undefined | FormExamsCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? FormExamsCountOutputType
    : S extends undefined
    ? never
    : S extends FormExamsCountOutputTypeArgs
    ?'include' extends U
    ? FormExamsCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof FormExamsCountOutputType ? FormExamsCountOutputType[P] : never
  } 
    : FormExamsCountOutputType
  : FormExamsCountOutputType




  // Custom InputTypes

  /**
   * FormExamsCountOutputType without action
   */
  export type FormExamsCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the FormExamsCountOutputType
     * 
    **/
    select?: FormExamsCountOutputTypeSelect | null
  }



  /**
   * Count Type ExamTypeCountOutputType
   */


  export type ExamTypeCountOutputType = {
    exam: number
  }

  export type ExamTypeCountOutputTypeSelect = {
    exam?: boolean
  }

  export type ExamTypeCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ExamTypeCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ExamTypeCountOutputType
    : S extends undefined
    ? never
    : S extends ExamTypeCountOutputTypeArgs
    ?'include' extends U
    ? ExamTypeCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof ExamTypeCountOutputType ? ExamTypeCountOutputType[P] : never
  } 
    : ExamTypeCountOutputType
  : ExamTypeCountOutputType




  // Custom InputTypes

  /**
   * ExamTypeCountOutputType without action
   */
  export type ExamTypeCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ExamTypeCountOutputType
     * 
    **/
    select?: ExamTypeCountOutputTypeSelect | null
  }



  /**
   * Count Type ExamCountOutputType
   */


  export type ExamCountOutputType = {
    examDownloadable: number
  }

  export type ExamCountOutputTypeSelect = {
    examDownloadable?: boolean
  }

  export type ExamCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ExamCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ExamCountOutputType
    : S extends undefined
    ? never
    : S extends ExamCountOutputTypeArgs
    ?'include' extends U
    ? ExamCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof ExamCountOutputType ? ExamCountOutputType[P] : never
  } 
    : ExamCountOutputType
  : ExamCountOutputType




  // Custom InputTypes

  /**
   * ExamCountOutputType without action
   */
  export type ExamCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ExamCountOutputType
     * 
    **/
    select?: ExamCountOutputTypeSelect | null
  }



  /**
   * Count Type SubjectReferenceCountOutputType
   */


  export type SubjectReferenceCountOutputType = {
    reference: number
    forms: number
  }

  export type SubjectReferenceCountOutputTypeSelect = {
    reference?: boolean
    forms?: boolean
  }

  export type SubjectReferenceCountOutputTypeGetPayload<
    S extends boolean | null | undefined | SubjectReferenceCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? SubjectReferenceCountOutputType
    : S extends undefined
    ? never
    : S extends SubjectReferenceCountOutputTypeArgs
    ?'include' extends U
    ? SubjectReferenceCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof SubjectReferenceCountOutputType ? SubjectReferenceCountOutputType[P] : never
  } 
    : SubjectReferenceCountOutputType
  : SubjectReferenceCountOutputType




  // Custom InputTypes

  /**
   * SubjectReferenceCountOutputType without action
   */
  export type SubjectReferenceCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the SubjectReferenceCountOutputType
     * 
    **/
    select?: SubjectReferenceCountOutputTypeSelect | null
  }



  /**
   * Count Type FormReferenceCountOutputType
   */


  export type FormReferenceCountOutputType = {
    reference: number
    subjects: number
  }

  export type FormReferenceCountOutputTypeSelect = {
    reference?: boolean
    subjects?: boolean
  }

  export type FormReferenceCountOutputTypeGetPayload<
    S extends boolean | null | undefined | FormReferenceCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? FormReferenceCountOutputType
    : S extends undefined
    ? never
    : S extends FormReferenceCountOutputTypeArgs
    ?'include' extends U
    ? FormReferenceCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof FormReferenceCountOutputType ? FormReferenceCountOutputType[P] : never
  } 
    : FormReferenceCountOutputType
  : FormReferenceCountOutputType




  // Custom InputTypes

  /**
   * FormReferenceCountOutputType without action
   */
  export type FormReferenceCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the FormReferenceCountOutputType
     * 
    **/
    select?: FormReferenceCountOutputTypeSelect | null
  }



  /**
   * Count Type ReferenceCountOutputType
   */


  export type ReferenceCountOutputType = {
    formReference: number
  }

  export type ReferenceCountOutputTypeSelect = {
    formReference?: boolean
  }

  export type ReferenceCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ReferenceCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ReferenceCountOutputType
    : S extends undefined
    ? never
    : S extends ReferenceCountOutputTypeArgs
    ?'include' extends U
    ? ReferenceCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof ReferenceCountOutputType ? ReferenceCountOutputType[P] : never
  } 
    : ReferenceCountOutputType
  : ReferenceCountOutputType




  // Custom InputTypes

  /**
   * ReferenceCountOutputType without action
   */
  export type ReferenceCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ReferenceCountOutputType
     * 
    **/
    select?: ReferenceCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model users
   */


  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersAvgAggregateOutputType = {
    id: number | null
  }

  export type UsersSumAggregateOutputType = {
    id: number | null
  }

  export type UsersMinAggregateOutputType = {
    id: number | null
    image: string | null
    username: string | null
    password: string | null
    isAdmin: boolean | null
    isSuperUser: boolean | null
    dateJoined: Date | null
    name: string | null
    updatedAt: Date | null
    isOnline: boolean | null
  }

  export type UsersMaxAggregateOutputType = {
    id: number | null
    image: string | null
    username: string | null
    password: string | null
    isAdmin: boolean | null
    isSuperUser: boolean | null
    dateJoined: Date | null
    name: string | null
    updatedAt: Date | null
    isOnline: boolean | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    image: number
    username: number
    password: number
    isAdmin: number
    isSuperUser: number
    dateJoined: number
    name: number
    updatedAt: number
    isOnline: number
    _all: number
  }


  export type UsersAvgAggregateInputType = {
    id?: true
  }

  export type UsersSumAggregateInputType = {
    id?: true
  }

  export type UsersMinAggregateInputType = {
    id?: true
    image?: true
    username?: true
    password?: true
    isAdmin?: true
    isSuperUser?: true
    dateJoined?: true
    name?: true
    updatedAt?: true
    isOnline?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    image?: true
    username?: true
    password?: true
    isAdmin?: true
    isSuperUser?: true
    dateJoined?: true
    name?: true
    updatedAt?: true
    isOnline?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    image?: true
    username?: true
    password?: true
    isAdmin?: true
    isSuperUser?: true
    dateJoined?: true
    name?: true
    updatedAt?: true
    isOnline?: true
    _all?: true
  }

  export type UsersAggregateArgs = {
    /**
     * Filter which users to aggregate.
     * 
    **/
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     * 
    **/
    orderBy?: Enumerable<usersOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type UsersGroupByArgs = {
    where?: usersWhereInput
    orderBy?: Enumerable<usersOrderByWithAggregationInput>
    by: Array<UsersScalarFieldEnum>
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _avg?: UsersAvgAggregateInputType
    _sum?: UsersSumAggregateInputType
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }


  export type UsersGroupByOutputType = {
    id: number
    image: string | null
    username: string
    password: string
    isAdmin: boolean
    isSuperUser: boolean
    dateJoined: Date
    name: string
    updatedAt: Date
    isOnline: boolean
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends UsersGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect = {
    id?: boolean
    image?: boolean
    username?: boolean
    password?: boolean
    isAdmin?: boolean
    isSuperUser?: boolean
    dateJoined?: boolean
    name?: boolean
    updatedAt?: boolean
    isOnline?: boolean
    exam?: boolean | examFindManyArgs
    examDownloadable?: boolean | examDownloadableFindManyArgs
    form?: boolean | formFindManyArgs
    formExams?: boolean | formExamsFindManyArgs
    formReference?: boolean | formReferenceFindManyArgs
    formReview?: boolean | formReviewFindManyArgs
    note?: boolean | noteFindManyArgs
    notesDownloadable?: boolean | notesDownloadableFindManyArgs
    purchase?: boolean | purchaseFindManyArgs
    question?: boolean | questionFindManyArgs
    reference?: boolean | referenceFindManyArgs
    review?: boolean | reviewFindManyArgs
    subject?: boolean | subjectFindManyArgs
    subjectExams?: boolean | subjectExamsFindManyArgs
    subjectReference?: boolean | subjectReferenceFindManyArgs
    subjectReview?: boolean | subjectReviewFindManyArgs
    topic?: boolean | topicFindManyArgs
    topicReview?: boolean | topicReviewFindManyArgs
    vifurushi?: boolean | vifurushiFindManyArgs
    _count?: boolean | UsersCountOutputTypeArgs
  }

  export type usersInclude = {
    exam?: boolean | examFindManyArgs
    examDownloadable?: boolean | examDownloadableFindManyArgs
    form?: boolean | formFindManyArgs
    formExams?: boolean | formExamsFindManyArgs
    formReference?: boolean | formReferenceFindManyArgs
    formReview?: boolean | formReviewFindManyArgs
    note?: boolean | noteFindManyArgs
    notesDownloadable?: boolean | notesDownloadableFindManyArgs
    purchase?: boolean | purchaseFindManyArgs
    question?: boolean | questionFindManyArgs
    reference?: boolean | referenceFindManyArgs
    review?: boolean | reviewFindManyArgs
    subject?: boolean | subjectFindManyArgs
    subjectExams?: boolean | subjectExamsFindManyArgs
    subjectReference?: boolean | subjectReferenceFindManyArgs
    subjectReview?: boolean | subjectReviewFindManyArgs
    topic?: boolean | topicFindManyArgs
    topicReview?: boolean | topicReviewFindManyArgs
    vifurushi?: boolean | vifurushiFindManyArgs
    _count?: boolean | UsersCountOutputTypeArgs
  }

  export type usersGetPayload<
    S extends boolean | null | undefined | usersArgs,
    U = keyof S
      > = S extends true
        ? users
    : S extends undefined
    ? never
    : S extends usersArgs | usersFindManyArgs
    ?'include' extends U
    ? users  & {
    [P in TrueKeys<S['include']>]:
        P extends 'exam' ? Array < examGetPayload<S['include'][P]>>  :
        P extends 'examDownloadable' ? Array < examDownloadableGetPayload<S['include'][P]>>  :
        P extends 'form' ? Array < formGetPayload<S['include'][P]>>  :
        P extends 'formExams' ? Array < formExamsGetPayload<S['include'][P]>>  :
        P extends 'formReference' ? Array < formReferenceGetPayload<S['include'][P]>>  :
        P extends 'formReview' ? Array < formReviewGetPayload<S['include'][P]>>  :
        P extends 'note' ? Array < noteGetPayload<S['include'][P]>>  :
        P extends 'notesDownloadable' ? Array < notesDownloadableGetPayload<S['include'][P]>>  :
        P extends 'purchase' ? Array < purchaseGetPayload<S['include'][P]>>  :
        P extends 'question' ? Array < questionGetPayload<S['include'][P]>>  :
        P extends 'reference' ? Array < referenceGetPayload<S['include'][P]>>  :
        P extends 'review' ? Array < reviewGetPayload<S['include'][P]>>  :
        P extends 'subject' ? Array < subjectGetPayload<S['include'][P]>>  :
        P extends 'subjectExams' ? Array < subjectExamsGetPayload<S['include'][P]>>  :
        P extends 'subjectReference' ? Array < subjectReferenceGetPayload<S['include'][P]>>  :
        P extends 'subjectReview' ? Array < subjectReviewGetPayload<S['include'][P]>>  :
        P extends 'topic' ? Array < topicGetPayload<S['include'][P]>>  :
        P extends 'topicReview' ? Array < topicReviewGetPayload<S['include'][P]>>  :
        P extends 'vifurushi' ? Array < vifurushiGetPayload<S['include'][P]>>  :
        P extends '_count' ? UsersCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'exam' ? Array < examGetPayload<S['select'][P]>>  :
        P extends 'examDownloadable' ? Array < examDownloadableGetPayload<S['select'][P]>>  :
        P extends 'form' ? Array < formGetPayload<S['select'][P]>>  :
        P extends 'formExams' ? Array < formExamsGetPayload<S['select'][P]>>  :
        P extends 'formReference' ? Array < formReferenceGetPayload<S['select'][P]>>  :
        P extends 'formReview' ? Array < formReviewGetPayload<S['select'][P]>>  :
        P extends 'note' ? Array < noteGetPayload<S['select'][P]>>  :
        P extends 'notesDownloadable' ? Array < notesDownloadableGetPayload<S['select'][P]>>  :
        P extends 'purchase' ? Array < purchaseGetPayload<S['select'][P]>>  :
        P extends 'question' ? Array < questionGetPayload<S['select'][P]>>  :
        P extends 'reference' ? Array < referenceGetPayload<S['select'][P]>>  :
        P extends 'review' ? Array < reviewGetPayload<S['select'][P]>>  :
        P extends 'subject' ? Array < subjectGetPayload<S['select'][P]>>  :
        P extends 'subjectExams' ? Array < subjectExamsGetPayload<S['select'][P]>>  :
        P extends 'subjectReference' ? Array < subjectReferenceGetPayload<S['select'][P]>>  :
        P extends 'subjectReview' ? Array < subjectReviewGetPayload<S['select'][P]>>  :
        P extends 'topic' ? Array < topicGetPayload<S['select'][P]>>  :
        P extends 'topicReview' ? Array < topicReviewGetPayload<S['select'][P]>>  :
        P extends 'vifurushi' ? Array < vifurushiGetPayload<S['select'][P]>>  :
        P extends '_count' ? UsersCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof users ? users[P] : never
  } 
    : users
  : users


  type usersCountArgs = Merge<
    Omit<usersFindManyArgs, 'select' | 'include'> & {
      select?: UsersCountAggregateInputType | true
    }
  >

  export interface usersDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends usersFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, usersFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'users'> extends True ? CheckSelect<T, Prisma__usersClient<users>, Prisma__usersClient<usersGetPayload<T>>> : CheckSelect<T, Prisma__usersClient<users | null >, Prisma__usersClient<usersGetPayload<T> | null >>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends usersFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, usersFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'users'> extends True ? CheckSelect<T, Prisma__usersClient<users>, Prisma__usersClient<usersGetPayload<T>>> : CheckSelect<T, Prisma__usersClient<users | null >, Prisma__usersClient<usersGetPayload<T> | null >>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends usersFindManyArgs>(
      args?: SelectSubset<T, usersFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<users>>, PrismaPromise<Array<usersGetPayload<T>>>>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
    **/
    create<T extends usersCreateArgs>(
      args: SelectSubset<T, usersCreateArgs>
    ): CheckSelect<T, Prisma__usersClient<users>, Prisma__usersClient<usersGetPayload<T>>>

    /**
     * Create many Users.
     *     @param {usersCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const users = await prisma.users.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends usersCreateManyArgs>(
      args?: SelectSubset<T, usersCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
    **/
    delete<T extends usersDeleteArgs>(
      args: SelectSubset<T, usersDeleteArgs>
    ): CheckSelect<T, Prisma__usersClient<users>, Prisma__usersClient<usersGetPayload<T>>>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends usersUpdateArgs>(
      args: SelectSubset<T, usersUpdateArgs>
    ): CheckSelect<T, Prisma__usersClient<users>, Prisma__usersClient<usersGetPayload<T>>>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends usersDeleteManyArgs>(
      args?: SelectSubset<T, usersDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends usersUpdateManyArgs>(
      args: SelectSubset<T, usersUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
    **/
    upsert<T extends usersUpsertArgs>(
      args: SelectSubset<T, usersUpsertArgs>
    ): CheckSelect<T, Prisma__usersClient<users>, Prisma__usersClient<usersGetPayload<T>>>

    /**
     * Find one Users that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, usersFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__usersClient<users>, Prisma__usersClient<usersGetPayload<T>>>

    /**
     * Find the first Users that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs>(
      args?: SelectSubset<T, usersFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__usersClient<users>, Prisma__usersClient<usersGetPayload<T>>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsersGroupByArgs['orderBy'] }
        : { orderBy?: UsersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__usersClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    exam<T extends examFindManyArgs = {}>(args?: Subset<T, examFindManyArgs>): CheckSelect<T, PrismaPromise<Array<exam>>, PrismaPromise<Array<examGetPayload<T>>>>;

    examDownloadable<T extends examDownloadableFindManyArgs = {}>(args?: Subset<T, examDownloadableFindManyArgs>): CheckSelect<T, PrismaPromise<Array<examDownloadable>>, PrismaPromise<Array<examDownloadableGetPayload<T>>>>;

    form<T extends formFindManyArgs = {}>(args?: Subset<T, formFindManyArgs>): CheckSelect<T, PrismaPromise<Array<form>>, PrismaPromise<Array<formGetPayload<T>>>>;

    formExams<T extends formExamsFindManyArgs = {}>(args?: Subset<T, formExamsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<formExams>>, PrismaPromise<Array<formExamsGetPayload<T>>>>;

    formReference<T extends formReferenceFindManyArgs = {}>(args?: Subset<T, formReferenceFindManyArgs>): CheckSelect<T, PrismaPromise<Array<formReference>>, PrismaPromise<Array<formReferenceGetPayload<T>>>>;

    formReview<T extends formReviewFindManyArgs = {}>(args?: Subset<T, formReviewFindManyArgs>): CheckSelect<T, PrismaPromise<Array<formReview>>, PrismaPromise<Array<formReviewGetPayload<T>>>>;

    note<T extends noteFindManyArgs = {}>(args?: Subset<T, noteFindManyArgs>): CheckSelect<T, PrismaPromise<Array<note>>, PrismaPromise<Array<noteGetPayload<T>>>>;

    notesDownloadable<T extends notesDownloadableFindManyArgs = {}>(args?: Subset<T, notesDownloadableFindManyArgs>): CheckSelect<T, PrismaPromise<Array<notesDownloadable>>, PrismaPromise<Array<notesDownloadableGetPayload<T>>>>;

    purchase<T extends purchaseFindManyArgs = {}>(args?: Subset<T, purchaseFindManyArgs>): CheckSelect<T, PrismaPromise<Array<purchase>>, PrismaPromise<Array<purchaseGetPayload<T>>>>;

    question<T extends questionFindManyArgs = {}>(args?: Subset<T, questionFindManyArgs>): CheckSelect<T, PrismaPromise<Array<question>>, PrismaPromise<Array<questionGetPayload<T>>>>;

    reference<T extends referenceFindManyArgs = {}>(args?: Subset<T, referenceFindManyArgs>): CheckSelect<T, PrismaPromise<Array<reference>>, PrismaPromise<Array<referenceGetPayload<T>>>>;

    review<T extends reviewFindManyArgs = {}>(args?: Subset<T, reviewFindManyArgs>): CheckSelect<T, PrismaPromise<Array<review>>, PrismaPromise<Array<reviewGetPayload<T>>>>;

    subject<T extends subjectFindManyArgs = {}>(args?: Subset<T, subjectFindManyArgs>): CheckSelect<T, PrismaPromise<Array<subject>>, PrismaPromise<Array<subjectGetPayload<T>>>>;

    subjectExams<T extends subjectExamsFindManyArgs = {}>(args?: Subset<T, subjectExamsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<subjectExams>>, PrismaPromise<Array<subjectExamsGetPayload<T>>>>;

    subjectReference<T extends subjectReferenceFindManyArgs = {}>(args?: Subset<T, subjectReferenceFindManyArgs>): CheckSelect<T, PrismaPromise<Array<subjectReference>>, PrismaPromise<Array<subjectReferenceGetPayload<T>>>>;

    subjectReview<T extends subjectReviewFindManyArgs = {}>(args?: Subset<T, subjectReviewFindManyArgs>): CheckSelect<T, PrismaPromise<Array<subjectReview>>, PrismaPromise<Array<subjectReviewGetPayload<T>>>>;

    topic<T extends topicFindManyArgs = {}>(args?: Subset<T, topicFindManyArgs>): CheckSelect<T, PrismaPromise<Array<topic>>, PrismaPromise<Array<topicGetPayload<T>>>>;

    topicReview<T extends topicReviewFindManyArgs = {}>(args?: Subset<T, topicReviewFindManyArgs>): CheckSelect<T, PrismaPromise<Array<topicReview>>, PrismaPromise<Array<topicReviewGetPayload<T>>>>;

    vifurushi<T extends vifurushiFindManyArgs = {}>(args?: Subset<T, vifurushiFindManyArgs>): CheckSelect<T, PrismaPromise<Array<vifurushi>>, PrismaPromise<Array<vifurushiGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * users base type for findUnique actions
   */
  export type usersFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the users
     * 
    **/
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usersInclude | null
    /**
     * Filter, which users to fetch.
     * 
    **/
    where: usersWhereUniqueInput
  }

  /**
   * users: findUnique
   */
  export interface usersFindUniqueArgs extends usersFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * users base type for findFirst actions
   */
  export type usersFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the users
     * 
    **/
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usersInclude | null
    /**
     * Filter, which users to fetch.
     * 
    **/
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     * 
    **/
    orderBy?: Enumerable<usersOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     * 
    **/
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     * 
    **/
    distinct?: Enumerable<UsersScalarFieldEnum>
  }

  /**
   * users: findFirst
   */
  export interface usersFindFirstArgs extends usersFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * users findMany
   */
  export type usersFindManyArgs = {
    /**
     * Select specific fields to fetch from the users
     * 
    **/
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usersInclude | null
    /**
     * Filter, which users to fetch.
     * 
    **/
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     * 
    **/
    orderBy?: Enumerable<usersOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     * 
    **/
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UsersScalarFieldEnum>
  }


  /**
   * users create
   */
  export type usersCreateArgs = {
    /**
     * Select specific fields to fetch from the users
     * 
    **/
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usersInclude | null
    /**
     * The data needed to create a users.
     * 
    **/
    data: XOR<usersCreateInput, usersUncheckedCreateInput>
  }


  /**
   * users createMany
   */
  export type usersCreateManyArgs = {
    /**
     * The data used to create many users.
     * 
    **/
    data: Enumerable<usersCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * users update
   */
  export type usersUpdateArgs = {
    /**
     * Select specific fields to fetch from the users
     * 
    **/
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usersInclude | null
    /**
     * The data needed to update a users.
     * 
    **/
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     * 
    **/
    where: usersWhereUniqueInput
  }


  /**
   * users updateMany
   */
  export type usersUpdateManyArgs = {
    /**
     * The data used to update users.
     * 
    **/
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     * 
    **/
    where?: usersWhereInput
  }


  /**
   * users upsert
   */
  export type usersUpsertArgs = {
    /**
     * Select specific fields to fetch from the users
     * 
    **/
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usersInclude | null
    /**
     * The filter to search for the users to update in case it exists.
     * 
    **/
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     * 
    **/
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }


  /**
   * users delete
   */
  export type usersDeleteArgs = {
    /**
     * Select specific fields to fetch from the users
     * 
    **/
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usersInclude | null
    /**
     * Filter which users to delete.
     * 
    **/
    where: usersWhereUniqueInput
  }


  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs = {
    /**
     * Filter which users to delete
     * 
    **/
    where?: usersWhereInput
  }


  /**
   * users: findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs = usersFindUniqueArgsBase
      

  /**
   * users: findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs = usersFindFirstArgsBase
      

  /**
   * users without action
   */
  export type usersArgs = {
    /**
     * Select specific fields to fetch from the users
     * 
    **/
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usersInclude | null
  }



  /**
   * Model vifurushi
   */


  export type AggregateVifurushi = {
    _count: VifurushiCountAggregateOutputType | null
    _avg: VifurushiAvgAggregateOutputType | null
    _sum: VifurushiSumAggregateOutputType | null
    _min: VifurushiMinAggregateOutputType | null
    _max: VifurushiMaxAggregateOutputType | null
  }

  export type VifurushiAvgAggregateOutputType = {
    id: number | null
    value: number | null
    usersId: number | null
  }

  export type VifurushiSumAggregateOutputType = {
    id: number | null
    value: number | null
    usersId: number | null
  }

  export type VifurushiMinAggregateOutputType = {
    id: number | null
    name: string | null
    value: number | null
    usersId: number | null
  }

  export type VifurushiMaxAggregateOutputType = {
    id: number | null
    name: string | null
    value: number | null
    usersId: number | null
  }

  export type VifurushiCountAggregateOutputType = {
    id: number
    name: number
    value: number
    usersId: number
    _all: number
  }


  export type VifurushiAvgAggregateInputType = {
    id?: true
    value?: true
    usersId?: true
  }

  export type VifurushiSumAggregateInputType = {
    id?: true
    value?: true
    usersId?: true
  }

  export type VifurushiMinAggregateInputType = {
    id?: true
    name?: true
    value?: true
    usersId?: true
  }

  export type VifurushiMaxAggregateInputType = {
    id?: true
    name?: true
    value?: true
    usersId?: true
  }

  export type VifurushiCountAggregateInputType = {
    id?: true
    name?: true
    value?: true
    usersId?: true
    _all?: true
  }

  export type VifurushiAggregateArgs = {
    /**
     * Filter which vifurushi to aggregate.
     * 
    **/
    where?: vifurushiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vifurushis to fetch.
     * 
    **/
    orderBy?: Enumerable<vifurushiOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: vifurushiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vifurushis from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vifurushis.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned vifurushis
    **/
    _count?: true | VifurushiCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VifurushiAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VifurushiSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VifurushiMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VifurushiMaxAggregateInputType
  }

  export type GetVifurushiAggregateType<T extends VifurushiAggregateArgs> = {
        [P in keyof T & keyof AggregateVifurushi]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVifurushi[P]>
      : GetScalarType<T[P], AggregateVifurushi[P]>
  }




  export type VifurushiGroupByArgs = {
    where?: vifurushiWhereInput
    orderBy?: Enumerable<vifurushiOrderByWithAggregationInput>
    by: Array<VifurushiScalarFieldEnum>
    having?: vifurushiScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VifurushiCountAggregateInputType | true
    _avg?: VifurushiAvgAggregateInputType
    _sum?: VifurushiSumAggregateInputType
    _min?: VifurushiMinAggregateInputType
    _max?: VifurushiMaxAggregateInputType
  }


  export type VifurushiGroupByOutputType = {
    id: number
    name: string
    value: number
    usersId: number
    _count: VifurushiCountAggregateOutputType | null
    _avg: VifurushiAvgAggregateOutputType | null
    _sum: VifurushiSumAggregateOutputType | null
    _min: VifurushiMinAggregateOutputType | null
    _max: VifurushiMaxAggregateOutputType | null
  }

  type GetVifurushiGroupByPayload<T extends VifurushiGroupByArgs> = PrismaPromise<
    Array<
      PickArray<VifurushiGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VifurushiGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VifurushiGroupByOutputType[P]>
            : GetScalarType<T[P], VifurushiGroupByOutputType[P]>
        }
      >
    >


  export type vifurushiSelect = {
    id?: boolean
    name?: boolean
    value?: boolean
    usersId?: boolean
    users?: boolean | usersArgs
  }

  export type vifurushiInclude = {
    users?: boolean | usersArgs
  }

  export type vifurushiGetPayload<
    S extends boolean | null | undefined | vifurushiArgs,
    U = keyof S
      > = S extends true
        ? vifurushi
    : S extends undefined
    ? never
    : S extends vifurushiArgs | vifurushiFindManyArgs
    ?'include' extends U
    ? vifurushi  & {
    [P in TrueKeys<S['include']>]:
        P extends 'users' ? usersGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'users' ? usersGetPayload<S['select'][P]> :  P extends keyof vifurushi ? vifurushi[P] : never
  } 
    : vifurushi
  : vifurushi


  type vifurushiCountArgs = Merge<
    Omit<vifurushiFindManyArgs, 'select' | 'include'> & {
      select?: VifurushiCountAggregateInputType | true
    }
  >

  export interface vifurushiDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Vifurushi that matches the filter.
     * @param {vifurushiFindUniqueArgs} args - Arguments to find a Vifurushi
     * @example
     * // Get one Vifurushi
     * const vifurushi = await prisma.vifurushi.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends vifurushiFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, vifurushiFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'vifurushi'> extends True ? CheckSelect<T, Prisma__vifurushiClient<vifurushi>, Prisma__vifurushiClient<vifurushiGetPayload<T>>> : CheckSelect<T, Prisma__vifurushiClient<vifurushi | null >, Prisma__vifurushiClient<vifurushiGetPayload<T> | null >>

    /**
     * Find the first Vifurushi that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vifurushiFindFirstArgs} args - Arguments to find a Vifurushi
     * @example
     * // Get one Vifurushi
     * const vifurushi = await prisma.vifurushi.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends vifurushiFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, vifurushiFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'vifurushi'> extends True ? CheckSelect<T, Prisma__vifurushiClient<vifurushi>, Prisma__vifurushiClient<vifurushiGetPayload<T>>> : CheckSelect<T, Prisma__vifurushiClient<vifurushi | null >, Prisma__vifurushiClient<vifurushiGetPayload<T> | null >>

    /**
     * Find zero or more Vifurushis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vifurushiFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vifurushis
     * const vifurushis = await prisma.vifurushi.findMany()
     * 
     * // Get first 10 Vifurushis
     * const vifurushis = await prisma.vifurushi.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vifurushiWithIdOnly = await prisma.vifurushi.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends vifurushiFindManyArgs>(
      args?: SelectSubset<T, vifurushiFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<vifurushi>>, PrismaPromise<Array<vifurushiGetPayload<T>>>>

    /**
     * Create a Vifurushi.
     * @param {vifurushiCreateArgs} args - Arguments to create a Vifurushi.
     * @example
     * // Create one Vifurushi
     * const Vifurushi = await prisma.vifurushi.create({
     *   data: {
     *     // ... data to create a Vifurushi
     *   }
     * })
     * 
    **/
    create<T extends vifurushiCreateArgs>(
      args: SelectSubset<T, vifurushiCreateArgs>
    ): CheckSelect<T, Prisma__vifurushiClient<vifurushi>, Prisma__vifurushiClient<vifurushiGetPayload<T>>>

    /**
     * Create many Vifurushis.
     *     @param {vifurushiCreateManyArgs} args - Arguments to create many Vifurushis.
     *     @example
     *     // Create many Vifurushis
     *     const vifurushi = await prisma.vifurushi.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends vifurushiCreateManyArgs>(
      args?: SelectSubset<T, vifurushiCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Vifurushi.
     * @param {vifurushiDeleteArgs} args - Arguments to delete one Vifurushi.
     * @example
     * // Delete one Vifurushi
     * const Vifurushi = await prisma.vifurushi.delete({
     *   where: {
     *     // ... filter to delete one Vifurushi
     *   }
     * })
     * 
    **/
    delete<T extends vifurushiDeleteArgs>(
      args: SelectSubset<T, vifurushiDeleteArgs>
    ): CheckSelect<T, Prisma__vifurushiClient<vifurushi>, Prisma__vifurushiClient<vifurushiGetPayload<T>>>

    /**
     * Update one Vifurushi.
     * @param {vifurushiUpdateArgs} args - Arguments to update one Vifurushi.
     * @example
     * // Update one Vifurushi
     * const vifurushi = await prisma.vifurushi.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends vifurushiUpdateArgs>(
      args: SelectSubset<T, vifurushiUpdateArgs>
    ): CheckSelect<T, Prisma__vifurushiClient<vifurushi>, Prisma__vifurushiClient<vifurushiGetPayload<T>>>

    /**
     * Delete zero or more Vifurushis.
     * @param {vifurushiDeleteManyArgs} args - Arguments to filter Vifurushis to delete.
     * @example
     * // Delete a few Vifurushis
     * const { count } = await prisma.vifurushi.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends vifurushiDeleteManyArgs>(
      args?: SelectSubset<T, vifurushiDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vifurushis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vifurushiUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vifurushis
     * const vifurushi = await prisma.vifurushi.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends vifurushiUpdateManyArgs>(
      args: SelectSubset<T, vifurushiUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Vifurushi.
     * @param {vifurushiUpsertArgs} args - Arguments to update or create a Vifurushi.
     * @example
     * // Update or create a Vifurushi
     * const vifurushi = await prisma.vifurushi.upsert({
     *   create: {
     *     // ... data to create a Vifurushi
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vifurushi we want to update
     *   }
     * })
    **/
    upsert<T extends vifurushiUpsertArgs>(
      args: SelectSubset<T, vifurushiUpsertArgs>
    ): CheckSelect<T, Prisma__vifurushiClient<vifurushi>, Prisma__vifurushiClient<vifurushiGetPayload<T>>>

    /**
     * Find one Vifurushi that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {vifurushiFindUniqueOrThrowArgs} args - Arguments to find a Vifurushi
     * @example
     * // Get one Vifurushi
     * const vifurushi = await prisma.vifurushi.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends vifurushiFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, vifurushiFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__vifurushiClient<vifurushi>, Prisma__vifurushiClient<vifurushiGetPayload<T>>>

    /**
     * Find the first Vifurushi that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vifurushiFindFirstOrThrowArgs} args - Arguments to find a Vifurushi
     * @example
     * // Get one Vifurushi
     * const vifurushi = await prisma.vifurushi.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends vifurushiFindFirstOrThrowArgs>(
      args?: SelectSubset<T, vifurushiFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__vifurushiClient<vifurushi>, Prisma__vifurushiClient<vifurushiGetPayload<T>>>

    /**
     * Count the number of Vifurushis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vifurushiCountArgs} args - Arguments to filter Vifurushis to count.
     * @example
     * // Count the number of Vifurushis
     * const count = await prisma.vifurushi.count({
     *   where: {
     *     // ... the filter for the Vifurushis we want to count
     *   }
     * })
    **/
    count<T extends vifurushiCountArgs>(
      args?: Subset<T, vifurushiCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VifurushiCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vifurushi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VifurushiAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VifurushiAggregateArgs>(args: Subset<T, VifurushiAggregateArgs>): PrismaPromise<GetVifurushiAggregateType<T>>

    /**
     * Group by Vifurushi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VifurushiGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VifurushiGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VifurushiGroupByArgs['orderBy'] }
        : { orderBy?: VifurushiGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VifurushiGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVifurushiGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for vifurushi.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__vifurushiClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    users<T extends usersArgs = {}>(args?: Subset<T, usersArgs>): CheckSelect<T, Prisma__usersClient<users | null >, Prisma__usersClient<usersGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * vifurushi base type for findUnique actions
   */
  export type vifurushiFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the vifurushi
     * 
    **/
    select?: vifurushiSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: vifurushiInclude | null
    /**
     * Filter, which vifurushi to fetch.
     * 
    **/
    where: vifurushiWhereUniqueInput
  }

  /**
   * vifurushi: findUnique
   */
  export interface vifurushiFindUniqueArgs extends vifurushiFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * vifurushi base type for findFirst actions
   */
  export type vifurushiFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the vifurushi
     * 
    **/
    select?: vifurushiSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: vifurushiInclude | null
    /**
     * Filter, which vifurushi to fetch.
     * 
    **/
    where?: vifurushiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vifurushis to fetch.
     * 
    **/
    orderBy?: Enumerable<vifurushiOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for vifurushis.
     * 
    **/
    cursor?: vifurushiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vifurushis from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vifurushis.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of vifurushis.
     * 
    **/
    distinct?: Enumerable<VifurushiScalarFieldEnum>
  }

  /**
   * vifurushi: findFirst
   */
  export interface vifurushiFindFirstArgs extends vifurushiFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * vifurushi findMany
   */
  export type vifurushiFindManyArgs = {
    /**
     * Select specific fields to fetch from the vifurushi
     * 
    **/
    select?: vifurushiSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: vifurushiInclude | null
    /**
     * Filter, which vifurushis to fetch.
     * 
    **/
    where?: vifurushiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vifurushis to fetch.
     * 
    **/
    orderBy?: Enumerable<vifurushiOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing vifurushis.
     * 
    **/
    cursor?: vifurushiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vifurushis from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vifurushis.
     * 
    **/
    skip?: number
    distinct?: Enumerable<VifurushiScalarFieldEnum>
  }


  /**
   * vifurushi create
   */
  export type vifurushiCreateArgs = {
    /**
     * Select specific fields to fetch from the vifurushi
     * 
    **/
    select?: vifurushiSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: vifurushiInclude | null
    /**
     * The data needed to create a vifurushi.
     * 
    **/
    data: XOR<vifurushiCreateInput, vifurushiUncheckedCreateInput>
  }


  /**
   * vifurushi createMany
   */
  export type vifurushiCreateManyArgs = {
    /**
     * The data used to create many vifurushis.
     * 
    **/
    data: Enumerable<vifurushiCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * vifurushi update
   */
  export type vifurushiUpdateArgs = {
    /**
     * Select specific fields to fetch from the vifurushi
     * 
    **/
    select?: vifurushiSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: vifurushiInclude | null
    /**
     * The data needed to update a vifurushi.
     * 
    **/
    data: XOR<vifurushiUpdateInput, vifurushiUncheckedUpdateInput>
    /**
     * Choose, which vifurushi to update.
     * 
    **/
    where: vifurushiWhereUniqueInput
  }


  /**
   * vifurushi updateMany
   */
  export type vifurushiUpdateManyArgs = {
    /**
     * The data used to update vifurushis.
     * 
    **/
    data: XOR<vifurushiUpdateManyMutationInput, vifurushiUncheckedUpdateManyInput>
    /**
     * Filter which vifurushis to update
     * 
    **/
    where?: vifurushiWhereInput
  }


  /**
   * vifurushi upsert
   */
  export type vifurushiUpsertArgs = {
    /**
     * Select specific fields to fetch from the vifurushi
     * 
    **/
    select?: vifurushiSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: vifurushiInclude | null
    /**
     * The filter to search for the vifurushi to update in case it exists.
     * 
    **/
    where: vifurushiWhereUniqueInput
    /**
     * In case the vifurushi found by the `where` argument doesn't exist, create a new vifurushi with this data.
     * 
    **/
    create: XOR<vifurushiCreateInput, vifurushiUncheckedCreateInput>
    /**
     * In case the vifurushi was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<vifurushiUpdateInput, vifurushiUncheckedUpdateInput>
  }


  /**
   * vifurushi delete
   */
  export type vifurushiDeleteArgs = {
    /**
     * Select specific fields to fetch from the vifurushi
     * 
    **/
    select?: vifurushiSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: vifurushiInclude | null
    /**
     * Filter which vifurushi to delete.
     * 
    **/
    where: vifurushiWhereUniqueInput
  }


  /**
   * vifurushi deleteMany
   */
  export type vifurushiDeleteManyArgs = {
    /**
     * Filter which vifurushis to delete
     * 
    **/
    where?: vifurushiWhereInput
  }


  /**
   * vifurushi: findUniqueOrThrow
   */
  export type vifurushiFindUniqueOrThrowArgs = vifurushiFindUniqueArgsBase
      

  /**
   * vifurushi: findFirstOrThrow
   */
  export type vifurushiFindFirstOrThrowArgs = vifurushiFindFirstArgsBase
      

  /**
   * vifurushi without action
   */
  export type vifurushiArgs = {
    /**
     * Select specific fields to fetch from the vifurushi
     * 
    **/
    select?: vifurushiSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: vifurushiInclude | null
  }



  /**
   * Model vifurushiPrice
   */


  export type AggregateVifurushiPrice = {
    _count: VifurushiPriceCountAggregateOutputType | null
    _avg: VifurushiPriceAvgAggregateOutputType | null
    _sum: VifurushiPriceSumAggregateOutputType | null
    _min: VifurushiPriceMinAggregateOutputType | null
    _max: VifurushiPriceMaxAggregateOutputType | null
  }

  export type VifurushiPriceAvgAggregateOutputType = {
    id: number | null
    price: number | null
  }

  export type VifurushiPriceSumAggregateOutputType = {
    id: number | null
    price: number | null
  }

  export type VifurushiPriceMinAggregateOutputType = {
    id: number | null
    name: string | null
    price: number | null
  }

  export type VifurushiPriceMaxAggregateOutputType = {
    id: number | null
    name: string | null
    price: number | null
  }

  export type VifurushiPriceCountAggregateOutputType = {
    id: number
    name: number
    price: number
    _all: number
  }


  export type VifurushiPriceAvgAggregateInputType = {
    id?: true
    price?: true
  }

  export type VifurushiPriceSumAggregateInputType = {
    id?: true
    price?: true
  }

  export type VifurushiPriceMinAggregateInputType = {
    id?: true
    name?: true
    price?: true
  }

  export type VifurushiPriceMaxAggregateInputType = {
    id?: true
    name?: true
    price?: true
  }

  export type VifurushiPriceCountAggregateInputType = {
    id?: true
    name?: true
    price?: true
    _all?: true
  }

  export type VifurushiPriceAggregateArgs = {
    /**
     * Filter which vifurushiPrice to aggregate.
     * 
    **/
    where?: vifurushiPriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vifurushiPrices to fetch.
     * 
    **/
    orderBy?: Enumerable<vifurushiPriceOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: vifurushiPriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vifurushiPrices from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vifurushiPrices.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned vifurushiPrices
    **/
    _count?: true | VifurushiPriceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VifurushiPriceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VifurushiPriceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VifurushiPriceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VifurushiPriceMaxAggregateInputType
  }

  export type GetVifurushiPriceAggregateType<T extends VifurushiPriceAggregateArgs> = {
        [P in keyof T & keyof AggregateVifurushiPrice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVifurushiPrice[P]>
      : GetScalarType<T[P], AggregateVifurushiPrice[P]>
  }




  export type VifurushiPriceGroupByArgs = {
    where?: vifurushiPriceWhereInput
    orderBy?: Enumerable<vifurushiPriceOrderByWithAggregationInput>
    by: Array<VifurushiPriceScalarFieldEnum>
    having?: vifurushiPriceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VifurushiPriceCountAggregateInputType | true
    _avg?: VifurushiPriceAvgAggregateInputType
    _sum?: VifurushiPriceSumAggregateInputType
    _min?: VifurushiPriceMinAggregateInputType
    _max?: VifurushiPriceMaxAggregateInputType
  }


  export type VifurushiPriceGroupByOutputType = {
    id: number
    name: string
    price: number
    _count: VifurushiPriceCountAggregateOutputType | null
    _avg: VifurushiPriceAvgAggregateOutputType | null
    _sum: VifurushiPriceSumAggregateOutputType | null
    _min: VifurushiPriceMinAggregateOutputType | null
    _max: VifurushiPriceMaxAggregateOutputType | null
  }

  type GetVifurushiPriceGroupByPayload<T extends VifurushiPriceGroupByArgs> = PrismaPromise<
    Array<
      PickArray<VifurushiPriceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VifurushiPriceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VifurushiPriceGroupByOutputType[P]>
            : GetScalarType<T[P], VifurushiPriceGroupByOutputType[P]>
        }
      >
    >


  export type vifurushiPriceSelect = {
    id?: boolean
    name?: boolean
    price?: boolean
  }

  export type vifurushiPriceGetPayload<
    S extends boolean | null | undefined | vifurushiPriceArgs,
    U = keyof S
      > = S extends true
        ? vifurushiPrice
    : S extends undefined
    ? never
    : S extends vifurushiPriceArgs | vifurushiPriceFindManyArgs
    ?'include' extends U
    ? vifurushiPrice 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof vifurushiPrice ? vifurushiPrice[P] : never
  } 
    : vifurushiPrice
  : vifurushiPrice


  type vifurushiPriceCountArgs = Merge<
    Omit<vifurushiPriceFindManyArgs, 'select' | 'include'> & {
      select?: VifurushiPriceCountAggregateInputType | true
    }
  >

  export interface vifurushiPriceDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one VifurushiPrice that matches the filter.
     * @param {vifurushiPriceFindUniqueArgs} args - Arguments to find a VifurushiPrice
     * @example
     * // Get one VifurushiPrice
     * const vifurushiPrice = await prisma.vifurushiPrice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends vifurushiPriceFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, vifurushiPriceFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'vifurushiPrice'> extends True ? CheckSelect<T, Prisma__vifurushiPriceClient<vifurushiPrice>, Prisma__vifurushiPriceClient<vifurushiPriceGetPayload<T>>> : CheckSelect<T, Prisma__vifurushiPriceClient<vifurushiPrice | null >, Prisma__vifurushiPriceClient<vifurushiPriceGetPayload<T> | null >>

    /**
     * Find the first VifurushiPrice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vifurushiPriceFindFirstArgs} args - Arguments to find a VifurushiPrice
     * @example
     * // Get one VifurushiPrice
     * const vifurushiPrice = await prisma.vifurushiPrice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends vifurushiPriceFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, vifurushiPriceFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'vifurushiPrice'> extends True ? CheckSelect<T, Prisma__vifurushiPriceClient<vifurushiPrice>, Prisma__vifurushiPriceClient<vifurushiPriceGetPayload<T>>> : CheckSelect<T, Prisma__vifurushiPriceClient<vifurushiPrice | null >, Prisma__vifurushiPriceClient<vifurushiPriceGetPayload<T> | null >>

    /**
     * Find zero or more VifurushiPrices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vifurushiPriceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VifurushiPrices
     * const vifurushiPrices = await prisma.vifurushiPrice.findMany()
     * 
     * // Get first 10 VifurushiPrices
     * const vifurushiPrices = await prisma.vifurushiPrice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vifurushiPriceWithIdOnly = await prisma.vifurushiPrice.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends vifurushiPriceFindManyArgs>(
      args?: SelectSubset<T, vifurushiPriceFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<vifurushiPrice>>, PrismaPromise<Array<vifurushiPriceGetPayload<T>>>>

    /**
     * Create a VifurushiPrice.
     * @param {vifurushiPriceCreateArgs} args - Arguments to create a VifurushiPrice.
     * @example
     * // Create one VifurushiPrice
     * const VifurushiPrice = await prisma.vifurushiPrice.create({
     *   data: {
     *     // ... data to create a VifurushiPrice
     *   }
     * })
     * 
    **/
    create<T extends vifurushiPriceCreateArgs>(
      args: SelectSubset<T, vifurushiPriceCreateArgs>
    ): CheckSelect<T, Prisma__vifurushiPriceClient<vifurushiPrice>, Prisma__vifurushiPriceClient<vifurushiPriceGetPayload<T>>>

    /**
     * Create many VifurushiPrices.
     *     @param {vifurushiPriceCreateManyArgs} args - Arguments to create many VifurushiPrices.
     *     @example
     *     // Create many VifurushiPrices
     *     const vifurushiPrice = await prisma.vifurushiPrice.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends vifurushiPriceCreateManyArgs>(
      args?: SelectSubset<T, vifurushiPriceCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a VifurushiPrice.
     * @param {vifurushiPriceDeleteArgs} args - Arguments to delete one VifurushiPrice.
     * @example
     * // Delete one VifurushiPrice
     * const VifurushiPrice = await prisma.vifurushiPrice.delete({
     *   where: {
     *     // ... filter to delete one VifurushiPrice
     *   }
     * })
     * 
    **/
    delete<T extends vifurushiPriceDeleteArgs>(
      args: SelectSubset<T, vifurushiPriceDeleteArgs>
    ): CheckSelect<T, Prisma__vifurushiPriceClient<vifurushiPrice>, Prisma__vifurushiPriceClient<vifurushiPriceGetPayload<T>>>

    /**
     * Update one VifurushiPrice.
     * @param {vifurushiPriceUpdateArgs} args - Arguments to update one VifurushiPrice.
     * @example
     * // Update one VifurushiPrice
     * const vifurushiPrice = await prisma.vifurushiPrice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends vifurushiPriceUpdateArgs>(
      args: SelectSubset<T, vifurushiPriceUpdateArgs>
    ): CheckSelect<T, Prisma__vifurushiPriceClient<vifurushiPrice>, Prisma__vifurushiPriceClient<vifurushiPriceGetPayload<T>>>

    /**
     * Delete zero or more VifurushiPrices.
     * @param {vifurushiPriceDeleteManyArgs} args - Arguments to filter VifurushiPrices to delete.
     * @example
     * // Delete a few VifurushiPrices
     * const { count } = await prisma.vifurushiPrice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends vifurushiPriceDeleteManyArgs>(
      args?: SelectSubset<T, vifurushiPriceDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more VifurushiPrices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vifurushiPriceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VifurushiPrices
     * const vifurushiPrice = await prisma.vifurushiPrice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends vifurushiPriceUpdateManyArgs>(
      args: SelectSubset<T, vifurushiPriceUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one VifurushiPrice.
     * @param {vifurushiPriceUpsertArgs} args - Arguments to update or create a VifurushiPrice.
     * @example
     * // Update or create a VifurushiPrice
     * const vifurushiPrice = await prisma.vifurushiPrice.upsert({
     *   create: {
     *     // ... data to create a VifurushiPrice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VifurushiPrice we want to update
     *   }
     * })
    **/
    upsert<T extends vifurushiPriceUpsertArgs>(
      args: SelectSubset<T, vifurushiPriceUpsertArgs>
    ): CheckSelect<T, Prisma__vifurushiPriceClient<vifurushiPrice>, Prisma__vifurushiPriceClient<vifurushiPriceGetPayload<T>>>

    /**
     * Find one VifurushiPrice that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {vifurushiPriceFindUniqueOrThrowArgs} args - Arguments to find a VifurushiPrice
     * @example
     * // Get one VifurushiPrice
     * const vifurushiPrice = await prisma.vifurushiPrice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends vifurushiPriceFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, vifurushiPriceFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__vifurushiPriceClient<vifurushiPrice>, Prisma__vifurushiPriceClient<vifurushiPriceGetPayload<T>>>

    /**
     * Find the first VifurushiPrice that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vifurushiPriceFindFirstOrThrowArgs} args - Arguments to find a VifurushiPrice
     * @example
     * // Get one VifurushiPrice
     * const vifurushiPrice = await prisma.vifurushiPrice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends vifurushiPriceFindFirstOrThrowArgs>(
      args?: SelectSubset<T, vifurushiPriceFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__vifurushiPriceClient<vifurushiPrice>, Prisma__vifurushiPriceClient<vifurushiPriceGetPayload<T>>>

    /**
     * Count the number of VifurushiPrices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vifurushiPriceCountArgs} args - Arguments to filter VifurushiPrices to count.
     * @example
     * // Count the number of VifurushiPrices
     * const count = await prisma.vifurushiPrice.count({
     *   where: {
     *     // ... the filter for the VifurushiPrices we want to count
     *   }
     * })
    **/
    count<T extends vifurushiPriceCountArgs>(
      args?: Subset<T, vifurushiPriceCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VifurushiPriceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VifurushiPrice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VifurushiPriceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VifurushiPriceAggregateArgs>(args: Subset<T, VifurushiPriceAggregateArgs>): PrismaPromise<GetVifurushiPriceAggregateType<T>>

    /**
     * Group by VifurushiPrice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VifurushiPriceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VifurushiPriceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VifurushiPriceGroupByArgs['orderBy'] }
        : { orderBy?: VifurushiPriceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VifurushiPriceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVifurushiPriceGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for vifurushiPrice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__vifurushiPriceClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * vifurushiPrice base type for findUnique actions
   */
  export type vifurushiPriceFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the vifurushiPrice
     * 
    **/
    select?: vifurushiPriceSelect | null
    /**
     * Filter, which vifurushiPrice to fetch.
     * 
    **/
    where: vifurushiPriceWhereUniqueInput
  }

  /**
   * vifurushiPrice: findUnique
   */
  export interface vifurushiPriceFindUniqueArgs extends vifurushiPriceFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * vifurushiPrice base type for findFirst actions
   */
  export type vifurushiPriceFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the vifurushiPrice
     * 
    **/
    select?: vifurushiPriceSelect | null
    /**
     * Filter, which vifurushiPrice to fetch.
     * 
    **/
    where?: vifurushiPriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vifurushiPrices to fetch.
     * 
    **/
    orderBy?: Enumerable<vifurushiPriceOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for vifurushiPrices.
     * 
    **/
    cursor?: vifurushiPriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vifurushiPrices from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vifurushiPrices.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of vifurushiPrices.
     * 
    **/
    distinct?: Enumerable<VifurushiPriceScalarFieldEnum>
  }

  /**
   * vifurushiPrice: findFirst
   */
  export interface vifurushiPriceFindFirstArgs extends vifurushiPriceFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * vifurushiPrice findMany
   */
  export type vifurushiPriceFindManyArgs = {
    /**
     * Select specific fields to fetch from the vifurushiPrice
     * 
    **/
    select?: vifurushiPriceSelect | null
    /**
     * Filter, which vifurushiPrices to fetch.
     * 
    **/
    where?: vifurushiPriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vifurushiPrices to fetch.
     * 
    **/
    orderBy?: Enumerable<vifurushiPriceOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing vifurushiPrices.
     * 
    **/
    cursor?: vifurushiPriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vifurushiPrices from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vifurushiPrices.
     * 
    **/
    skip?: number
    distinct?: Enumerable<VifurushiPriceScalarFieldEnum>
  }


  /**
   * vifurushiPrice create
   */
  export type vifurushiPriceCreateArgs = {
    /**
     * Select specific fields to fetch from the vifurushiPrice
     * 
    **/
    select?: vifurushiPriceSelect | null
    /**
     * The data needed to create a vifurushiPrice.
     * 
    **/
    data: XOR<vifurushiPriceCreateInput, vifurushiPriceUncheckedCreateInput>
  }


  /**
   * vifurushiPrice createMany
   */
  export type vifurushiPriceCreateManyArgs = {
    /**
     * The data used to create many vifurushiPrices.
     * 
    **/
    data: Enumerable<vifurushiPriceCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * vifurushiPrice update
   */
  export type vifurushiPriceUpdateArgs = {
    /**
     * Select specific fields to fetch from the vifurushiPrice
     * 
    **/
    select?: vifurushiPriceSelect | null
    /**
     * The data needed to update a vifurushiPrice.
     * 
    **/
    data: XOR<vifurushiPriceUpdateInput, vifurushiPriceUncheckedUpdateInput>
    /**
     * Choose, which vifurushiPrice to update.
     * 
    **/
    where: vifurushiPriceWhereUniqueInput
  }


  /**
   * vifurushiPrice updateMany
   */
  export type vifurushiPriceUpdateManyArgs = {
    /**
     * The data used to update vifurushiPrices.
     * 
    **/
    data: XOR<vifurushiPriceUpdateManyMutationInput, vifurushiPriceUncheckedUpdateManyInput>
    /**
     * Filter which vifurushiPrices to update
     * 
    **/
    where?: vifurushiPriceWhereInput
  }


  /**
   * vifurushiPrice upsert
   */
  export type vifurushiPriceUpsertArgs = {
    /**
     * Select specific fields to fetch from the vifurushiPrice
     * 
    **/
    select?: vifurushiPriceSelect | null
    /**
     * The filter to search for the vifurushiPrice to update in case it exists.
     * 
    **/
    where: vifurushiPriceWhereUniqueInput
    /**
     * In case the vifurushiPrice found by the `where` argument doesn't exist, create a new vifurushiPrice with this data.
     * 
    **/
    create: XOR<vifurushiPriceCreateInput, vifurushiPriceUncheckedCreateInput>
    /**
     * In case the vifurushiPrice was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<vifurushiPriceUpdateInput, vifurushiPriceUncheckedUpdateInput>
  }


  /**
   * vifurushiPrice delete
   */
  export type vifurushiPriceDeleteArgs = {
    /**
     * Select specific fields to fetch from the vifurushiPrice
     * 
    **/
    select?: vifurushiPriceSelect | null
    /**
     * Filter which vifurushiPrice to delete.
     * 
    **/
    where: vifurushiPriceWhereUniqueInput
  }


  /**
   * vifurushiPrice deleteMany
   */
  export type vifurushiPriceDeleteManyArgs = {
    /**
     * Filter which vifurushiPrices to delete
     * 
    **/
    where?: vifurushiPriceWhereInput
  }


  /**
   * vifurushiPrice: findUniqueOrThrow
   */
  export type vifurushiPriceFindUniqueOrThrowArgs = vifurushiPriceFindUniqueArgsBase
      

  /**
   * vifurushiPrice: findFirstOrThrow
   */
  export type vifurushiPriceFindFirstOrThrowArgs = vifurushiPriceFindFirstArgsBase
      

  /**
   * vifurushiPrice without action
   */
  export type vifurushiPriceArgs = {
    /**
     * Select specific fields to fetch from the vifurushiPrice
     * 
    **/
    select?: vifurushiPriceSelect | null
  }



  /**
   * Model vifurushiPackage
   */


  export type AggregateVifurushiPackage = {
    _count: VifurushiPackageCountAggregateOutputType | null
    _avg: VifurushiPackageAvgAggregateOutputType | null
    _sum: VifurushiPackageSumAggregateOutputType | null
    _min: VifurushiPackageMinAggregateOutputType | null
    _max: VifurushiPackageMaxAggregateOutputType | null
  }

  export type VifurushiPackageAvgAggregateOutputType = {
    id: number | null
    value: number | null
  }

  export type VifurushiPackageSumAggregateOutputType = {
    id: number | null
    value: number | null
  }

  export type VifurushiPackageMinAggregateOutputType = {
    id: number | null
    name: string | null
    value: number | null
  }

  export type VifurushiPackageMaxAggregateOutputType = {
    id: number | null
    name: string | null
    value: number | null
  }

  export type VifurushiPackageCountAggregateOutputType = {
    id: number
    name: number
    value: number
    _all: number
  }


  export type VifurushiPackageAvgAggregateInputType = {
    id?: true
    value?: true
  }

  export type VifurushiPackageSumAggregateInputType = {
    id?: true
    value?: true
  }

  export type VifurushiPackageMinAggregateInputType = {
    id?: true
    name?: true
    value?: true
  }

  export type VifurushiPackageMaxAggregateInputType = {
    id?: true
    name?: true
    value?: true
  }

  export type VifurushiPackageCountAggregateInputType = {
    id?: true
    name?: true
    value?: true
    _all?: true
  }

  export type VifurushiPackageAggregateArgs = {
    /**
     * Filter which vifurushiPackage to aggregate.
     * 
    **/
    where?: vifurushiPackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vifurushiPackages to fetch.
     * 
    **/
    orderBy?: Enumerable<vifurushiPackageOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: vifurushiPackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vifurushiPackages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vifurushiPackages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned vifurushiPackages
    **/
    _count?: true | VifurushiPackageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VifurushiPackageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VifurushiPackageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VifurushiPackageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VifurushiPackageMaxAggregateInputType
  }

  export type GetVifurushiPackageAggregateType<T extends VifurushiPackageAggregateArgs> = {
        [P in keyof T & keyof AggregateVifurushiPackage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVifurushiPackage[P]>
      : GetScalarType<T[P], AggregateVifurushiPackage[P]>
  }




  export type VifurushiPackageGroupByArgs = {
    where?: vifurushiPackageWhereInput
    orderBy?: Enumerable<vifurushiPackageOrderByWithAggregationInput>
    by: Array<VifurushiPackageScalarFieldEnum>
    having?: vifurushiPackageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VifurushiPackageCountAggregateInputType | true
    _avg?: VifurushiPackageAvgAggregateInputType
    _sum?: VifurushiPackageSumAggregateInputType
    _min?: VifurushiPackageMinAggregateInputType
    _max?: VifurushiPackageMaxAggregateInputType
  }


  export type VifurushiPackageGroupByOutputType = {
    id: number
    name: string
    value: number
    _count: VifurushiPackageCountAggregateOutputType | null
    _avg: VifurushiPackageAvgAggregateOutputType | null
    _sum: VifurushiPackageSumAggregateOutputType | null
    _min: VifurushiPackageMinAggregateOutputType | null
    _max: VifurushiPackageMaxAggregateOutputType | null
  }

  type GetVifurushiPackageGroupByPayload<T extends VifurushiPackageGroupByArgs> = PrismaPromise<
    Array<
      PickArray<VifurushiPackageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VifurushiPackageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VifurushiPackageGroupByOutputType[P]>
            : GetScalarType<T[P], VifurushiPackageGroupByOutputType[P]>
        }
      >
    >


  export type vifurushiPackageSelect = {
    id?: boolean
    name?: boolean
    value?: boolean
    booksDownload?: boolean | booksDownloadArgs
    examAccess?: boolean | examAccessArgs
    examsSolvedDownload?: boolean | examsSolvedDownloadArgs
    examsUnsolvedDownload?: boolean | examsUnsolvedDownloadArgs
    notesDownload?: boolean | notesDownloadArgs
    quizExcercises?: boolean | quizExcercisesArgs
  }

  export type vifurushiPackageInclude = {
    booksDownload?: boolean | booksDownloadArgs
    examAccess?: boolean | examAccessArgs
    examsSolvedDownload?: boolean | examsSolvedDownloadArgs
    examsUnsolvedDownload?: boolean | examsUnsolvedDownloadArgs
    notesDownload?: boolean | notesDownloadArgs
    quizExcercises?: boolean | quizExcercisesArgs
  }

  export type vifurushiPackageGetPayload<
    S extends boolean | null | undefined | vifurushiPackageArgs,
    U = keyof S
      > = S extends true
        ? vifurushiPackage
    : S extends undefined
    ? never
    : S extends vifurushiPackageArgs | vifurushiPackageFindManyArgs
    ?'include' extends U
    ? vifurushiPackage  & {
    [P in TrueKeys<S['include']>]:
        P extends 'booksDownload' ? booksDownloadGetPayload<S['include'][P]> | null :
        P extends 'examAccess' ? examAccessGetPayload<S['include'][P]> | null :
        P extends 'examsSolvedDownload' ? examsSolvedDownloadGetPayload<S['include'][P]> | null :
        P extends 'examsUnsolvedDownload' ? examsUnsolvedDownloadGetPayload<S['include'][P]> | null :
        P extends 'notesDownload' ? notesDownloadGetPayload<S['include'][P]> | null :
        P extends 'quizExcercises' ? quizExcercisesGetPayload<S['include'][P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'booksDownload' ? booksDownloadGetPayload<S['select'][P]> | null :
        P extends 'examAccess' ? examAccessGetPayload<S['select'][P]> | null :
        P extends 'examsSolvedDownload' ? examsSolvedDownloadGetPayload<S['select'][P]> | null :
        P extends 'examsUnsolvedDownload' ? examsUnsolvedDownloadGetPayload<S['select'][P]> | null :
        P extends 'notesDownload' ? notesDownloadGetPayload<S['select'][P]> | null :
        P extends 'quizExcercises' ? quizExcercisesGetPayload<S['select'][P]> | null :  P extends keyof vifurushiPackage ? vifurushiPackage[P] : never
  } 
    : vifurushiPackage
  : vifurushiPackage


  type vifurushiPackageCountArgs = Merge<
    Omit<vifurushiPackageFindManyArgs, 'select' | 'include'> & {
      select?: VifurushiPackageCountAggregateInputType | true
    }
  >

  export interface vifurushiPackageDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one VifurushiPackage that matches the filter.
     * @param {vifurushiPackageFindUniqueArgs} args - Arguments to find a VifurushiPackage
     * @example
     * // Get one VifurushiPackage
     * const vifurushiPackage = await prisma.vifurushiPackage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends vifurushiPackageFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, vifurushiPackageFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'vifurushiPackage'> extends True ? CheckSelect<T, Prisma__vifurushiPackageClient<vifurushiPackage>, Prisma__vifurushiPackageClient<vifurushiPackageGetPayload<T>>> : CheckSelect<T, Prisma__vifurushiPackageClient<vifurushiPackage | null >, Prisma__vifurushiPackageClient<vifurushiPackageGetPayload<T> | null >>

    /**
     * Find the first VifurushiPackage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vifurushiPackageFindFirstArgs} args - Arguments to find a VifurushiPackage
     * @example
     * // Get one VifurushiPackage
     * const vifurushiPackage = await prisma.vifurushiPackage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends vifurushiPackageFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, vifurushiPackageFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'vifurushiPackage'> extends True ? CheckSelect<T, Prisma__vifurushiPackageClient<vifurushiPackage>, Prisma__vifurushiPackageClient<vifurushiPackageGetPayload<T>>> : CheckSelect<T, Prisma__vifurushiPackageClient<vifurushiPackage | null >, Prisma__vifurushiPackageClient<vifurushiPackageGetPayload<T> | null >>

    /**
     * Find zero or more VifurushiPackages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vifurushiPackageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VifurushiPackages
     * const vifurushiPackages = await prisma.vifurushiPackage.findMany()
     * 
     * // Get first 10 VifurushiPackages
     * const vifurushiPackages = await prisma.vifurushiPackage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vifurushiPackageWithIdOnly = await prisma.vifurushiPackage.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends vifurushiPackageFindManyArgs>(
      args?: SelectSubset<T, vifurushiPackageFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<vifurushiPackage>>, PrismaPromise<Array<vifurushiPackageGetPayload<T>>>>

    /**
     * Create a VifurushiPackage.
     * @param {vifurushiPackageCreateArgs} args - Arguments to create a VifurushiPackage.
     * @example
     * // Create one VifurushiPackage
     * const VifurushiPackage = await prisma.vifurushiPackage.create({
     *   data: {
     *     // ... data to create a VifurushiPackage
     *   }
     * })
     * 
    **/
    create<T extends vifurushiPackageCreateArgs>(
      args: SelectSubset<T, vifurushiPackageCreateArgs>
    ): CheckSelect<T, Prisma__vifurushiPackageClient<vifurushiPackage>, Prisma__vifurushiPackageClient<vifurushiPackageGetPayload<T>>>

    /**
     * Create many VifurushiPackages.
     *     @param {vifurushiPackageCreateManyArgs} args - Arguments to create many VifurushiPackages.
     *     @example
     *     // Create many VifurushiPackages
     *     const vifurushiPackage = await prisma.vifurushiPackage.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends vifurushiPackageCreateManyArgs>(
      args?: SelectSubset<T, vifurushiPackageCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a VifurushiPackage.
     * @param {vifurushiPackageDeleteArgs} args - Arguments to delete one VifurushiPackage.
     * @example
     * // Delete one VifurushiPackage
     * const VifurushiPackage = await prisma.vifurushiPackage.delete({
     *   where: {
     *     // ... filter to delete one VifurushiPackage
     *   }
     * })
     * 
    **/
    delete<T extends vifurushiPackageDeleteArgs>(
      args: SelectSubset<T, vifurushiPackageDeleteArgs>
    ): CheckSelect<T, Prisma__vifurushiPackageClient<vifurushiPackage>, Prisma__vifurushiPackageClient<vifurushiPackageGetPayload<T>>>

    /**
     * Update one VifurushiPackage.
     * @param {vifurushiPackageUpdateArgs} args - Arguments to update one VifurushiPackage.
     * @example
     * // Update one VifurushiPackage
     * const vifurushiPackage = await prisma.vifurushiPackage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends vifurushiPackageUpdateArgs>(
      args: SelectSubset<T, vifurushiPackageUpdateArgs>
    ): CheckSelect<T, Prisma__vifurushiPackageClient<vifurushiPackage>, Prisma__vifurushiPackageClient<vifurushiPackageGetPayload<T>>>

    /**
     * Delete zero or more VifurushiPackages.
     * @param {vifurushiPackageDeleteManyArgs} args - Arguments to filter VifurushiPackages to delete.
     * @example
     * // Delete a few VifurushiPackages
     * const { count } = await prisma.vifurushiPackage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends vifurushiPackageDeleteManyArgs>(
      args?: SelectSubset<T, vifurushiPackageDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more VifurushiPackages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vifurushiPackageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VifurushiPackages
     * const vifurushiPackage = await prisma.vifurushiPackage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends vifurushiPackageUpdateManyArgs>(
      args: SelectSubset<T, vifurushiPackageUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one VifurushiPackage.
     * @param {vifurushiPackageUpsertArgs} args - Arguments to update or create a VifurushiPackage.
     * @example
     * // Update or create a VifurushiPackage
     * const vifurushiPackage = await prisma.vifurushiPackage.upsert({
     *   create: {
     *     // ... data to create a VifurushiPackage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VifurushiPackage we want to update
     *   }
     * })
    **/
    upsert<T extends vifurushiPackageUpsertArgs>(
      args: SelectSubset<T, vifurushiPackageUpsertArgs>
    ): CheckSelect<T, Prisma__vifurushiPackageClient<vifurushiPackage>, Prisma__vifurushiPackageClient<vifurushiPackageGetPayload<T>>>

    /**
     * Find one VifurushiPackage that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {vifurushiPackageFindUniqueOrThrowArgs} args - Arguments to find a VifurushiPackage
     * @example
     * // Get one VifurushiPackage
     * const vifurushiPackage = await prisma.vifurushiPackage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends vifurushiPackageFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, vifurushiPackageFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__vifurushiPackageClient<vifurushiPackage>, Prisma__vifurushiPackageClient<vifurushiPackageGetPayload<T>>>

    /**
     * Find the first VifurushiPackage that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vifurushiPackageFindFirstOrThrowArgs} args - Arguments to find a VifurushiPackage
     * @example
     * // Get one VifurushiPackage
     * const vifurushiPackage = await prisma.vifurushiPackage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends vifurushiPackageFindFirstOrThrowArgs>(
      args?: SelectSubset<T, vifurushiPackageFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__vifurushiPackageClient<vifurushiPackage>, Prisma__vifurushiPackageClient<vifurushiPackageGetPayload<T>>>

    /**
     * Count the number of VifurushiPackages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vifurushiPackageCountArgs} args - Arguments to filter VifurushiPackages to count.
     * @example
     * // Count the number of VifurushiPackages
     * const count = await prisma.vifurushiPackage.count({
     *   where: {
     *     // ... the filter for the VifurushiPackages we want to count
     *   }
     * })
    **/
    count<T extends vifurushiPackageCountArgs>(
      args?: Subset<T, vifurushiPackageCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VifurushiPackageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VifurushiPackage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VifurushiPackageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VifurushiPackageAggregateArgs>(args: Subset<T, VifurushiPackageAggregateArgs>): PrismaPromise<GetVifurushiPackageAggregateType<T>>

    /**
     * Group by VifurushiPackage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VifurushiPackageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VifurushiPackageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VifurushiPackageGroupByArgs['orderBy'] }
        : { orderBy?: VifurushiPackageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VifurushiPackageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVifurushiPackageGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for vifurushiPackage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__vifurushiPackageClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    booksDownload<T extends booksDownloadArgs = {}>(args?: Subset<T, booksDownloadArgs>): CheckSelect<T, Prisma__booksDownloadClient<booksDownload | null >, Prisma__booksDownloadClient<booksDownloadGetPayload<T> | null >>;

    examAccess<T extends examAccessArgs = {}>(args?: Subset<T, examAccessArgs>): CheckSelect<T, Prisma__examAccessClient<examAccess | null >, Prisma__examAccessClient<examAccessGetPayload<T> | null >>;

    examsSolvedDownload<T extends examsSolvedDownloadArgs = {}>(args?: Subset<T, examsSolvedDownloadArgs>): CheckSelect<T, Prisma__examsSolvedDownloadClient<examsSolvedDownload | null >, Prisma__examsSolvedDownloadClient<examsSolvedDownloadGetPayload<T> | null >>;

    examsUnsolvedDownload<T extends examsUnsolvedDownloadArgs = {}>(args?: Subset<T, examsUnsolvedDownloadArgs>): CheckSelect<T, Prisma__examsUnsolvedDownloadClient<examsUnsolvedDownload | null >, Prisma__examsUnsolvedDownloadClient<examsUnsolvedDownloadGetPayload<T> | null >>;

    notesDownload<T extends notesDownloadArgs = {}>(args?: Subset<T, notesDownloadArgs>): CheckSelect<T, Prisma__notesDownloadClient<notesDownload | null >, Prisma__notesDownloadClient<notesDownloadGetPayload<T> | null >>;

    quizExcercises<T extends quizExcercisesArgs = {}>(args?: Subset<T, quizExcercisesArgs>): CheckSelect<T, Prisma__quizExcercisesClient<quizExcercises | null >, Prisma__quizExcercisesClient<quizExcercisesGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * vifurushiPackage base type for findUnique actions
   */
  export type vifurushiPackageFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the vifurushiPackage
     * 
    **/
    select?: vifurushiPackageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: vifurushiPackageInclude | null
    /**
     * Filter, which vifurushiPackage to fetch.
     * 
    **/
    where: vifurushiPackageWhereUniqueInput
  }

  /**
   * vifurushiPackage: findUnique
   */
  export interface vifurushiPackageFindUniqueArgs extends vifurushiPackageFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * vifurushiPackage base type for findFirst actions
   */
  export type vifurushiPackageFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the vifurushiPackage
     * 
    **/
    select?: vifurushiPackageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: vifurushiPackageInclude | null
    /**
     * Filter, which vifurushiPackage to fetch.
     * 
    **/
    where?: vifurushiPackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vifurushiPackages to fetch.
     * 
    **/
    orderBy?: Enumerable<vifurushiPackageOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for vifurushiPackages.
     * 
    **/
    cursor?: vifurushiPackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vifurushiPackages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vifurushiPackages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of vifurushiPackages.
     * 
    **/
    distinct?: Enumerable<VifurushiPackageScalarFieldEnum>
  }

  /**
   * vifurushiPackage: findFirst
   */
  export interface vifurushiPackageFindFirstArgs extends vifurushiPackageFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * vifurushiPackage findMany
   */
  export type vifurushiPackageFindManyArgs = {
    /**
     * Select specific fields to fetch from the vifurushiPackage
     * 
    **/
    select?: vifurushiPackageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: vifurushiPackageInclude | null
    /**
     * Filter, which vifurushiPackages to fetch.
     * 
    **/
    where?: vifurushiPackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vifurushiPackages to fetch.
     * 
    **/
    orderBy?: Enumerable<vifurushiPackageOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing vifurushiPackages.
     * 
    **/
    cursor?: vifurushiPackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vifurushiPackages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vifurushiPackages.
     * 
    **/
    skip?: number
    distinct?: Enumerable<VifurushiPackageScalarFieldEnum>
  }


  /**
   * vifurushiPackage create
   */
  export type vifurushiPackageCreateArgs = {
    /**
     * Select specific fields to fetch from the vifurushiPackage
     * 
    **/
    select?: vifurushiPackageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: vifurushiPackageInclude | null
    /**
     * The data needed to create a vifurushiPackage.
     * 
    **/
    data: XOR<vifurushiPackageCreateInput, vifurushiPackageUncheckedCreateInput>
  }


  /**
   * vifurushiPackage createMany
   */
  export type vifurushiPackageCreateManyArgs = {
    /**
     * The data used to create many vifurushiPackages.
     * 
    **/
    data: Enumerable<vifurushiPackageCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * vifurushiPackage update
   */
  export type vifurushiPackageUpdateArgs = {
    /**
     * Select specific fields to fetch from the vifurushiPackage
     * 
    **/
    select?: vifurushiPackageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: vifurushiPackageInclude | null
    /**
     * The data needed to update a vifurushiPackage.
     * 
    **/
    data: XOR<vifurushiPackageUpdateInput, vifurushiPackageUncheckedUpdateInput>
    /**
     * Choose, which vifurushiPackage to update.
     * 
    **/
    where: vifurushiPackageWhereUniqueInput
  }


  /**
   * vifurushiPackage updateMany
   */
  export type vifurushiPackageUpdateManyArgs = {
    /**
     * The data used to update vifurushiPackages.
     * 
    **/
    data: XOR<vifurushiPackageUpdateManyMutationInput, vifurushiPackageUncheckedUpdateManyInput>
    /**
     * Filter which vifurushiPackages to update
     * 
    **/
    where?: vifurushiPackageWhereInput
  }


  /**
   * vifurushiPackage upsert
   */
  export type vifurushiPackageUpsertArgs = {
    /**
     * Select specific fields to fetch from the vifurushiPackage
     * 
    **/
    select?: vifurushiPackageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: vifurushiPackageInclude | null
    /**
     * The filter to search for the vifurushiPackage to update in case it exists.
     * 
    **/
    where: vifurushiPackageWhereUniqueInput
    /**
     * In case the vifurushiPackage found by the `where` argument doesn't exist, create a new vifurushiPackage with this data.
     * 
    **/
    create: XOR<vifurushiPackageCreateInput, vifurushiPackageUncheckedCreateInput>
    /**
     * In case the vifurushiPackage was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<vifurushiPackageUpdateInput, vifurushiPackageUncheckedUpdateInput>
  }


  /**
   * vifurushiPackage delete
   */
  export type vifurushiPackageDeleteArgs = {
    /**
     * Select specific fields to fetch from the vifurushiPackage
     * 
    **/
    select?: vifurushiPackageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: vifurushiPackageInclude | null
    /**
     * Filter which vifurushiPackage to delete.
     * 
    **/
    where: vifurushiPackageWhereUniqueInput
  }


  /**
   * vifurushiPackage deleteMany
   */
  export type vifurushiPackageDeleteManyArgs = {
    /**
     * Filter which vifurushiPackages to delete
     * 
    **/
    where?: vifurushiPackageWhereInput
  }


  /**
   * vifurushiPackage: findUniqueOrThrow
   */
  export type vifurushiPackageFindUniqueOrThrowArgs = vifurushiPackageFindUniqueArgsBase
      

  /**
   * vifurushiPackage: findFirstOrThrow
   */
  export type vifurushiPackageFindFirstOrThrowArgs = vifurushiPackageFindFirstArgsBase
      

  /**
   * vifurushiPackage without action
   */
  export type vifurushiPackageArgs = {
    /**
     * Select specific fields to fetch from the vifurushiPackage
     * 
    **/
    select?: vifurushiPackageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: vifurushiPackageInclude | null
  }



  /**
   * Model notesDownload
   */


  export type AggregateNotesDownload = {
    _count: NotesDownloadCountAggregateOutputType | null
    _avg: NotesDownloadAvgAggregateOutputType | null
    _sum: NotesDownloadSumAggregateOutputType | null
    _min: NotesDownloadMinAggregateOutputType | null
    _max: NotesDownloadMaxAggregateOutputType | null
  }

  export type NotesDownloadAvgAggregateOutputType = {
    id: number | null
    value: number | null
    vifurushiPackageId: number | null
  }

  export type NotesDownloadSumAggregateOutputType = {
    id: number | null
    value: number | null
    vifurushiPackageId: number | null
  }

  export type NotesDownloadMinAggregateOutputType = {
    id: number | null
    name: string | null
    value: number | null
    vifurushiPackageId: number | null
  }

  export type NotesDownloadMaxAggregateOutputType = {
    id: number | null
    name: string | null
    value: number | null
    vifurushiPackageId: number | null
  }

  export type NotesDownloadCountAggregateOutputType = {
    id: number
    name: number
    value: number
    vifurushiPackageId: number
    _all: number
  }


  export type NotesDownloadAvgAggregateInputType = {
    id?: true
    value?: true
    vifurushiPackageId?: true
  }

  export type NotesDownloadSumAggregateInputType = {
    id?: true
    value?: true
    vifurushiPackageId?: true
  }

  export type NotesDownloadMinAggregateInputType = {
    id?: true
    name?: true
    value?: true
    vifurushiPackageId?: true
  }

  export type NotesDownloadMaxAggregateInputType = {
    id?: true
    name?: true
    value?: true
    vifurushiPackageId?: true
  }

  export type NotesDownloadCountAggregateInputType = {
    id?: true
    name?: true
    value?: true
    vifurushiPackageId?: true
    _all?: true
  }

  export type NotesDownloadAggregateArgs = {
    /**
     * Filter which notesDownload to aggregate.
     * 
    **/
    where?: notesDownloadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notesDownloads to fetch.
     * 
    **/
    orderBy?: Enumerable<notesDownloadOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: notesDownloadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notesDownloads from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notesDownloads.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned notesDownloads
    **/
    _count?: true | NotesDownloadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotesDownloadAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotesDownloadSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotesDownloadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotesDownloadMaxAggregateInputType
  }

  export type GetNotesDownloadAggregateType<T extends NotesDownloadAggregateArgs> = {
        [P in keyof T & keyof AggregateNotesDownload]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotesDownload[P]>
      : GetScalarType<T[P], AggregateNotesDownload[P]>
  }




  export type NotesDownloadGroupByArgs = {
    where?: notesDownloadWhereInput
    orderBy?: Enumerable<notesDownloadOrderByWithAggregationInput>
    by: Array<NotesDownloadScalarFieldEnum>
    having?: notesDownloadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotesDownloadCountAggregateInputType | true
    _avg?: NotesDownloadAvgAggregateInputType
    _sum?: NotesDownloadSumAggregateInputType
    _min?: NotesDownloadMinAggregateInputType
    _max?: NotesDownloadMaxAggregateInputType
  }


  export type NotesDownloadGroupByOutputType = {
    id: number
    name: string
    value: number
    vifurushiPackageId: number
    _count: NotesDownloadCountAggregateOutputType | null
    _avg: NotesDownloadAvgAggregateOutputType | null
    _sum: NotesDownloadSumAggregateOutputType | null
    _min: NotesDownloadMinAggregateOutputType | null
    _max: NotesDownloadMaxAggregateOutputType | null
  }

  type GetNotesDownloadGroupByPayload<T extends NotesDownloadGroupByArgs> = PrismaPromise<
    Array<
      PickArray<NotesDownloadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotesDownloadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotesDownloadGroupByOutputType[P]>
            : GetScalarType<T[P], NotesDownloadGroupByOutputType[P]>
        }
      >
    >


  export type notesDownloadSelect = {
    id?: boolean
    name?: boolean
    value?: boolean
    vifurushiPackageId?: boolean
    vifurushiPackage?: boolean | vifurushiPackageArgs
  }

  export type notesDownloadInclude = {
    vifurushiPackage?: boolean | vifurushiPackageArgs
  }

  export type notesDownloadGetPayload<
    S extends boolean | null | undefined | notesDownloadArgs,
    U = keyof S
      > = S extends true
        ? notesDownload
    : S extends undefined
    ? never
    : S extends notesDownloadArgs | notesDownloadFindManyArgs
    ?'include' extends U
    ? notesDownload  & {
    [P in TrueKeys<S['include']>]:
        P extends 'vifurushiPackage' ? vifurushiPackageGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'vifurushiPackage' ? vifurushiPackageGetPayload<S['select'][P]> :  P extends keyof notesDownload ? notesDownload[P] : never
  } 
    : notesDownload
  : notesDownload


  type notesDownloadCountArgs = Merge<
    Omit<notesDownloadFindManyArgs, 'select' | 'include'> & {
      select?: NotesDownloadCountAggregateInputType | true
    }
  >

  export interface notesDownloadDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one NotesDownload that matches the filter.
     * @param {notesDownloadFindUniqueArgs} args - Arguments to find a NotesDownload
     * @example
     * // Get one NotesDownload
     * const notesDownload = await prisma.notesDownload.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends notesDownloadFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, notesDownloadFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'notesDownload'> extends True ? CheckSelect<T, Prisma__notesDownloadClient<notesDownload>, Prisma__notesDownloadClient<notesDownloadGetPayload<T>>> : CheckSelect<T, Prisma__notesDownloadClient<notesDownload | null >, Prisma__notesDownloadClient<notesDownloadGetPayload<T> | null >>

    /**
     * Find the first NotesDownload that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notesDownloadFindFirstArgs} args - Arguments to find a NotesDownload
     * @example
     * // Get one NotesDownload
     * const notesDownload = await prisma.notesDownload.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends notesDownloadFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, notesDownloadFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'notesDownload'> extends True ? CheckSelect<T, Prisma__notesDownloadClient<notesDownload>, Prisma__notesDownloadClient<notesDownloadGetPayload<T>>> : CheckSelect<T, Prisma__notesDownloadClient<notesDownload | null >, Prisma__notesDownloadClient<notesDownloadGetPayload<T> | null >>

    /**
     * Find zero or more NotesDownloads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notesDownloadFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotesDownloads
     * const notesDownloads = await prisma.notesDownload.findMany()
     * 
     * // Get first 10 NotesDownloads
     * const notesDownloads = await prisma.notesDownload.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notesDownloadWithIdOnly = await prisma.notesDownload.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends notesDownloadFindManyArgs>(
      args?: SelectSubset<T, notesDownloadFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<notesDownload>>, PrismaPromise<Array<notesDownloadGetPayload<T>>>>

    /**
     * Create a NotesDownload.
     * @param {notesDownloadCreateArgs} args - Arguments to create a NotesDownload.
     * @example
     * // Create one NotesDownload
     * const NotesDownload = await prisma.notesDownload.create({
     *   data: {
     *     // ... data to create a NotesDownload
     *   }
     * })
     * 
    **/
    create<T extends notesDownloadCreateArgs>(
      args: SelectSubset<T, notesDownloadCreateArgs>
    ): CheckSelect<T, Prisma__notesDownloadClient<notesDownload>, Prisma__notesDownloadClient<notesDownloadGetPayload<T>>>

    /**
     * Create many NotesDownloads.
     *     @param {notesDownloadCreateManyArgs} args - Arguments to create many NotesDownloads.
     *     @example
     *     // Create many NotesDownloads
     *     const notesDownload = await prisma.notesDownload.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends notesDownloadCreateManyArgs>(
      args?: SelectSubset<T, notesDownloadCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a NotesDownload.
     * @param {notesDownloadDeleteArgs} args - Arguments to delete one NotesDownload.
     * @example
     * // Delete one NotesDownload
     * const NotesDownload = await prisma.notesDownload.delete({
     *   where: {
     *     // ... filter to delete one NotesDownload
     *   }
     * })
     * 
    **/
    delete<T extends notesDownloadDeleteArgs>(
      args: SelectSubset<T, notesDownloadDeleteArgs>
    ): CheckSelect<T, Prisma__notesDownloadClient<notesDownload>, Prisma__notesDownloadClient<notesDownloadGetPayload<T>>>

    /**
     * Update one NotesDownload.
     * @param {notesDownloadUpdateArgs} args - Arguments to update one NotesDownload.
     * @example
     * // Update one NotesDownload
     * const notesDownload = await prisma.notesDownload.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends notesDownloadUpdateArgs>(
      args: SelectSubset<T, notesDownloadUpdateArgs>
    ): CheckSelect<T, Prisma__notesDownloadClient<notesDownload>, Prisma__notesDownloadClient<notesDownloadGetPayload<T>>>

    /**
     * Delete zero or more NotesDownloads.
     * @param {notesDownloadDeleteManyArgs} args - Arguments to filter NotesDownloads to delete.
     * @example
     * // Delete a few NotesDownloads
     * const { count } = await prisma.notesDownload.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends notesDownloadDeleteManyArgs>(
      args?: SelectSubset<T, notesDownloadDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotesDownloads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notesDownloadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotesDownloads
     * const notesDownload = await prisma.notesDownload.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends notesDownloadUpdateManyArgs>(
      args: SelectSubset<T, notesDownloadUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one NotesDownload.
     * @param {notesDownloadUpsertArgs} args - Arguments to update or create a NotesDownload.
     * @example
     * // Update or create a NotesDownload
     * const notesDownload = await prisma.notesDownload.upsert({
     *   create: {
     *     // ... data to create a NotesDownload
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotesDownload we want to update
     *   }
     * })
    **/
    upsert<T extends notesDownloadUpsertArgs>(
      args: SelectSubset<T, notesDownloadUpsertArgs>
    ): CheckSelect<T, Prisma__notesDownloadClient<notesDownload>, Prisma__notesDownloadClient<notesDownloadGetPayload<T>>>

    /**
     * Find one NotesDownload that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {notesDownloadFindUniqueOrThrowArgs} args - Arguments to find a NotesDownload
     * @example
     * // Get one NotesDownload
     * const notesDownload = await prisma.notesDownload.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends notesDownloadFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, notesDownloadFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__notesDownloadClient<notesDownload>, Prisma__notesDownloadClient<notesDownloadGetPayload<T>>>

    /**
     * Find the first NotesDownload that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notesDownloadFindFirstOrThrowArgs} args - Arguments to find a NotesDownload
     * @example
     * // Get one NotesDownload
     * const notesDownload = await prisma.notesDownload.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends notesDownloadFindFirstOrThrowArgs>(
      args?: SelectSubset<T, notesDownloadFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__notesDownloadClient<notesDownload>, Prisma__notesDownloadClient<notesDownloadGetPayload<T>>>

    /**
     * Count the number of NotesDownloads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notesDownloadCountArgs} args - Arguments to filter NotesDownloads to count.
     * @example
     * // Count the number of NotesDownloads
     * const count = await prisma.notesDownload.count({
     *   where: {
     *     // ... the filter for the NotesDownloads we want to count
     *   }
     * })
    **/
    count<T extends notesDownloadCountArgs>(
      args?: Subset<T, notesDownloadCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotesDownloadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotesDownload.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotesDownloadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotesDownloadAggregateArgs>(args: Subset<T, NotesDownloadAggregateArgs>): PrismaPromise<GetNotesDownloadAggregateType<T>>

    /**
     * Group by NotesDownload.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotesDownloadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotesDownloadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotesDownloadGroupByArgs['orderBy'] }
        : { orderBy?: NotesDownloadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotesDownloadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotesDownloadGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for notesDownload.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__notesDownloadClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    vifurushiPackage<T extends vifurushiPackageArgs = {}>(args?: Subset<T, vifurushiPackageArgs>): CheckSelect<T, Prisma__vifurushiPackageClient<vifurushiPackage | null >, Prisma__vifurushiPackageClient<vifurushiPackageGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * notesDownload base type for findUnique actions
   */
  export type notesDownloadFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the notesDownload
     * 
    **/
    select?: notesDownloadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: notesDownloadInclude | null
    /**
     * Filter, which notesDownload to fetch.
     * 
    **/
    where: notesDownloadWhereUniqueInput
  }

  /**
   * notesDownload: findUnique
   */
  export interface notesDownloadFindUniqueArgs extends notesDownloadFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * notesDownload base type for findFirst actions
   */
  export type notesDownloadFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the notesDownload
     * 
    **/
    select?: notesDownloadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: notesDownloadInclude | null
    /**
     * Filter, which notesDownload to fetch.
     * 
    **/
    where?: notesDownloadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notesDownloads to fetch.
     * 
    **/
    orderBy?: Enumerable<notesDownloadOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notesDownloads.
     * 
    **/
    cursor?: notesDownloadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notesDownloads from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notesDownloads.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notesDownloads.
     * 
    **/
    distinct?: Enumerable<NotesDownloadScalarFieldEnum>
  }

  /**
   * notesDownload: findFirst
   */
  export interface notesDownloadFindFirstArgs extends notesDownloadFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * notesDownload findMany
   */
  export type notesDownloadFindManyArgs = {
    /**
     * Select specific fields to fetch from the notesDownload
     * 
    **/
    select?: notesDownloadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: notesDownloadInclude | null
    /**
     * Filter, which notesDownloads to fetch.
     * 
    **/
    where?: notesDownloadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notesDownloads to fetch.
     * 
    **/
    orderBy?: Enumerable<notesDownloadOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing notesDownloads.
     * 
    **/
    cursor?: notesDownloadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notesDownloads from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notesDownloads.
     * 
    **/
    skip?: number
    distinct?: Enumerable<NotesDownloadScalarFieldEnum>
  }


  /**
   * notesDownload create
   */
  export type notesDownloadCreateArgs = {
    /**
     * Select specific fields to fetch from the notesDownload
     * 
    **/
    select?: notesDownloadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: notesDownloadInclude | null
    /**
     * The data needed to create a notesDownload.
     * 
    **/
    data: XOR<notesDownloadCreateInput, notesDownloadUncheckedCreateInput>
  }


  /**
   * notesDownload createMany
   */
  export type notesDownloadCreateManyArgs = {
    /**
     * The data used to create many notesDownloads.
     * 
    **/
    data: Enumerable<notesDownloadCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * notesDownload update
   */
  export type notesDownloadUpdateArgs = {
    /**
     * Select specific fields to fetch from the notesDownload
     * 
    **/
    select?: notesDownloadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: notesDownloadInclude | null
    /**
     * The data needed to update a notesDownload.
     * 
    **/
    data: XOR<notesDownloadUpdateInput, notesDownloadUncheckedUpdateInput>
    /**
     * Choose, which notesDownload to update.
     * 
    **/
    where: notesDownloadWhereUniqueInput
  }


  /**
   * notesDownload updateMany
   */
  export type notesDownloadUpdateManyArgs = {
    /**
     * The data used to update notesDownloads.
     * 
    **/
    data: XOR<notesDownloadUpdateManyMutationInput, notesDownloadUncheckedUpdateManyInput>
    /**
     * Filter which notesDownloads to update
     * 
    **/
    where?: notesDownloadWhereInput
  }


  /**
   * notesDownload upsert
   */
  export type notesDownloadUpsertArgs = {
    /**
     * Select specific fields to fetch from the notesDownload
     * 
    **/
    select?: notesDownloadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: notesDownloadInclude | null
    /**
     * The filter to search for the notesDownload to update in case it exists.
     * 
    **/
    where: notesDownloadWhereUniqueInput
    /**
     * In case the notesDownload found by the `where` argument doesn't exist, create a new notesDownload with this data.
     * 
    **/
    create: XOR<notesDownloadCreateInput, notesDownloadUncheckedCreateInput>
    /**
     * In case the notesDownload was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<notesDownloadUpdateInput, notesDownloadUncheckedUpdateInput>
  }


  /**
   * notesDownload delete
   */
  export type notesDownloadDeleteArgs = {
    /**
     * Select specific fields to fetch from the notesDownload
     * 
    **/
    select?: notesDownloadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: notesDownloadInclude | null
    /**
     * Filter which notesDownload to delete.
     * 
    **/
    where: notesDownloadWhereUniqueInput
  }


  /**
   * notesDownload deleteMany
   */
  export type notesDownloadDeleteManyArgs = {
    /**
     * Filter which notesDownloads to delete
     * 
    **/
    where?: notesDownloadWhereInput
  }


  /**
   * notesDownload: findUniqueOrThrow
   */
  export type notesDownloadFindUniqueOrThrowArgs = notesDownloadFindUniqueArgsBase
      

  /**
   * notesDownload: findFirstOrThrow
   */
  export type notesDownloadFindFirstOrThrowArgs = notesDownloadFindFirstArgsBase
      

  /**
   * notesDownload without action
   */
  export type notesDownloadArgs = {
    /**
     * Select specific fields to fetch from the notesDownload
     * 
    **/
    select?: notesDownloadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: notesDownloadInclude | null
  }



  /**
   * Model quizExcercises
   */


  export type AggregateQuizExcercises = {
    _count: QuizExcercisesCountAggregateOutputType | null
    _avg: QuizExcercisesAvgAggregateOutputType | null
    _sum: QuizExcercisesSumAggregateOutputType | null
    _min: QuizExcercisesMinAggregateOutputType | null
    _max: QuizExcercisesMaxAggregateOutputType | null
  }

  export type QuizExcercisesAvgAggregateOutputType = {
    id: number | null
    value: number | null
    vifurushiPackageId: number | null
  }

  export type QuizExcercisesSumAggregateOutputType = {
    id: number | null
    value: number | null
    vifurushiPackageId: number | null
  }

  export type QuizExcercisesMinAggregateOutputType = {
    id: number | null
    name: string | null
    value: number | null
    vifurushiPackageId: number | null
  }

  export type QuizExcercisesMaxAggregateOutputType = {
    id: number | null
    name: string | null
    value: number | null
    vifurushiPackageId: number | null
  }

  export type QuizExcercisesCountAggregateOutputType = {
    id: number
    name: number
    value: number
    vifurushiPackageId: number
    _all: number
  }


  export type QuizExcercisesAvgAggregateInputType = {
    id?: true
    value?: true
    vifurushiPackageId?: true
  }

  export type QuizExcercisesSumAggregateInputType = {
    id?: true
    value?: true
    vifurushiPackageId?: true
  }

  export type QuizExcercisesMinAggregateInputType = {
    id?: true
    name?: true
    value?: true
    vifurushiPackageId?: true
  }

  export type QuizExcercisesMaxAggregateInputType = {
    id?: true
    name?: true
    value?: true
    vifurushiPackageId?: true
  }

  export type QuizExcercisesCountAggregateInputType = {
    id?: true
    name?: true
    value?: true
    vifurushiPackageId?: true
    _all?: true
  }

  export type QuizExcercisesAggregateArgs = {
    /**
     * Filter which quizExcercises to aggregate.
     * 
    **/
    where?: quizExcercisesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of quizExcercises to fetch.
     * 
    **/
    orderBy?: Enumerable<quizExcercisesOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: quizExcercisesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` quizExcercises from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` quizExcercises.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned quizExcercises
    **/
    _count?: true | QuizExcercisesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuizExcercisesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuizExcercisesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizExcercisesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizExcercisesMaxAggregateInputType
  }

  export type GetQuizExcercisesAggregateType<T extends QuizExcercisesAggregateArgs> = {
        [P in keyof T & keyof AggregateQuizExcercises]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuizExcercises[P]>
      : GetScalarType<T[P], AggregateQuizExcercises[P]>
  }




  export type QuizExcercisesGroupByArgs = {
    where?: quizExcercisesWhereInput
    orderBy?: Enumerable<quizExcercisesOrderByWithAggregationInput>
    by: Array<QuizExcercisesScalarFieldEnum>
    having?: quizExcercisesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizExcercisesCountAggregateInputType | true
    _avg?: QuizExcercisesAvgAggregateInputType
    _sum?: QuizExcercisesSumAggregateInputType
    _min?: QuizExcercisesMinAggregateInputType
    _max?: QuizExcercisesMaxAggregateInputType
  }


  export type QuizExcercisesGroupByOutputType = {
    id: number
    name: string
    value: number
    vifurushiPackageId: number
    _count: QuizExcercisesCountAggregateOutputType | null
    _avg: QuizExcercisesAvgAggregateOutputType | null
    _sum: QuizExcercisesSumAggregateOutputType | null
    _min: QuizExcercisesMinAggregateOutputType | null
    _max: QuizExcercisesMaxAggregateOutputType | null
  }

  type GetQuizExcercisesGroupByPayload<T extends QuizExcercisesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<QuizExcercisesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizExcercisesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizExcercisesGroupByOutputType[P]>
            : GetScalarType<T[P], QuizExcercisesGroupByOutputType[P]>
        }
      >
    >


  export type quizExcercisesSelect = {
    id?: boolean
    name?: boolean
    value?: boolean
    vifurushiPackageId?: boolean
    vifurushiPackage?: boolean | vifurushiPackageArgs
  }

  export type quizExcercisesInclude = {
    vifurushiPackage?: boolean | vifurushiPackageArgs
  }

  export type quizExcercisesGetPayload<
    S extends boolean | null | undefined | quizExcercisesArgs,
    U = keyof S
      > = S extends true
        ? quizExcercises
    : S extends undefined
    ? never
    : S extends quizExcercisesArgs | quizExcercisesFindManyArgs
    ?'include' extends U
    ? quizExcercises  & {
    [P in TrueKeys<S['include']>]:
        P extends 'vifurushiPackage' ? vifurushiPackageGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'vifurushiPackage' ? vifurushiPackageGetPayload<S['select'][P]> :  P extends keyof quizExcercises ? quizExcercises[P] : never
  } 
    : quizExcercises
  : quizExcercises


  type quizExcercisesCountArgs = Merge<
    Omit<quizExcercisesFindManyArgs, 'select' | 'include'> & {
      select?: QuizExcercisesCountAggregateInputType | true
    }
  >

  export interface quizExcercisesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one QuizExcercises that matches the filter.
     * @param {quizExcercisesFindUniqueArgs} args - Arguments to find a QuizExcercises
     * @example
     * // Get one QuizExcercises
     * const quizExcercises = await prisma.quizExcercises.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends quizExcercisesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, quizExcercisesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'quizExcercises'> extends True ? CheckSelect<T, Prisma__quizExcercisesClient<quizExcercises>, Prisma__quizExcercisesClient<quizExcercisesGetPayload<T>>> : CheckSelect<T, Prisma__quizExcercisesClient<quizExcercises | null >, Prisma__quizExcercisesClient<quizExcercisesGetPayload<T> | null >>

    /**
     * Find the first QuizExcercises that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quizExcercisesFindFirstArgs} args - Arguments to find a QuizExcercises
     * @example
     * // Get one QuizExcercises
     * const quizExcercises = await prisma.quizExcercises.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends quizExcercisesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, quizExcercisesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'quizExcercises'> extends True ? CheckSelect<T, Prisma__quizExcercisesClient<quizExcercises>, Prisma__quizExcercisesClient<quizExcercisesGetPayload<T>>> : CheckSelect<T, Prisma__quizExcercisesClient<quizExcercises | null >, Prisma__quizExcercisesClient<quizExcercisesGetPayload<T> | null >>

    /**
     * Find zero or more QuizExcercises that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quizExcercisesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuizExcercises
     * const quizExcercises = await prisma.quizExcercises.findMany()
     * 
     * // Get first 10 QuizExcercises
     * const quizExcercises = await prisma.quizExcercises.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizExcercisesWithIdOnly = await prisma.quizExcercises.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends quizExcercisesFindManyArgs>(
      args?: SelectSubset<T, quizExcercisesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<quizExcercises>>, PrismaPromise<Array<quizExcercisesGetPayload<T>>>>

    /**
     * Create a QuizExcercises.
     * @param {quizExcercisesCreateArgs} args - Arguments to create a QuizExcercises.
     * @example
     * // Create one QuizExcercises
     * const QuizExcercises = await prisma.quizExcercises.create({
     *   data: {
     *     // ... data to create a QuizExcercises
     *   }
     * })
     * 
    **/
    create<T extends quizExcercisesCreateArgs>(
      args: SelectSubset<T, quizExcercisesCreateArgs>
    ): CheckSelect<T, Prisma__quizExcercisesClient<quizExcercises>, Prisma__quizExcercisesClient<quizExcercisesGetPayload<T>>>

    /**
     * Create many QuizExcercises.
     *     @param {quizExcercisesCreateManyArgs} args - Arguments to create many QuizExcercises.
     *     @example
     *     // Create many QuizExcercises
     *     const quizExcercises = await prisma.quizExcercises.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends quizExcercisesCreateManyArgs>(
      args?: SelectSubset<T, quizExcercisesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a QuizExcercises.
     * @param {quizExcercisesDeleteArgs} args - Arguments to delete one QuizExcercises.
     * @example
     * // Delete one QuizExcercises
     * const QuizExcercises = await prisma.quizExcercises.delete({
     *   where: {
     *     // ... filter to delete one QuizExcercises
     *   }
     * })
     * 
    **/
    delete<T extends quizExcercisesDeleteArgs>(
      args: SelectSubset<T, quizExcercisesDeleteArgs>
    ): CheckSelect<T, Prisma__quizExcercisesClient<quizExcercises>, Prisma__quizExcercisesClient<quizExcercisesGetPayload<T>>>

    /**
     * Update one QuizExcercises.
     * @param {quizExcercisesUpdateArgs} args - Arguments to update one QuizExcercises.
     * @example
     * // Update one QuizExcercises
     * const quizExcercises = await prisma.quizExcercises.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends quizExcercisesUpdateArgs>(
      args: SelectSubset<T, quizExcercisesUpdateArgs>
    ): CheckSelect<T, Prisma__quizExcercisesClient<quizExcercises>, Prisma__quizExcercisesClient<quizExcercisesGetPayload<T>>>

    /**
     * Delete zero or more QuizExcercises.
     * @param {quizExcercisesDeleteManyArgs} args - Arguments to filter QuizExcercises to delete.
     * @example
     * // Delete a few QuizExcercises
     * const { count } = await prisma.quizExcercises.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends quizExcercisesDeleteManyArgs>(
      args?: SelectSubset<T, quizExcercisesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizExcercises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quizExcercisesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuizExcercises
     * const quizExcercises = await prisma.quizExcercises.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends quizExcercisesUpdateManyArgs>(
      args: SelectSubset<T, quizExcercisesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one QuizExcercises.
     * @param {quizExcercisesUpsertArgs} args - Arguments to update or create a QuizExcercises.
     * @example
     * // Update or create a QuizExcercises
     * const quizExcercises = await prisma.quizExcercises.upsert({
     *   create: {
     *     // ... data to create a QuizExcercises
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuizExcercises we want to update
     *   }
     * })
    **/
    upsert<T extends quizExcercisesUpsertArgs>(
      args: SelectSubset<T, quizExcercisesUpsertArgs>
    ): CheckSelect<T, Prisma__quizExcercisesClient<quizExcercises>, Prisma__quizExcercisesClient<quizExcercisesGetPayload<T>>>

    /**
     * Find one QuizExcercises that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {quizExcercisesFindUniqueOrThrowArgs} args - Arguments to find a QuizExcercises
     * @example
     * // Get one QuizExcercises
     * const quizExcercises = await prisma.quizExcercises.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends quizExcercisesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, quizExcercisesFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__quizExcercisesClient<quizExcercises>, Prisma__quizExcercisesClient<quizExcercisesGetPayload<T>>>

    /**
     * Find the first QuizExcercises that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quizExcercisesFindFirstOrThrowArgs} args - Arguments to find a QuizExcercises
     * @example
     * // Get one QuizExcercises
     * const quizExcercises = await prisma.quizExcercises.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends quizExcercisesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, quizExcercisesFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__quizExcercisesClient<quizExcercises>, Prisma__quizExcercisesClient<quizExcercisesGetPayload<T>>>

    /**
     * Count the number of QuizExcercises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quizExcercisesCountArgs} args - Arguments to filter QuizExcercises to count.
     * @example
     * // Count the number of QuizExcercises
     * const count = await prisma.quizExcercises.count({
     *   where: {
     *     // ... the filter for the QuizExcercises we want to count
     *   }
     * })
    **/
    count<T extends quizExcercisesCountArgs>(
      args?: Subset<T, quizExcercisesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizExcercisesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuizExcercises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizExcercisesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizExcercisesAggregateArgs>(args: Subset<T, QuizExcercisesAggregateArgs>): PrismaPromise<GetQuizExcercisesAggregateType<T>>

    /**
     * Group by QuizExcercises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizExcercisesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizExcercisesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizExcercisesGroupByArgs['orderBy'] }
        : { orderBy?: QuizExcercisesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizExcercisesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizExcercisesGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for quizExcercises.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__quizExcercisesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    vifurushiPackage<T extends vifurushiPackageArgs = {}>(args?: Subset<T, vifurushiPackageArgs>): CheckSelect<T, Prisma__vifurushiPackageClient<vifurushiPackage | null >, Prisma__vifurushiPackageClient<vifurushiPackageGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * quizExcercises base type for findUnique actions
   */
  export type quizExcercisesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the quizExcercises
     * 
    **/
    select?: quizExcercisesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: quizExcercisesInclude | null
    /**
     * Filter, which quizExcercises to fetch.
     * 
    **/
    where: quizExcercisesWhereUniqueInput
  }

  /**
   * quizExcercises: findUnique
   */
  export interface quizExcercisesFindUniqueArgs extends quizExcercisesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * quizExcercises base type for findFirst actions
   */
  export type quizExcercisesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the quizExcercises
     * 
    **/
    select?: quizExcercisesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: quizExcercisesInclude | null
    /**
     * Filter, which quizExcercises to fetch.
     * 
    **/
    where?: quizExcercisesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of quizExcercises to fetch.
     * 
    **/
    orderBy?: Enumerable<quizExcercisesOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for quizExcercises.
     * 
    **/
    cursor?: quizExcercisesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` quizExcercises from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` quizExcercises.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of quizExcercises.
     * 
    **/
    distinct?: Enumerable<QuizExcercisesScalarFieldEnum>
  }

  /**
   * quizExcercises: findFirst
   */
  export interface quizExcercisesFindFirstArgs extends quizExcercisesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * quizExcercises findMany
   */
  export type quizExcercisesFindManyArgs = {
    /**
     * Select specific fields to fetch from the quizExcercises
     * 
    **/
    select?: quizExcercisesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: quizExcercisesInclude | null
    /**
     * Filter, which quizExcercises to fetch.
     * 
    **/
    where?: quizExcercisesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of quizExcercises to fetch.
     * 
    **/
    orderBy?: Enumerable<quizExcercisesOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing quizExcercises.
     * 
    **/
    cursor?: quizExcercisesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` quizExcercises from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` quizExcercises.
     * 
    **/
    skip?: number
    distinct?: Enumerable<QuizExcercisesScalarFieldEnum>
  }


  /**
   * quizExcercises create
   */
  export type quizExcercisesCreateArgs = {
    /**
     * Select specific fields to fetch from the quizExcercises
     * 
    **/
    select?: quizExcercisesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: quizExcercisesInclude | null
    /**
     * The data needed to create a quizExcercises.
     * 
    **/
    data: XOR<quizExcercisesCreateInput, quizExcercisesUncheckedCreateInput>
  }


  /**
   * quizExcercises createMany
   */
  export type quizExcercisesCreateManyArgs = {
    /**
     * The data used to create many quizExcercises.
     * 
    **/
    data: Enumerable<quizExcercisesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * quizExcercises update
   */
  export type quizExcercisesUpdateArgs = {
    /**
     * Select specific fields to fetch from the quizExcercises
     * 
    **/
    select?: quizExcercisesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: quizExcercisesInclude | null
    /**
     * The data needed to update a quizExcercises.
     * 
    **/
    data: XOR<quizExcercisesUpdateInput, quizExcercisesUncheckedUpdateInput>
    /**
     * Choose, which quizExcercises to update.
     * 
    **/
    where: quizExcercisesWhereUniqueInput
  }


  /**
   * quizExcercises updateMany
   */
  export type quizExcercisesUpdateManyArgs = {
    /**
     * The data used to update quizExcercises.
     * 
    **/
    data: XOR<quizExcercisesUpdateManyMutationInput, quizExcercisesUncheckedUpdateManyInput>
    /**
     * Filter which quizExcercises to update
     * 
    **/
    where?: quizExcercisesWhereInput
  }


  /**
   * quizExcercises upsert
   */
  export type quizExcercisesUpsertArgs = {
    /**
     * Select specific fields to fetch from the quizExcercises
     * 
    **/
    select?: quizExcercisesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: quizExcercisesInclude | null
    /**
     * The filter to search for the quizExcercises to update in case it exists.
     * 
    **/
    where: quizExcercisesWhereUniqueInput
    /**
     * In case the quizExcercises found by the `where` argument doesn't exist, create a new quizExcercises with this data.
     * 
    **/
    create: XOR<quizExcercisesCreateInput, quizExcercisesUncheckedCreateInput>
    /**
     * In case the quizExcercises was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<quizExcercisesUpdateInput, quizExcercisesUncheckedUpdateInput>
  }


  /**
   * quizExcercises delete
   */
  export type quizExcercisesDeleteArgs = {
    /**
     * Select specific fields to fetch from the quizExcercises
     * 
    **/
    select?: quizExcercisesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: quizExcercisesInclude | null
    /**
     * Filter which quizExcercises to delete.
     * 
    **/
    where: quizExcercisesWhereUniqueInput
  }


  /**
   * quizExcercises deleteMany
   */
  export type quizExcercisesDeleteManyArgs = {
    /**
     * Filter which quizExcercises to delete
     * 
    **/
    where?: quizExcercisesWhereInput
  }


  /**
   * quizExcercises: findUniqueOrThrow
   */
  export type quizExcercisesFindUniqueOrThrowArgs = quizExcercisesFindUniqueArgsBase
      

  /**
   * quizExcercises: findFirstOrThrow
   */
  export type quizExcercisesFindFirstOrThrowArgs = quizExcercisesFindFirstArgsBase
      

  /**
   * quizExcercises without action
   */
  export type quizExcercisesArgs = {
    /**
     * Select specific fields to fetch from the quizExcercises
     * 
    **/
    select?: quizExcercisesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: quizExcercisesInclude | null
  }



  /**
   * Model examsUnsolvedDownload
   */


  export type AggregateExamsUnsolvedDownload = {
    _count: ExamsUnsolvedDownloadCountAggregateOutputType | null
    _avg: ExamsUnsolvedDownloadAvgAggregateOutputType | null
    _sum: ExamsUnsolvedDownloadSumAggregateOutputType | null
    _min: ExamsUnsolvedDownloadMinAggregateOutputType | null
    _max: ExamsUnsolvedDownloadMaxAggregateOutputType | null
  }

  export type ExamsUnsolvedDownloadAvgAggregateOutputType = {
    id: number | null
    value: number | null
    vifurushiPackageId: number | null
  }

  export type ExamsUnsolvedDownloadSumAggregateOutputType = {
    id: number | null
    value: number | null
    vifurushiPackageId: number | null
  }

  export type ExamsUnsolvedDownloadMinAggregateOutputType = {
    id: number | null
    name: string | null
    value: number | null
    vifurushiPackageId: number | null
  }

  export type ExamsUnsolvedDownloadMaxAggregateOutputType = {
    id: number | null
    name: string | null
    value: number | null
    vifurushiPackageId: number | null
  }

  export type ExamsUnsolvedDownloadCountAggregateOutputType = {
    id: number
    name: number
    value: number
    vifurushiPackageId: number
    _all: number
  }


  export type ExamsUnsolvedDownloadAvgAggregateInputType = {
    id?: true
    value?: true
    vifurushiPackageId?: true
  }

  export type ExamsUnsolvedDownloadSumAggregateInputType = {
    id?: true
    value?: true
    vifurushiPackageId?: true
  }

  export type ExamsUnsolvedDownloadMinAggregateInputType = {
    id?: true
    name?: true
    value?: true
    vifurushiPackageId?: true
  }

  export type ExamsUnsolvedDownloadMaxAggregateInputType = {
    id?: true
    name?: true
    value?: true
    vifurushiPackageId?: true
  }

  export type ExamsUnsolvedDownloadCountAggregateInputType = {
    id?: true
    name?: true
    value?: true
    vifurushiPackageId?: true
    _all?: true
  }

  export type ExamsUnsolvedDownloadAggregateArgs = {
    /**
     * Filter which examsUnsolvedDownload to aggregate.
     * 
    **/
    where?: examsUnsolvedDownloadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of examsUnsolvedDownloads to fetch.
     * 
    **/
    orderBy?: Enumerable<examsUnsolvedDownloadOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: examsUnsolvedDownloadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` examsUnsolvedDownloads from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` examsUnsolvedDownloads.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned examsUnsolvedDownloads
    **/
    _count?: true | ExamsUnsolvedDownloadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExamsUnsolvedDownloadAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExamsUnsolvedDownloadSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExamsUnsolvedDownloadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExamsUnsolvedDownloadMaxAggregateInputType
  }

  export type GetExamsUnsolvedDownloadAggregateType<T extends ExamsUnsolvedDownloadAggregateArgs> = {
        [P in keyof T & keyof AggregateExamsUnsolvedDownload]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExamsUnsolvedDownload[P]>
      : GetScalarType<T[P], AggregateExamsUnsolvedDownload[P]>
  }




  export type ExamsUnsolvedDownloadGroupByArgs = {
    where?: examsUnsolvedDownloadWhereInput
    orderBy?: Enumerable<examsUnsolvedDownloadOrderByWithAggregationInput>
    by: Array<ExamsUnsolvedDownloadScalarFieldEnum>
    having?: examsUnsolvedDownloadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExamsUnsolvedDownloadCountAggregateInputType | true
    _avg?: ExamsUnsolvedDownloadAvgAggregateInputType
    _sum?: ExamsUnsolvedDownloadSumAggregateInputType
    _min?: ExamsUnsolvedDownloadMinAggregateInputType
    _max?: ExamsUnsolvedDownloadMaxAggregateInputType
  }


  export type ExamsUnsolvedDownloadGroupByOutputType = {
    id: number
    name: string
    value: number
    vifurushiPackageId: number
    _count: ExamsUnsolvedDownloadCountAggregateOutputType | null
    _avg: ExamsUnsolvedDownloadAvgAggregateOutputType | null
    _sum: ExamsUnsolvedDownloadSumAggregateOutputType | null
    _min: ExamsUnsolvedDownloadMinAggregateOutputType | null
    _max: ExamsUnsolvedDownloadMaxAggregateOutputType | null
  }

  type GetExamsUnsolvedDownloadGroupByPayload<T extends ExamsUnsolvedDownloadGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ExamsUnsolvedDownloadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExamsUnsolvedDownloadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExamsUnsolvedDownloadGroupByOutputType[P]>
            : GetScalarType<T[P], ExamsUnsolvedDownloadGroupByOutputType[P]>
        }
      >
    >


  export type examsUnsolvedDownloadSelect = {
    id?: boolean
    name?: boolean
    value?: boolean
    vifurushiPackageId?: boolean
    vifurushiPackage?: boolean | vifurushiPackageArgs
  }

  export type examsUnsolvedDownloadInclude = {
    vifurushiPackage?: boolean | vifurushiPackageArgs
  }

  export type examsUnsolvedDownloadGetPayload<
    S extends boolean | null | undefined | examsUnsolvedDownloadArgs,
    U = keyof S
      > = S extends true
        ? examsUnsolvedDownload
    : S extends undefined
    ? never
    : S extends examsUnsolvedDownloadArgs | examsUnsolvedDownloadFindManyArgs
    ?'include' extends U
    ? examsUnsolvedDownload  & {
    [P in TrueKeys<S['include']>]:
        P extends 'vifurushiPackage' ? vifurushiPackageGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'vifurushiPackage' ? vifurushiPackageGetPayload<S['select'][P]> :  P extends keyof examsUnsolvedDownload ? examsUnsolvedDownload[P] : never
  } 
    : examsUnsolvedDownload
  : examsUnsolvedDownload


  type examsUnsolvedDownloadCountArgs = Merge<
    Omit<examsUnsolvedDownloadFindManyArgs, 'select' | 'include'> & {
      select?: ExamsUnsolvedDownloadCountAggregateInputType | true
    }
  >

  export interface examsUnsolvedDownloadDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ExamsUnsolvedDownload that matches the filter.
     * @param {examsUnsolvedDownloadFindUniqueArgs} args - Arguments to find a ExamsUnsolvedDownload
     * @example
     * // Get one ExamsUnsolvedDownload
     * const examsUnsolvedDownload = await prisma.examsUnsolvedDownload.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends examsUnsolvedDownloadFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, examsUnsolvedDownloadFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'examsUnsolvedDownload'> extends True ? CheckSelect<T, Prisma__examsUnsolvedDownloadClient<examsUnsolvedDownload>, Prisma__examsUnsolvedDownloadClient<examsUnsolvedDownloadGetPayload<T>>> : CheckSelect<T, Prisma__examsUnsolvedDownloadClient<examsUnsolvedDownload | null >, Prisma__examsUnsolvedDownloadClient<examsUnsolvedDownloadGetPayload<T> | null >>

    /**
     * Find the first ExamsUnsolvedDownload that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {examsUnsolvedDownloadFindFirstArgs} args - Arguments to find a ExamsUnsolvedDownload
     * @example
     * // Get one ExamsUnsolvedDownload
     * const examsUnsolvedDownload = await prisma.examsUnsolvedDownload.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends examsUnsolvedDownloadFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, examsUnsolvedDownloadFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'examsUnsolvedDownload'> extends True ? CheckSelect<T, Prisma__examsUnsolvedDownloadClient<examsUnsolvedDownload>, Prisma__examsUnsolvedDownloadClient<examsUnsolvedDownloadGetPayload<T>>> : CheckSelect<T, Prisma__examsUnsolvedDownloadClient<examsUnsolvedDownload | null >, Prisma__examsUnsolvedDownloadClient<examsUnsolvedDownloadGetPayload<T> | null >>

    /**
     * Find zero or more ExamsUnsolvedDownloads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {examsUnsolvedDownloadFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExamsUnsolvedDownloads
     * const examsUnsolvedDownloads = await prisma.examsUnsolvedDownload.findMany()
     * 
     * // Get first 10 ExamsUnsolvedDownloads
     * const examsUnsolvedDownloads = await prisma.examsUnsolvedDownload.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const examsUnsolvedDownloadWithIdOnly = await prisma.examsUnsolvedDownload.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends examsUnsolvedDownloadFindManyArgs>(
      args?: SelectSubset<T, examsUnsolvedDownloadFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<examsUnsolvedDownload>>, PrismaPromise<Array<examsUnsolvedDownloadGetPayload<T>>>>

    /**
     * Create a ExamsUnsolvedDownload.
     * @param {examsUnsolvedDownloadCreateArgs} args - Arguments to create a ExamsUnsolvedDownload.
     * @example
     * // Create one ExamsUnsolvedDownload
     * const ExamsUnsolvedDownload = await prisma.examsUnsolvedDownload.create({
     *   data: {
     *     // ... data to create a ExamsUnsolvedDownload
     *   }
     * })
     * 
    **/
    create<T extends examsUnsolvedDownloadCreateArgs>(
      args: SelectSubset<T, examsUnsolvedDownloadCreateArgs>
    ): CheckSelect<T, Prisma__examsUnsolvedDownloadClient<examsUnsolvedDownload>, Prisma__examsUnsolvedDownloadClient<examsUnsolvedDownloadGetPayload<T>>>

    /**
     * Create many ExamsUnsolvedDownloads.
     *     @param {examsUnsolvedDownloadCreateManyArgs} args - Arguments to create many ExamsUnsolvedDownloads.
     *     @example
     *     // Create many ExamsUnsolvedDownloads
     *     const examsUnsolvedDownload = await prisma.examsUnsolvedDownload.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends examsUnsolvedDownloadCreateManyArgs>(
      args?: SelectSubset<T, examsUnsolvedDownloadCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ExamsUnsolvedDownload.
     * @param {examsUnsolvedDownloadDeleteArgs} args - Arguments to delete one ExamsUnsolvedDownload.
     * @example
     * // Delete one ExamsUnsolvedDownload
     * const ExamsUnsolvedDownload = await prisma.examsUnsolvedDownload.delete({
     *   where: {
     *     // ... filter to delete one ExamsUnsolvedDownload
     *   }
     * })
     * 
    **/
    delete<T extends examsUnsolvedDownloadDeleteArgs>(
      args: SelectSubset<T, examsUnsolvedDownloadDeleteArgs>
    ): CheckSelect<T, Prisma__examsUnsolvedDownloadClient<examsUnsolvedDownload>, Prisma__examsUnsolvedDownloadClient<examsUnsolvedDownloadGetPayload<T>>>

    /**
     * Update one ExamsUnsolvedDownload.
     * @param {examsUnsolvedDownloadUpdateArgs} args - Arguments to update one ExamsUnsolvedDownload.
     * @example
     * // Update one ExamsUnsolvedDownload
     * const examsUnsolvedDownload = await prisma.examsUnsolvedDownload.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends examsUnsolvedDownloadUpdateArgs>(
      args: SelectSubset<T, examsUnsolvedDownloadUpdateArgs>
    ): CheckSelect<T, Prisma__examsUnsolvedDownloadClient<examsUnsolvedDownload>, Prisma__examsUnsolvedDownloadClient<examsUnsolvedDownloadGetPayload<T>>>

    /**
     * Delete zero or more ExamsUnsolvedDownloads.
     * @param {examsUnsolvedDownloadDeleteManyArgs} args - Arguments to filter ExamsUnsolvedDownloads to delete.
     * @example
     * // Delete a few ExamsUnsolvedDownloads
     * const { count } = await prisma.examsUnsolvedDownload.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends examsUnsolvedDownloadDeleteManyArgs>(
      args?: SelectSubset<T, examsUnsolvedDownloadDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExamsUnsolvedDownloads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {examsUnsolvedDownloadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExamsUnsolvedDownloads
     * const examsUnsolvedDownload = await prisma.examsUnsolvedDownload.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends examsUnsolvedDownloadUpdateManyArgs>(
      args: SelectSubset<T, examsUnsolvedDownloadUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ExamsUnsolvedDownload.
     * @param {examsUnsolvedDownloadUpsertArgs} args - Arguments to update or create a ExamsUnsolvedDownload.
     * @example
     * // Update or create a ExamsUnsolvedDownload
     * const examsUnsolvedDownload = await prisma.examsUnsolvedDownload.upsert({
     *   create: {
     *     // ... data to create a ExamsUnsolvedDownload
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExamsUnsolvedDownload we want to update
     *   }
     * })
    **/
    upsert<T extends examsUnsolvedDownloadUpsertArgs>(
      args: SelectSubset<T, examsUnsolvedDownloadUpsertArgs>
    ): CheckSelect<T, Prisma__examsUnsolvedDownloadClient<examsUnsolvedDownload>, Prisma__examsUnsolvedDownloadClient<examsUnsolvedDownloadGetPayload<T>>>

    /**
     * Find one ExamsUnsolvedDownload that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {examsUnsolvedDownloadFindUniqueOrThrowArgs} args - Arguments to find a ExamsUnsolvedDownload
     * @example
     * // Get one ExamsUnsolvedDownload
     * const examsUnsolvedDownload = await prisma.examsUnsolvedDownload.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends examsUnsolvedDownloadFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, examsUnsolvedDownloadFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__examsUnsolvedDownloadClient<examsUnsolvedDownload>, Prisma__examsUnsolvedDownloadClient<examsUnsolvedDownloadGetPayload<T>>>

    /**
     * Find the first ExamsUnsolvedDownload that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {examsUnsolvedDownloadFindFirstOrThrowArgs} args - Arguments to find a ExamsUnsolvedDownload
     * @example
     * // Get one ExamsUnsolvedDownload
     * const examsUnsolvedDownload = await prisma.examsUnsolvedDownload.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends examsUnsolvedDownloadFindFirstOrThrowArgs>(
      args?: SelectSubset<T, examsUnsolvedDownloadFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__examsUnsolvedDownloadClient<examsUnsolvedDownload>, Prisma__examsUnsolvedDownloadClient<examsUnsolvedDownloadGetPayload<T>>>

    /**
     * Count the number of ExamsUnsolvedDownloads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {examsUnsolvedDownloadCountArgs} args - Arguments to filter ExamsUnsolvedDownloads to count.
     * @example
     * // Count the number of ExamsUnsolvedDownloads
     * const count = await prisma.examsUnsolvedDownload.count({
     *   where: {
     *     // ... the filter for the ExamsUnsolvedDownloads we want to count
     *   }
     * })
    **/
    count<T extends examsUnsolvedDownloadCountArgs>(
      args?: Subset<T, examsUnsolvedDownloadCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExamsUnsolvedDownloadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExamsUnsolvedDownload.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamsUnsolvedDownloadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExamsUnsolvedDownloadAggregateArgs>(args: Subset<T, ExamsUnsolvedDownloadAggregateArgs>): PrismaPromise<GetExamsUnsolvedDownloadAggregateType<T>>

    /**
     * Group by ExamsUnsolvedDownload.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamsUnsolvedDownloadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExamsUnsolvedDownloadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExamsUnsolvedDownloadGroupByArgs['orderBy'] }
        : { orderBy?: ExamsUnsolvedDownloadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExamsUnsolvedDownloadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExamsUnsolvedDownloadGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for examsUnsolvedDownload.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__examsUnsolvedDownloadClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    vifurushiPackage<T extends vifurushiPackageArgs = {}>(args?: Subset<T, vifurushiPackageArgs>): CheckSelect<T, Prisma__vifurushiPackageClient<vifurushiPackage | null >, Prisma__vifurushiPackageClient<vifurushiPackageGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * examsUnsolvedDownload base type for findUnique actions
   */
  export type examsUnsolvedDownloadFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the examsUnsolvedDownload
     * 
    **/
    select?: examsUnsolvedDownloadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: examsUnsolvedDownloadInclude | null
    /**
     * Filter, which examsUnsolvedDownload to fetch.
     * 
    **/
    where: examsUnsolvedDownloadWhereUniqueInput
  }

  /**
   * examsUnsolvedDownload: findUnique
   */
  export interface examsUnsolvedDownloadFindUniqueArgs extends examsUnsolvedDownloadFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * examsUnsolvedDownload base type for findFirst actions
   */
  export type examsUnsolvedDownloadFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the examsUnsolvedDownload
     * 
    **/
    select?: examsUnsolvedDownloadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: examsUnsolvedDownloadInclude | null
    /**
     * Filter, which examsUnsolvedDownload to fetch.
     * 
    **/
    where?: examsUnsolvedDownloadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of examsUnsolvedDownloads to fetch.
     * 
    **/
    orderBy?: Enumerable<examsUnsolvedDownloadOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for examsUnsolvedDownloads.
     * 
    **/
    cursor?: examsUnsolvedDownloadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` examsUnsolvedDownloads from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` examsUnsolvedDownloads.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of examsUnsolvedDownloads.
     * 
    **/
    distinct?: Enumerable<ExamsUnsolvedDownloadScalarFieldEnum>
  }

  /**
   * examsUnsolvedDownload: findFirst
   */
  export interface examsUnsolvedDownloadFindFirstArgs extends examsUnsolvedDownloadFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * examsUnsolvedDownload findMany
   */
  export type examsUnsolvedDownloadFindManyArgs = {
    /**
     * Select specific fields to fetch from the examsUnsolvedDownload
     * 
    **/
    select?: examsUnsolvedDownloadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: examsUnsolvedDownloadInclude | null
    /**
     * Filter, which examsUnsolvedDownloads to fetch.
     * 
    **/
    where?: examsUnsolvedDownloadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of examsUnsolvedDownloads to fetch.
     * 
    **/
    orderBy?: Enumerable<examsUnsolvedDownloadOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing examsUnsolvedDownloads.
     * 
    **/
    cursor?: examsUnsolvedDownloadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` examsUnsolvedDownloads from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` examsUnsolvedDownloads.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ExamsUnsolvedDownloadScalarFieldEnum>
  }


  /**
   * examsUnsolvedDownload create
   */
  export type examsUnsolvedDownloadCreateArgs = {
    /**
     * Select specific fields to fetch from the examsUnsolvedDownload
     * 
    **/
    select?: examsUnsolvedDownloadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: examsUnsolvedDownloadInclude | null
    /**
     * The data needed to create a examsUnsolvedDownload.
     * 
    **/
    data: XOR<examsUnsolvedDownloadCreateInput, examsUnsolvedDownloadUncheckedCreateInput>
  }


  /**
   * examsUnsolvedDownload createMany
   */
  export type examsUnsolvedDownloadCreateManyArgs = {
    /**
     * The data used to create many examsUnsolvedDownloads.
     * 
    **/
    data: Enumerable<examsUnsolvedDownloadCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * examsUnsolvedDownload update
   */
  export type examsUnsolvedDownloadUpdateArgs = {
    /**
     * Select specific fields to fetch from the examsUnsolvedDownload
     * 
    **/
    select?: examsUnsolvedDownloadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: examsUnsolvedDownloadInclude | null
    /**
     * The data needed to update a examsUnsolvedDownload.
     * 
    **/
    data: XOR<examsUnsolvedDownloadUpdateInput, examsUnsolvedDownloadUncheckedUpdateInput>
    /**
     * Choose, which examsUnsolvedDownload to update.
     * 
    **/
    where: examsUnsolvedDownloadWhereUniqueInput
  }


  /**
   * examsUnsolvedDownload updateMany
   */
  export type examsUnsolvedDownloadUpdateManyArgs = {
    /**
     * The data used to update examsUnsolvedDownloads.
     * 
    **/
    data: XOR<examsUnsolvedDownloadUpdateManyMutationInput, examsUnsolvedDownloadUncheckedUpdateManyInput>
    /**
     * Filter which examsUnsolvedDownloads to update
     * 
    **/
    where?: examsUnsolvedDownloadWhereInput
  }


  /**
   * examsUnsolvedDownload upsert
   */
  export type examsUnsolvedDownloadUpsertArgs = {
    /**
     * Select specific fields to fetch from the examsUnsolvedDownload
     * 
    **/
    select?: examsUnsolvedDownloadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: examsUnsolvedDownloadInclude | null
    /**
     * The filter to search for the examsUnsolvedDownload to update in case it exists.
     * 
    **/
    where: examsUnsolvedDownloadWhereUniqueInput
    /**
     * In case the examsUnsolvedDownload found by the `where` argument doesn't exist, create a new examsUnsolvedDownload with this data.
     * 
    **/
    create: XOR<examsUnsolvedDownloadCreateInput, examsUnsolvedDownloadUncheckedCreateInput>
    /**
     * In case the examsUnsolvedDownload was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<examsUnsolvedDownloadUpdateInput, examsUnsolvedDownloadUncheckedUpdateInput>
  }


  /**
   * examsUnsolvedDownload delete
   */
  export type examsUnsolvedDownloadDeleteArgs = {
    /**
     * Select specific fields to fetch from the examsUnsolvedDownload
     * 
    **/
    select?: examsUnsolvedDownloadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: examsUnsolvedDownloadInclude | null
    /**
     * Filter which examsUnsolvedDownload to delete.
     * 
    **/
    where: examsUnsolvedDownloadWhereUniqueInput
  }


  /**
   * examsUnsolvedDownload deleteMany
   */
  export type examsUnsolvedDownloadDeleteManyArgs = {
    /**
     * Filter which examsUnsolvedDownloads to delete
     * 
    **/
    where?: examsUnsolvedDownloadWhereInput
  }


  /**
   * examsUnsolvedDownload: findUniqueOrThrow
   */
  export type examsUnsolvedDownloadFindUniqueOrThrowArgs = examsUnsolvedDownloadFindUniqueArgsBase
      

  /**
   * examsUnsolvedDownload: findFirstOrThrow
   */
  export type examsUnsolvedDownloadFindFirstOrThrowArgs = examsUnsolvedDownloadFindFirstArgsBase
      

  /**
   * examsUnsolvedDownload without action
   */
  export type examsUnsolvedDownloadArgs = {
    /**
     * Select specific fields to fetch from the examsUnsolvedDownload
     * 
    **/
    select?: examsUnsolvedDownloadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: examsUnsolvedDownloadInclude | null
  }



  /**
   * Model examsSolvedDownload
   */


  export type AggregateExamsSolvedDownload = {
    _count: ExamsSolvedDownloadCountAggregateOutputType | null
    _avg: ExamsSolvedDownloadAvgAggregateOutputType | null
    _sum: ExamsSolvedDownloadSumAggregateOutputType | null
    _min: ExamsSolvedDownloadMinAggregateOutputType | null
    _max: ExamsSolvedDownloadMaxAggregateOutputType | null
  }

  export type ExamsSolvedDownloadAvgAggregateOutputType = {
    id: number | null
    value: number | null
    vifurushiPackageId: number | null
  }

  export type ExamsSolvedDownloadSumAggregateOutputType = {
    id: number | null
    value: number | null
    vifurushiPackageId: number | null
  }

  export type ExamsSolvedDownloadMinAggregateOutputType = {
    id: number | null
    name: string | null
    value: number | null
    vifurushiPackageId: number | null
  }

  export type ExamsSolvedDownloadMaxAggregateOutputType = {
    id: number | null
    name: string | null
    value: number | null
    vifurushiPackageId: number | null
  }

  export type ExamsSolvedDownloadCountAggregateOutputType = {
    id: number
    name: number
    value: number
    vifurushiPackageId: number
    _all: number
  }


  export type ExamsSolvedDownloadAvgAggregateInputType = {
    id?: true
    value?: true
    vifurushiPackageId?: true
  }

  export type ExamsSolvedDownloadSumAggregateInputType = {
    id?: true
    value?: true
    vifurushiPackageId?: true
  }

  export type ExamsSolvedDownloadMinAggregateInputType = {
    id?: true
    name?: true
    value?: true
    vifurushiPackageId?: true
  }

  export type ExamsSolvedDownloadMaxAggregateInputType = {
    id?: true
    name?: true
    value?: true
    vifurushiPackageId?: true
  }

  export type ExamsSolvedDownloadCountAggregateInputType = {
    id?: true
    name?: true
    value?: true
    vifurushiPackageId?: true
    _all?: true
  }

  export type ExamsSolvedDownloadAggregateArgs = {
    /**
     * Filter which examsSolvedDownload to aggregate.
     * 
    **/
    where?: examsSolvedDownloadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of examsSolvedDownloads to fetch.
     * 
    **/
    orderBy?: Enumerable<examsSolvedDownloadOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: examsSolvedDownloadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` examsSolvedDownloads from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` examsSolvedDownloads.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned examsSolvedDownloads
    **/
    _count?: true | ExamsSolvedDownloadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExamsSolvedDownloadAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExamsSolvedDownloadSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExamsSolvedDownloadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExamsSolvedDownloadMaxAggregateInputType
  }

  export type GetExamsSolvedDownloadAggregateType<T extends ExamsSolvedDownloadAggregateArgs> = {
        [P in keyof T & keyof AggregateExamsSolvedDownload]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExamsSolvedDownload[P]>
      : GetScalarType<T[P], AggregateExamsSolvedDownload[P]>
  }




  export type ExamsSolvedDownloadGroupByArgs = {
    where?: examsSolvedDownloadWhereInput
    orderBy?: Enumerable<examsSolvedDownloadOrderByWithAggregationInput>
    by: Array<ExamsSolvedDownloadScalarFieldEnum>
    having?: examsSolvedDownloadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExamsSolvedDownloadCountAggregateInputType | true
    _avg?: ExamsSolvedDownloadAvgAggregateInputType
    _sum?: ExamsSolvedDownloadSumAggregateInputType
    _min?: ExamsSolvedDownloadMinAggregateInputType
    _max?: ExamsSolvedDownloadMaxAggregateInputType
  }


  export type ExamsSolvedDownloadGroupByOutputType = {
    id: number
    name: string
    value: number
    vifurushiPackageId: number
    _count: ExamsSolvedDownloadCountAggregateOutputType | null
    _avg: ExamsSolvedDownloadAvgAggregateOutputType | null
    _sum: ExamsSolvedDownloadSumAggregateOutputType | null
    _min: ExamsSolvedDownloadMinAggregateOutputType | null
    _max: ExamsSolvedDownloadMaxAggregateOutputType | null
  }

  type GetExamsSolvedDownloadGroupByPayload<T extends ExamsSolvedDownloadGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ExamsSolvedDownloadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExamsSolvedDownloadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExamsSolvedDownloadGroupByOutputType[P]>
            : GetScalarType<T[P], ExamsSolvedDownloadGroupByOutputType[P]>
        }
      >
    >


  export type examsSolvedDownloadSelect = {
    id?: boolean
    name?: boolean
    value?: boolean
    vifurushiPackageId?: boolean
    vifurushiPackage?: boolean | vifurushiPackageArgs
  }

  export type examsSolvedDownloadInclude = {
    vifurushiPackage?: boolean | vifurushiPackageArgs
  }

  export type examsSolvedDownloadGetPayload<
    S extends boolean | null | undefined | examsSolvedDownloadArgs,
    U = keyof S
      > = S extends true
        ? examsSolvedDownload
    : S extends undefined
    ? never
    : S extends examsSolvedDownloadArgs | examsSolvedDownloadFindManyArgs
    ?'include' extends U
    ? examsSolvedDownload  & {
    [P in TrueKeys<S['include']>]:
        P extends 'vifurushiPackage' ? vifurushiPackageGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'vifurushiPackage' ? vifurushiPackageGetPayload<S['select'][P]> :  P extends keyof examsSolvedDownload ? examsSolvedDownload[P] : never
  } 
    : examsSolvedDownload
  : examsSolvedDownload


  type examsSolvedDownloadCountArgs = Merge<
    Omit<examsSolvedDownloadFindManyArgs, 'select' | 'include'> & {
      select?: ExamsSolvedDownloadCountAggregateInputType | true
    }
  >

  export interface examsSolvedDownloadDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ExamsSolvedDownload that matches the filter.
     * @param {examsSolvedDownloadFindUniqueArgs} args - Arguments to find a ExamsSolvedDownload
     * @example
     * // Get one ExamsSolvedDownload
     * const examsSolvedDownload = await prisma.examsSolvedDownload.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends examsSolvedDownloadFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, examsSolvedDownloadFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'examsSolvedDownload'> extends True ? CheckSelect<T, Prisma__examsSolvedDownloadClient<examsSolvedDownload>, Prisma__examsSolvedDownloadClient<examsSolvedDownloadGetPayload<T>>> : CheckSelect<T, Prisma__examsSolvedDownloadClient<examsSolvedDownload | null >, Prisma__examsSolvedDownloadClient<examsSolvedDownloadGetPayload<T> | null >>

    /**
     * Find the first ExamsSolvedDownload that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {examsSolvedDownloadFindFirstArgs} args - Arguments to find a ExamsSolvedDownload
     * @example
     * // Get one ExamsSolvedDownload
     * const examsSolvedDownload = await prisma.examsSolvedDownload.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends examsSolvedDownloadFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, examsSolvedDownloadFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'examsSolvedDownload'> extends True ? CheckSelect<T, Prisma__examsSolvedDownloadClient<examsSolvedDownload>, Prisma__examsSolvedDownloadClient<examsSolvedDownloadGetPayload<T>>> : CheckSelect<T, Prisma__examsSolvedDownloadClient<examsSolvedDownload | null >, Prisma__examsSolvedDownloadClient<examsSolvedDownloadGetPayload<T> | null >>

    /**
     * Find zero or more ExamsSolvedDownloads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {examsSolvedDownloadFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExamsSolvedDownloads
     * const examsSolvedDownloads = await prisma.examsSolvedDownload.findMany()
     * 
     * // Get first 10 ExamsSolvedDownloads
     * const examsSolvedDownloads = await prisma.examsSolvedDownload.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const examsSolvedDownloadWithIdOnly = await prisma.examsSolvedDownload.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends examsSolvedDownloadFindManyArgs>(
      args?: SelectSubset<T, examsSolvedDownloadFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<examsSolvedDownload>>, PrismaPromise<Array<examsSolvedDownloadGetPayload<T>>>>

    /**
     * Create a ExamsSolvedDownload.
     * @param {examsSolvedDownloadCreateArgs} args - Arguments to create a ExamsSolvedDownload.
     * @example
     * // Create one ExamsSolvedDownload
     * const ExamsSolvedDownload = await prisma.examsSolvedDownload.create({
     *   data: {
     *     // ... data to create a ExamsSolvedDownload
     *   }
     * })
     * 
    **/
    create<T extends examsSolvedDownloadCreateArgs>(
      args: SelectSubset<T, examsSolvedDownloadCreateArgs>
    ): CheckSelect<T, Prisma__examsSolvedDownloadClient<examsSolvedDownload>, Prisma__examsSolvedDownloadClient<examsSolvedDownloadGetPayload<T>>>

    /**
     * Create many ExamsSolvedDownloads.
     *     @param {examsSolvedDownloadCreateManyArgs} args - Arguments to create many ExamsSolvedDownloads.
     *     @example
     *     // Create many ExamsSolvedDownloads
     *     const examsSolvedDownload = await prisma.examsSolvedDownload.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends examsSolvedDownloadCreateManyArgs>(
      args?: SelectSubset<T, examsSolvedDownloadCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ExamsSolvedDownload.
     * @param {examsSolvedDownloadDeleteArgs} args - Arguments to delete one ExamsSolvedDownload.
     * @example
     * // Delete one ExamsSolvedDownload
     * const ExamsSolvedDownload = await prisma.examsSolvedDownload.delete({
     *   where: {
     *     // ... filter to delete one ExamsSolvedDownload
     *   }
     * })
     * 
    **/
    delete<T extends examsSolvedDownloadDeleteArgs>(
      args: SelectSubset<T, examsSolvedDownloadDeleteArgs>
    ): CheckSelect<T, Prisma__examsSolvedDownloadClient<examsSolvedDownload>, Prisma__examsSolvedDownloadClient<examsSolvedDownloadGetPayload<T>>>

    /**
     * Update one ExamsSolvedDownload.
     * @param {examsSolvedDownloadUpdateArgs} args - Arguments to update one ExamsSolvedDownload.
     * @example
     * // Update one ExamsSolvedDownload
     * const examsSolvedDownload = await prisma.examsSolvedDownload.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends examsSolvedDownloadUpdateArgs>(
      args: SelectSubset<T, examsSolvedDownloadUpdateArgs>
    ): CheckSelect<T, Prisma__examsSolvedDownloadClient<examsSolvedDownload>, Prisma__examsSolvedDownloadClient<examsSolvedDownloadGetPayload<T>>>

    /**
     * Delete zero or more ExamsSolvedDownloads.
     * @param {examsSolvedDownloadDeleteManyArgs} args - Arguments to filter ExamsSolvedDownloads to delete.
     * @example
     * // Delete a few ExamsSolvedDownloads
     * const { count } = await prisma.examsSolvedDownload.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends examsSolvedDownloadDeleteManyArgs>(
      args?: SelectSubset<T, examsSolvedDownloadDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExamsSolvedDownloads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {examsSolvedDownloadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExamsSolvedDownloads
     * const examsSolvedDownload = await prisma.examsSolvedDownload.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends examsSolvedDownloadUpdateManyArgs>(
      args: SelectSubset<T, examsSolvedDownloadUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ExamsSolvedDownload.
     * @param {examsSolvedDownloadUpsertArgs} args - Arguments to update or create a ExamsSolvedDownload.
     * @example
     * // Update or create a ExamsSolvedDownload
     * const examsSolvedDownload = await prisma.examsSolvedDownload.upsert({
     *   create: {
     *     // ... data to create a ExamsSolvedDownload
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExamsSolvedDownload we want to update
     *   }
     * })
    **/
    upsert<T extends examsSolvedDownloadUpsertArgs>(
      args: SelectSubset<T, examsSolvedDownloadUpsertArgs>
    ): CheckSelect<T, Prisma__examsSolvedDownloadClient<examsSolvedDownload>, Prisma__examsSolvedDownloadClient<examsSolvedDownloadGetPayload<T>>>

    /**
     * Find one ExamsSolvedDownload that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {examsSolvedDownloadFindUniqueOrThrowArgs} args - Arguments to find a ExamsSolvedDownload
     * @example
     * // Get one ExamsSolvedDownload
     * const examsSolvedDownload = await prisma.examsSolvedDownload.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends examsSolvedDownloadFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, examsSolvedDownloadFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__examsSolvedDownloadClient<examsSolvedDownload>, Prisma__examsSolvedDownloadClient<examsSolvedDownloadGetPayload<T>>>

    /**
     * Find the first ExamsSolvedDownload that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {examsSolvedDownloadFindFirstOrThrowArgs} args - Arguments to find a ExamsSolvedDownload
     * @example
     * // Get one ExamsSolvedDownload
     * const examsSolvedDownload = await prisma.examsSolvedDownload.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends examsSolvedDownloadFindFirstOrThrowArgs>(
      args?: SelectSubset<T, examsSolvedDownloadFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__examsSolvedDownloadClient<examsSolvedDownload>, Prisma__examsSolvedDownloadClient<examsSolvedDownloadGetPayload<T>>>

    /**
     * Count the number of ExamsSolvedDownloads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {examsSolvedDownloadCountArgs} args - Arguments to filter ExamsSolvedDownloads to count.
     * @example
     * // Count the number of ExamsSolvedDownloads
     * const count = await prisma.examsSolvedDownload.count({
     *   where: {
     *     // ... the filter for the ExamsSolvedDownloads we want to count
     *   }
     * })
    **/
    count<T extends examsSolvedDownloadCountArgs>(
      args?: Subset<T, examsSolvedDownloadCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExamsSolvedDownloadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExamsSolvedDownload.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamsSolvedDownloadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExamsSolvedDownloadAggregateArgs>(args: Subset<T, ExamsSolvedDownloadAggregateArgs>): PrismaPromise<GetExamsSolvedDownloadAggregateType<T>>

    /**
     * Group by ExamsSolvedDownload.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamsSolvedDownloadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExamsSolvedDownloadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExamsSolvedDownloadGroupByArgs['orderBy'] }
        : { orderBy?: ExamsSolvedDownloadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExamsSolvedDownloadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExamsSolvedDownloadGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for examsSolvedDownload.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__examsSolvedDownloadClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    vifurushiPackage<T extends vifurushiPackageArgs = {}>(args?: Subset<T, vifurushiPackageArgs>): CheckSelect<T, Prisma__vifurushiPackageClient<vifurushiPackage | null >, Prisma__vifurushiPackageClient<vifurushiPackageGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * examsSolvedDownload base type for findUnique actions
   */
  export type examsSolvedDownloadFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the examsSolvedDownload
     * 
    **/
    select?: examsSolvedDownloadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: examsSolvedDownloadInclude | null
    /**
     * Filter, which examsSolvedDownload to fetch.
     * 
    **/
    where: examsSolvedDownloadWhereUniqueInput
  }

  /**
   * examsSolvedDownload: findUnique
   */
  export interface examsSolvedDownloadFindUniqueArgs extends examsSolvedDownloadFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * examsSolvedDownload base type for findFirst actions
   */
  export type examsSolvedDownloadFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the examsSolvedDownload
     * 
    **/
    select?: examsSolvedDownloadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: examsSolvedDownloadInclude | null
    /**
     * Filter, which examsSolvedDownload to fetch.
     * 
    **/
    where?: examsSolvedDownloadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of examsSolvedDownloads to fetch.
     * 
    **/
    orderBy?: Enumerable<examsSolvedDownloadOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for examsSolvedDownloads.
     * 
    **/
    cursor?: examsSolvedDownloadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` examsSolvedDownloads from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` examsSolvedDownloads.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of examsSolvedDownloads.
     * 
    **/
    distinct?: Enumerable<ExamsSolvedDownloadScalarFieldEnum>
  }

  /**
   * examsSolvedDownload: findFirst
   */
  export interface examsSolvedDownloadFindFirstArgs extends examsSolvedDownloadFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * examsSolvedDownload findMany
   */
  export type examsSolvedDownloadFindManyArgs = {
    /**
     * Select specific fields to fetch from the examsSolvedDownload
     * 
    **/
    select?: examsSolvedDownloadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: examsSolvedDownloadInclude | null
    /**
     * Filter, which examsSolvedDownloads to fetch.
     * 
    **/
    where?: examsSolvedDownloadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of examsSolvedDownloads to fetch.
     * 
    **/
    orderBy?: Enumerable<examsSolvedDownloadOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing examsSolvedDownloads.
     * 
    **/
    cursor?: examsSolvedDownloadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` examsSolvedDownloads from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` examsSolvedDownloads.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ExamsSolvedDownloadScalarFieldEnum>
  }


  /**
   * examsSolvedDownload create
   */
  export type examsSolvedDownloadCreateArgs = {
    /**
     * Select specific fields to fetch from the examsSolvedDownload
     * 
    **/
    select?: examsSolvedDownloadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: examsSolvedDownloadInclude | null
    /**
     * The data needed to create a examsSolvedDownload.
     * 
    **/
    data: XOR<examsSolvedDownloadCreateInput, examsSolvedDownloadUncheckedCreateInput>
  }


  /**
   * examsSolvedDownload createMany
   */
  export type examsSolvedDownloadCreateManyArgs = {
    /**
     * The data used to create many examsSolvedDownloads.
     * 
    **/
    data: Enumerable<examsSolvedDownloadCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * examsSolvedDownload update
   */
  export type examsSolvedDownloadUpdateArgs = {
    /**
     * Select specific fields to fetch from the examsSolvedDownload
     * 
    **/
    select?: examsSolvedDownloadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: examsSolvedDownloadInclude | null
    /**
     * The data needed to update a examsSolvedDownload.
     * 
    **/
    data: XOR<examsSolvedDownloadUpdateInput, examsSolvedDownloadUncheckedUpdateInput>
    /**
     * Choose, which examsSolvedDownload to update.
     * 
    **/
    where: examsSolvedDownloadWhereUniqueInput
  }


  /**
   * examsSolvedDownload updateMany
   */
  export type examsSolvedDownloadUpdateManyArgs = {
    /**
     * The data used to update examsSolvedDownloads.
     * 
    **/
    data: XOR<examsSolvedDownloadUpdateManyMutationInput, examsSolvedDownloadUncheckedUpdateManyInput>
    /**
     * Filter which examsSolvedDownloads to update
     * 
    **/
    where?: examsSolvedDownloadWhereInput
  }


  /**
   * examsSolvedDownload upsert
   */
  export type examsSolvedDownloadUpsertArgs = {
    /**
     * Select specific fields to fetch from the examsSolvedDownload
     * 
    **/
    select?: examsSolvedDownloadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: examsSolvedDownloadInclude | null
    /**
     * The filter to search for the examsSolvedDownload to update in case it exists.
     * 
    **/
    where: examsSolvedDownloadWhereUniqueInput
    /**
     * In case the examsSolvedDownload found by the `where` argument doesn't exist, create a new examsSolvedDownload with this data.
     * 
    **/
    create: XOR<examsSolvedDownloadCreateInput, examsSolvedDownloadUncheckedCreateInput>
    /**
     * In case the examsSolvedDownload was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<examsSolvedDownloadUpdateInput, examsSolvedDownloadUncheckedUpdateInput>
  }


  /**
   * examsSolvedDownload delete
   */
  export type examsSolvedDownloadDeleteArgs = {
    /**
     * Select specific fields to fetch from the examsSolvedDownload
     * 
    **/
    select?: examsSolvedDownloadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: examsSolvedDownloadInclude | null
    /**
     * Filter which examsSolvedDownload to delete.
     * 
    **/
    where: examsSolvedDownloadWhereUniqueInput
  }


  /**
   * examsSolvedDownload deleteMany
   */
  export type examsSolvedDownloadDeleteManyArgs = {
    /**
     * Filter which examsSolvedDownloads to delete
     * 
    **/
    where?: examsSolvedDownloadWhereInput
  }


  /**
   * examsSolvedDownload: findUniqueOrThrow
   */
  export type examsSolvedDownloadFindUniqueOrThrowArgs = examsSolvedDownloadFindUniqueArgsBase
      

  /**
   * examsSolvedDownload: findFirstOrThrow
   */
  export type examsSolvedDownloadFindFirstOrThrowArgs = examsSolvedDownloadFindFirstArgsBase
      

  /**
   * examsSolvedDownload without action
   */
  export type examsSolvedDownloadArgs = {
    /**
     * Select specific fields to fetch from the examsSolvedDownload
     * 
    **/
    select?: examsSolvedDownloadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: examsSolvedDownloadInclude | null
  }



  /**
   * Model examAccess
   */


  export type AggregateExamAccess = {
    _count: ExamAccessCountAggregateOutputType | null
    _avg: ExamAccessAvgAggregateOutputType | null
    _sum: ExamAccessSumAggregateOutputType | null
    _min: ExamAccessMinAggregateOutputType | null
    _max: ExamAccessMaxAggregateOutputType | null
  }

  export type ExamAccessAvgAggregateOutputType = {
    id: number | null
    value: number | null
    vifurushiPackageId: number | null
  }

  export type ExamAccessSumAggregateOutputType = {
    id: number | null
    value: number | null
    vifurushiPackageId: number | null
  }

  export type ExamAccessMinAggregateOutputType = {
    id: number | null
    name: string | null
    value: number | null
    vifurushiPackageId: number | null
  }

  export type ExamAccessMaxAggregateOutputType = {
    id: number | null
    name: string | null
    value: number | null
    vifurushiPackageId: number | null
  }

  export type ExamAccessCountAggregateOutputType = {
    id: number
    name: number
    value: number
    vifurushiPackageId: number
    _all: number
  }


  export type ExamAccessAvgAggregateInputType = {
    id?: true
    value?: true
    vifurushiPackageId?: true
  }

  export type ExamAccessSumAggregateInputType = {
    id?: true
    value?: true
    vifurushiPackageId?: true
  }

  export type ExamAccessMinAggregateInputType = {
    id?: true
    name?: true
    value?: true
    vifurushiPackageId?: true
  }

  export type ExamAccessMaxAggregateInputType = {
    id?: true
    name?: true
    value?: true
    vifurushiPackageId?: true
  }

  export type ExamAccessCountAggregateInputType = {
    id?: true
    name?: true
    value?: true
    vifurushiPackageId?: true
    _all?: true
  }

  export type ExamAccessAggregateArgs = {
    /**
     * Filter which examAccess to aggregate.
     * 
    **/
    where?: examAccessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of examAccesses to fetch.
     * 
    **/
    orderBy?: Enumerable<examAccessOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: examAccessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` examAccesses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` examAccesses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned examAccesses
    **/
    _count?: true | ExamAccessCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExamAccessAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExamAccessSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExamAccessMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExamAccessMaxAggregateInputType
  }

  export type GetExamAccessAggregateType<T extends ExamAccessAggregateArgs> = {
        [P in keyof T & keyof AggregateExamAccess]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExamAccess[P]>
      : GetScalarType<T[P], AggregateExamAccess[P]>
  }




  export type ExamAccessGroupByArgs = {
    where?: examAccessWhereInput
    orderBy?: Enumerable<examAccessOrderByWithAggregationInput>
    by: Array<ExamAccessScalarFieldEnum>
    having?: examAccessScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExamAccessCountAggregateInputType | true
    _avg?: ExamAccessAvgAggregateInputType
    _sum?: ExamAccessSumAggregateInputType
    _min?: ExamAccessMinAggregateInputType
    _max?: ExamAccessMaxAggregateInputType
  }


  export type ExamAccessGroupByOutputType = {
    id: number
    name: string
    value: number
    vifurushiPackageId: number
    _count: ExamAccessCountAggregateOutputType | null
    _avg: ExamAccessAvgAggregateOutputType | null
    _sum: ExamAccessSumAggregateOutputType | null
    _min: ExamAccessMinAggregateOutputType | null
    _max: ExamAccessMaxAggregateOutputType | null
  }

  type GetExamAccessGroupByPayload<T extends ExamAccessGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ExamAccessGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExamAccessGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExamAccessGroupByOutputType[P]>
            : GetScalarType<T[P], ExamAccessGroupByOutputType[P]>
        }
      >
    >


  export type examAccessSelect = {
    id?: boolean
    name?: boolean
    value?: boolean
    vifurushiPackageId?: boolean
    vifurushiPackage?: boolean | vifurushiPackageArgs
  }

  export type examAccessInclude = {
    vifurushiPackage?: boolean | vifurushiPackageArgs
  }

  export type examAccessGetPayload<
    S extends boolean | null | undefined | examAccessArgs,
    U = keyof S
      > = S extends true
        ? examAccess
    : S extends undefined
    ? never
    : S extends examAccessArgs | examAccessFindManyArgs
    ?'include' extends U
    ? examAccess  & {
    [P in TrueKeys<S['include']>]:
        P extends 'vifurushiPackage' ? vifurushiPackageGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'vifurushiPackage' ? vifurushiPackageGetPayload<S['select'][P]> :  P extends keyof examAccess ? examAccess[P] : never
  } 
    : examAccess
  : examAccess


  type examAccessCountArgs = Merge<
    Omit<examAccessFindManyArgs, 'select' | 'include'> & {
      select?: ExamAccessCountAggregateInputType | true
    }
  >

  export interface examAccessDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ExamAccess that matches the filter.
     * @param {examAccessFindUniqueArgs} args - Arguments to find a ExamAccess
     * @example
     * // Get one ExamAccess
     * const examAccess = await prisma.examAccess.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends examAccessFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, examAccessFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'examAccess'> extends True ? CheckSelect<T, Prisma__examAccessClient<examAccess>, Prisma__examAccessClient<examAccessGetPayload<T>>> : CheckSelect<T, Prisma__examAccessClient<examAccess | null >, Prisma__examAccessClient<examAccessGetPayload<T> | null >>

    /**
     * Find the first ExamAccess that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {examAccessFindFirstArgs} args - Arguments to find a ExamAccess
     * @example
     * // Get one ExamAccess
     * const examAccess = await prisma.examAccess.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends examAccessFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, examAccessFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'examAccess'> extends True ? CheckSelect<T, Prisma__examAccessClient<examAccess>, Prisma__examAccessClient<examAccessGetPayload<T>>> : CheckSelect<T, Prisma__examAccessClient<examAccess | null >, Prisma__examAccessClient<examAccessGetPayload<T> | null >>

    /**
     * Find zero or more ExamAccesses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {examAccessFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExamAccesses
     * const examAccesses = await prisma.examAccess.findMany()
     * 
     * // Get first 10 ExamAccesses
     * const examAccesses = await prisma.examAccess.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const examAccessWithIdOnly = await prisma.examAccess.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends examAccessFindManyArgs>(
      args?: SelectSubset<T, examAccessFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<examAccess>>, PrismaPromise<Array<examAccessGetPayload<T>>>>

    /**
     * Create a ExamAccess.
     * @param {examAccessCreateArgs} args - Arguments to create a ExamAccess.
     * @example
     * // Create one ExamAccess
     * const ExamAccess = await prisma.examAccess.create({
     *   data: {
     *     // ... data to create a ExamAccess
     *   }
     * })
     * 
    **/
    create<T extends examAccessCreateArgs>(
      args: SelectSubset<T, examAccessCreateArgs>
    ): CheckSelect<T, Prisma__examAccessClient<examAccess>, Prisma__examAccessClient<examAccessGetPayload<T>>>

    /**
     * Create many ExamAccesses.
     *     @param {examAccessCreateManyArgs} args - Arguments to create many ExamAccesses.
     *     @example
     *     // Create many ExamAccesses
     *     const examAccess = await prisma.examAccess.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends examAccessCreateManyArgs>(
      args?: SelectSubset<T, examAccessCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ExamAccess.
     * @param {examAccessDeleteArgs} args - Arguments to delete one ExamAccess.
     * @example
     * // Delete one ExamAccess
     * const ExamAccess = await prisma.examAccess.delete({
     *   where: {
     *     // ... filter to delete one ExamAccess
     *   }
     * })
     * 
    **/
    delete<T extends examAccessDeleteArgs>(
      args: SelectSubset<T, examAccessDeleteArgs>
    ): CheckSelect<T, Prisma__examAccessClient<examAccess>, Prisma__examAccessClient<examAccessGetPayload<T>>>

    /**
     * Update one ExamAccess.
     * @param {examAccessUpdateArgs} args - Arguments to update one ExamAccess.
     * @example
     * // Update one ExamAccess
     * const examAccess = await prisma.examAccess.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends examAccessUpdateArgs>(
      args: SelectSubset<T, examAccessUpdateArgs>
    ): CheckSelect<T, Prisma__examAccessClient<examAccess>, Prisma__examAccessClient<examAccessGetPayload<T>>>

    /**
     * Delete zero or more ExamAccesses.
     * @param {examAccessDeleteManyArgs} args - Arguments to filter ExamAccesses to delete.
     * @example
     * // Delete a few ExamAccesses
     * const { count } = await prisma.examAccess.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends examAccessDeleteManyArgs>(
      args?: SelectSubset<T, examAccessDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExamAccesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {examAccessUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExamAccesses
     * const examAccess = await prisma.examAccess.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends examAccessUpdateManyArgs>(
      args: SelectSubset<T, examAccessUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ExamAccess.
     * @param {examAccessUpsertArgs} args - Arguments to update or create a ExamAccess.
     * @example
     * // Update or create a ExamAccess
     * const examAccess = await prisma.examAccess.upsert({
     *   create: {
     *     // ... data to create a ExamAccess
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExamAccess we want to update
     *   }
     * })
    **/
    upsert<T extends examAccessUpsertArgs>(
      args: SelectSubset<T, examAccessUpsertArgs>
    ): CheckSelect<T, Prisma__examAccessClient<examAccess>, Prisma__examAccessClient<examAccessGetPayload<T>>>

    /**
     * Find one ExamAccess that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {examAccessFindUniqueOrThrowArgs} args - Arguments to find a ExamAccess
     * @example
     * // Get one ExamAccess
     * const examAccess = await prisma.examAccess.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends examAccessFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, examAccessFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__examAccessClient<examAccess>, Prisma__examAccessClient<examAccessGetPayload<T>>>

    /**
     * Find the first ExamAccess that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {examAccessFindFirstOrThrowArgs} args - Arguments to find a ExamAccess
     * @example
     * // Get one ExamAccess
     * const examAccess = await prisma.examAccess.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends examAccessFindFirstOrThrowArgs>(
      args?: SelectSubset<T, examAccessFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__examAccessClient<examAccess>, Prisma__examAccessClient<examAccessGetPayload<T>>>

    /**
     * Count the number of ExamAccesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {examAccessCountArgs} args - Arguments to filter ExamAccesses to count.
     * @example
     * // Count the number of ExamAccesses
     * const count = await prisma.examAccess.count({
     *   where: {
     *     // ... the filter for the ExamAccesses we want to count
     *   }
     * })
    **/
    count<T extends examAccessCountArgs>(
      args?: Subset<T, examAccessCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExamAccessCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExamAccess.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamAccessAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExamAccessAggregateArgs>(args: Subset<T, ExamAccessAggregateArgs>): PrismaPromise<GetExamAccessAggregateType<T>>

    /**
     * Group by ExamAccess.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamAccessGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExamAccessGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExamAccessGroupByArgs['orderBy'] }
        : { orderBy?: ExamAccessGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExamAccessGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExamAccessGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for examAccess.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__examAccessClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    vifurushiPackage<T extends vifurushiPackageArgs = {}>(args?: Subset<T, vifurushiPackageArgs>): CheckSelect<T, Prisma__vifurushiPackageClient<vifurushiPackage | null >, Prisma__vifurushiPackageClient<vifurushiPackageGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * examAccess base type for findUnique actions
   */
  export type examAccessFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the examAccess
     * 
    **/
    select?: examAccessSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: examAccessInclude | null
    /**
     * Filter, which examAccess to fetch.
     * 
    **/
    where: examAccessWhereUniqueInput
  }

  /**
   * examAccess: findUnique
   */
  export interface examAccessFindUniqueArgs extends examAccessFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * examAccess base type for findFirst actions
   */
  export type examAccessFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the examAccess
     * 
    **/
    select?: examAccessSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: examAccessInclude | null
    /**
     * Filter, which examAccess to fetch.
     * 
    **/
    where?: examAccessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of examAccesses to fetch.
     * 
    **/
    orderBy?: Enumerable<examAccessOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for examAccesses.
     * 
    **/
    cursor?: examAccessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` examAccesses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` examAccesses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of examAccesses.
     * 
    **/
    distinct?: Enumerable<ExamAccessScalarFieldEnum>
  }

  /**
   * examAccess: findFirst
   */
  export interface examAccessFindFirstArgs extends examAccessFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * examAccess findMany
   */
  export type examAccessFindManyArgs = {
    /**
     * Select specific fields to fetch from the examAccess
     * 
    **/
    select?: examAccessSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: examAccessInclude | null
    /**
     * Filter, which examAccesses to fetch.
     * 
    **/
    where?: examAccessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of examAccesses to fetch.
     * 
    **/
    orderBy?: Enumerable<examAccessOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing examAccesses.
     * 
    **/
    cursor?: examAccessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` examAccesses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` examAccesses.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ExamAccessScalarFieldEnum>
  }


  /**
   * examAccess create
   */
  export type examAccessCreateArgs = {
    /**
     * Select specific fields to fetch from the examAccess
     * 
    **/
    select?: examAccessSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: examAccessInclude | null
    /**
     * The data needed to create a examAccess.
     * 
    **/
    data: XOR<examAccessCreateInput, examAccessUncheckedCreateInput>
  }


  /**
   * examAccess createMany
   */
  export type examAccessCreateManyArgs = {
    /**
     * The data used to create many examAccesses.
     * 
    **/
    data: Enumerable<examAccessCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * examAccess update
   */
  export type examAccessUpdateArgs = {
    /**
     * Select specific fields to fetch from the examAccess
     * 
    **/
    select?: examAccessSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: examAccessInclude | null
    /**
     * The data needed to update a examAccess.
     * 
    **/
    data: XOR<examAccessUpdateInput, examAccessUncheckedUpdateInput>
    /**
     * Choose, which examAccess to update.
     * 
    **/
    where: examAccessWhereUniqueInput
  }


  /**
   * examAccess updateMany
   */
  export type examAccessUpdateManyArgs = {
    /**
     * The data used to update examAccesses.
     * 
    **/
    data: XOR<examAccessUpdateManyMutationInput, examAccessUncheckedUpdateManyInput>
    /**
     * Filter which examAccesses to update
     * 
    **/
    where?: examAccessWhereInput
  }


  /**
   * examAccess upsert
   */
  export type examAccessUpsertArgs = {
    /**
     * Select specific fields to fetch from the examAccess
     * 
    **/
    select?: examAccessSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: examAccessInclude | null
    /**
     * The filter to search for the examAccess to update in case it exists.
     * 
    **/
    where: examAccessWhereUniqueInput
    /**
     * In case the examAccess found by the `where` argument doesn't exist, create a new examAccess with this data.
     * 
    **/
    create: XOR<examAccessCreateInput, examAccessUncheckedCreateInput>
    /**
     * In case the examAccess was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<examAccessUpdateInput, examAccessUncheckedUpdateInput>
  }


  /**
   * examAccess delete
   */
  export type examAccessDeleteArgs = {
    /**
     * Select specific fields to fetch from the examAccess
     * 
    **/
    select?: examAccessSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: examAccessInclude | null
    /**
     * Filter which examAccess to delete.
     * 
    **/
    where: examAccessWhereUniqueInput
  }


  /**
   * examAccess deleteMany
   */
  export type examAccessDeleteManyArgs = {
    /**
     * Filter which examAccesses to delete
     * 
    **/
    where?: examAccessWhereInput
  }


  /**
   * examAccess: findUniqueOrThrow
   */
  export type examAccessFindUniqueOrThrowArgs = examAccessFindUniqueArgsBase
      

  /**
   * examAccess: findFirstOrThrow
   */
  export type examAccessFindFirstOrThrowArgs = examAccessFindFirstArgsBase
      

  /**
   * examAccess without action
   */
  export type examAccessArgs = {
    /**
     * Select specific fields to fetch from the examAccess
     * 
    **/
    select?: examAccessSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: examAccessInclude | null
  }



  /**
   * Model booksDownload
   */


  export type AggregateBooksDownload = {
    _count: BooksDownloadCountAggregateOutputType | null
    _avg: BooksDownloadAvgAggregateOutputType | null
    _sum: BooksDownloadSumAggregateOutputType | null
    _min: BooksDownloadMinAggregateOutputType | null
    _max: BooksDownloadMaxAggregateOutputType | null
  }

  export type BooksDownloadAvgAggregateOutputType = {
    id: number | null
    value: number | null
    vifurushiPackageId: number | null
  }

  export type BooksDownloadSumAggregateOutputType = {
    id: number | null
    value: number | null
    vifurushiPackageId: number | null
  }

  export type BooksDownloadMinAggregateOutputType = {
    id: number | null
    name: string | null
    value: number | null
    vifurushiPackageId: number | null
  }

  export type BooksDownloadMaxAggregateOutputType = {
    id: number | null
    name: string | null
    value: number | null
    vifurushiPackageId: number | null
  }

  export type BooksDownloadCountAggregateOutputType = {
    id: number
    name: number
    value: number
    vifurushiPackageId: number
    _all: number
  }


  export type BooksDownloadAvgAggregateInputType = {
    id?: true
    value?: true
    vifurushiPackageId?: true
  }

  export type BooksDownloadSumAggregateInputType = {
    id?: true
    value?: true
    vifurushiPackageId?: true
  }

  export type BooksDownloadMinAggregateInputType = {
    id?: true
    name?: true
    value?: true
    vifurushiPackageId?: true
  }

  export type BooksDownloadMaxAggregateInputType = {
    id?: true
    name?: true
    value?: true
    vifurushiPackageId?: true
  }

  export type BooksDownloadCountAggregateInputType = {
    id?: true
    name?: true
    value?: true
    vifurushiPackageId?: true
    _all?: true
  }

  export type BooksDownloadAggregateArgs = {
    /**
     * Filter which booksDownload to aggregate.
     * 
    **/
    where?: booksDownloadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of booksDownloads to fetch.
     * 
    **/
    orderBy?: Enumerable<booksDownloadOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: booksDownloadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` booksDownloads from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` booksDownloads.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned booksDownloads
    **/
    _count?: true | BooksDownloadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BooksDownloadAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BooksDownloadSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BooksDownloadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BooksDownloadMaxAggregateInputType
  }

  export type GetBooksDownloadAggregateType<T extends BooksDownloadAggregateArgs> = {
        [P in keyof T & keyof AggregateBooksDownload]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBooksDownload[P]>
      : GetScalarType<T[P], AggregateBooksDownload[P]>
  }




  export type BooksDownloadGroupByArgs = {
    where?: booksDownloadWhereInput
    orderBy?: Enumerable<booksDownloadOrderByWithAggregationInput>
    by: Array<BooksDownloadScalarFieldEnum>
    having?: booksDownloadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BooksDownloadCountAggregateInputType | true
    _avg?: BooksDownloadAvgAggregateInputType
    _sum?: BooksDownloadSumAggregateInputType
    _min?: BooksDownloadMinAggregateInputType
    _max?: BooksDownloadMaxAggregateInputType
  }


  export type BooksDownloadGroupByOutputType = {
    id: number
    name: string
    value: number
    vifurushiPackageId: number
    _count: BooksDownloadCountAggregateOutputType | null
    _avg: BooksDownloadAvgAggregateOutputType | null
    _sum: BooksDownloadSumAggregateOutputType | null
    _min: BooksDownloadMinAggregateOutputType | null
    _max: BooksDownloadMaxAggregateOutputType | null
  }

  type GetBooksDownloadGroupByPayload<T extends BooksDownloadGroupByArgs> = PrismaPromise<
    Array<
      PickArray<BooksDownloadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BooksDownloadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BooksDownloadGroupByOutputType[P]>
            : GetScalarType<T[P], BooksDownloadGroupByOutputType[P]>
        }
      >
    >


  export type booksDownloadSelect = {
    id?: boolean
    name?: boolean
    value?: boolean
    vifurushiPackageId?: boolean
    vifurushiPackage?: boolean | vifurushiPackageArgs
  }

  export type booksDownloadInclude = {
    vifurushiPackage?: boolean | vifurushiPackageArgs
  }

  export type booksDownloadGetPayload<
    S extends boolean | null | undefined | booksDownloadArgs,
    U = keyof S
      > = S extends true
        ? booksDownload
    : S extends undefined
    ? never
    : S extends booksDownloadArgs | booksDownloadFindManyArgs
    ?'include' extends U
    ? booksDownload  & {
    [P in TrueKeys<S['include']>]:
        P extends 'vifurushiPackage' ? vifurushiPackageGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'vifurushiPackage' ? vifurushiPackageGetPayload<S['select'][P]> :  P extends keyof booksDownload ? booksDownload[P] : never
  } 
    : booksDownload
  : booksDownload


  type booksDownloadCountArgs = Merge<
    Omit<booksDownloadFindManyArgs, 'select' | 'include'> & {
      select?: BooksDownloadCountAggregateInputType | true
    }
  >

  export interface booksDownloadDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one BooksDownload that matches the filter.
     * @param {booksDownloadFindUniqueArgs} args - Arguments to find a BooksDownload
     * @example
     * // Get one BooksDownload
     * const booksDownload = await prisma.booksDownload.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends booksDownloadFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, booksDownloadFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'booksDownload'> extends True ? CheckSelect<T, Prisma__booksDownloadClient<booksDownload>, Prisma__booksDownloadClient<booksDownloadGetPayload<T>>> : CheckSelect<T, Prisma__booksDownloadClient<booksDownload | null >, Prisma__booksDownloadClient<booksDownloadGetPayload<T> | null >>

    /**
     * Find the first BooksDownload that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {booksDownloadFindFirstArgs} args - Arguments to find a BooksDownload
     * @example
     * // Get one BooksDownload
     * const booksDownload = await prisma.booksDownload.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends booksDownloadFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, booksDownloadFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'booksDownload'> extends True ? CheckSelect<T, Prisma__booksDownloadClient<booksDownload>, Prisma__booksDownloadClient<booksDownloadGetPayload<T>>> : CheckSelect<T, Prisma__booksDownloadClient<booksDownload | null >, Prisma__booksDownloadClient<booksDownloadGetPayload<T> | null >>

    /**
     * Find zero or more BooksDownloads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {booksDownloadFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BooksDownloads
     * const booksDownloads = await prisma.booksDownload.findMany()
     * 
     * // Get first 10 BooksDownloads
     * const booksDownloads = await prisma.booksDownload.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const booksDownloadWithIdOnly = await prisma.booksDownload.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends booksDownloadFindManyArgs>(
      args?: SelectSubset<T, booksDownloadFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<booksDownload>>, PrismaPromise<Array<booksDownloadGetPayload<T>>>>

    /**
     * Create a BooksDownload.
     * @param {booksDownloadCreateArgs} args - Arguments to create a BooksDownload.
     * @example
     * // Create one BooksDownload
     * const BooksDownload = await prisma.booksDownload.create({
     *   data: {
     *     // ... data to create a BooksDownload
     *   }
     * })
     * 
    **/
    create<T extends booksDownloadCreateArgs>(
      args: SelectSubset<T, booksDownloadCreateArgs>
    ): CheckSelect<T, Prisma__booksDownloadClient<booksDownload>, Prisma__booksDownloadClient<booksDownloadGetPayload<T>>>

    /**
     * Create many BooksDownloads.
     *     @param {booksDownloadCreateManyArgs} args - Arguments to create many BooksDownloads.
     *     @example
     *     // Create many BooksDownloads
     *     const booksDownload = await prisma.booksDownload.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends booksDownloadCreateManyArgs>(
      args?: SelectSubset<T, booksDownloadCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a BooksDownload.
     * @param {booksDownloadDeleteArgs} args - Arguments to delete one BooksDownload.
     * @example
     * // Delete one BooksDownload
     * const BooksDownload = await prisma.booksDownload.delete({
     *   where: {
     *     // ... filter to delete one BooksDownload
     *   }
     * })
     * 
    **/
    delete<T extends booksDownloadDeleteArgs>(
      args: SelectSubset<T, booksDownloadDeleteArgs>
    ): CheckSelect<T, Prisma__booksDownloadClient<booksDownload>, Prisma__booksDownloadClient<booksDownloadGetPayload<T>>>

    /**
     * Update one BooksDownload.
     * @param {booksDownloadUpdateArgs} args - Arguments to update one BooksDownload.
     * @example
     * // Update one BooksDownload
     * const booksDownload = await prisma.booksDownload.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends booksDownloadUpdateArgs>(
      args: SelectSubset<T, booksDownloadUpdateArgs>
    ): CheckSelect<T, Prisma__booksDownloadClient<booksDownload>, Prisma__booksDownloadClient<booksDownloadGetPayload<T>>>

    /**
     * Delete zero or more BooksDownloads.
     * @param {booksDownloadDeleteManyArgs} args - Arguments to filter BooksDownloads to delete.
     * @example
     * // Delete a few BooksDownloads
     * const { count } = await prisma.booksDownload.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends booksDownloadDeleteManyArgs>(
      args?: SelectSubset<T, booksDownloadDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more BooksDownloads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {booksDownloadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BooksDownloads
     * const booksDownload = await prisma.booksDownload.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends booksDownloadUpdateManyArgs>(
      args: SelectSubset<T, booksDownloadUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one BooksDownload.
     * @param {booksDownloadUpsertArgs} args - Arguments to update or create a BooksDownload.
     * @example
     * // Update or create a BooksDownload
     * const booksDownload = await prisma.booksDownload.upsert({
     *   create: {
     *     // ... data to create a BooksDownload
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BooksDownload we want to update
     *   }
     * })
    **/
    upsert<T extends booksDownloadUpsertArgs>(
      args: SelectSubset<T, booksDownloadUpsertArgs>
    ): CheckSelect<T, Prisma__booksDownloadClient<booksDownload>, Prisma__booksDownloadClient<booksDownloadGetPayload<T>>>

    /**
     * Find one BooksDownload that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {booksDownloadFindUniqueOrThrowArgs} args - Arguments to find a BooksDownload
     * @example
     * // Get one BooksDownload
     * const booksDownload = await prisma.booksDownload.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends booksDownloadFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, booksDownloadFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__booksDownloadClient<booksDownload>, Prisma__booksDownloadClient<booksDownloadGetPayload<T>>>

    /**
     * Find the first BooksDownload that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {booksDownloadFindFirstOrThrowArgs} args - Arguments to find a BooksDownload
     * @example
     * // Get one BooksDownload
     * const booksDownload = await prisma.booksDownload.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends booksDownloadFindFirstOrThrowArgs>(
      args?: SelectSubset<T, booksDownloadFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__booksDownloadClient<booksDownload>, Prisma__booksDownloadClient<booksDownloadGetPayload<T>>>

    /**
     * Count the number of BooksDownloads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {booksDownloadCountArgs} args - Arguments to filter BooksDownloads to count.
     * @example
     * // Count the number of BooksDownloads
     * const count = await prisma.booksDownload.count({
     *   where: {
     *     // ... the filter for the BooksDownloads we want to count
     *   }
     * })
    **/
    count<T extends booksDownloadCountArgs>(
      args?: Subset<T, booksDownloadCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BooksDownloadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BooksDownload.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BooksDownloadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BooksDownloadAggregateArgs>(args: Subset<T, BooksDownloadAggregateArgs>): PrismaPromise<GetBooksDownloadAggregateType<T>>

    /**
     * Group by BooksDownload.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BooksDownloadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BooksDownloadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BooksDownloadGroupByArgs['orderBy'] }
        : { orderBy?: BooksDownloadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BooksDownloadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBooksDownloadGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for booksDownload.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__booksDownloadClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    vifurushiPackage<T extends vifurushiPackageArgs = {}>(args?: Subset<T, vifurushiPackageArgs>): CheckSelect<T, Prisma__vifurushiPackageClient<vifurushiPackage | null >, Prisma__vifurushiPackageClient<vifurushiPackageGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * booksDownload base type for findUnique actions
   */
  export type booksDownloadFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the booksDownload
     * 
    **/
    select?: booksDownloadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: booksDownloadInclude | null
    /**
     * Filter, which booksDownload to fetch.
     * 
    **/
    where: booksDownloadWhereUniqueInput
  }

  /**
   * booksDownload: findUnique
   */
  export interface booksDownloadFindUniqueArgs extends booksDownloadFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * booksDownload base type for findFirst actions
   */
  export type booksDownloadFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the booksDownload
     * 
    **/
    select?: booksDownloadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: booksDownloadInclude | null
    /**
     * Filter, which booksDownload to fetch.
     * 
    **/
    where?: booksDownloadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of booksDownloads to fetch.
     * 
    **/
    orderBy?: Enumerable<booksDownloadOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for booksDownloads.
     * 
    **/
    cursor?: booksDownloadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` booksDownloads from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` booksDownloads.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of booksDownloads.
     * 
    **/
    distinct?: Enumerable<BooksDownloadScalarFieldEnum>
  }

  /**
   * booksDownload: findFirst
   */
  export interface booksDownloadFindFirstArgs extends booksDownloadFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * booksDownload findMany
   */
  export type booksDownloadFindManyArgs = {
    /**
     * Select specific fields to fetch from the booksDownload
     * 
    **/
    select?: booksDownloadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: booksDownloadInclude | null
    /**
     * Filter, which booksDownloads to fetch.
     * 
    **/
    where?: booksDownloadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of booksDownloads to fetch.
     * 
    **/
    orderBy?: Enumerable<booksDownloadOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing booksDownloads.
     * 
    **/
    cursor?: booksDownloadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` booksDownloads from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` booksDownloads.
     * 
    **/
    skip?: number
    distinct?: Enumerable<BooksDownloadScalarFieldEnum>
  }


  /**
   * booksDownload create
   */
  export type booksDownloadCreateArgs = {
    /**
     * Select specific fields to fetch from the booksDownload
     * 
    **/
    select?: booksDownloadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: booksDownloadInclude | null
    /**
     * The data needed to create a booksDownload.
     * 
    **/
    data: XOR<booksDownloadCreateInput, booksDownloadUncheckedCreateInput>
  }


  /**
   * booksDownload createMany
   */
  export type booksDownloadCreateManyArgs = {
    /**
     * The data used to create many booksDownloads.
     * 
    **/
    data: Enumerable<booksDownloadCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * booksDownload update
   */
  export type booksDownloadUpdateArgs = {
    /**
     * Select specific fields to fetch from the booksDownload
     * 
    **/
    select?: booksDownloadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: booksDownloadInclude | null
    /**
     * The data needed to update a booksDownload.
     * 
    **/
    data: XOR<booksDownloadUpdateInput, booksDownloadUncheckedUpdateInput>
    /**
     * Choose, which booksDownload to update.
     * 
    **/
    where: booksDownloadWhereUniqueInput
  }


  /**
   * booksDownload updateMany
   */
  export type booksDownloadUpdateManyArgs = {
    /**
     * The data used to update booksDownloads.
     * 
    **/
    data: XOR<booksDownloadUpdateManyMutationInput, booksDownloadUncheckedUpdateManyInput>
    /**
     * Filter which booksDownloads to update
     * 
    **/
    where?: booksDownloadWhereInput
  }


  /**
   * booksDownload upsert
   */
  export type booksDownloadUpsertArgs = {
    /**
     * Select specific fields to fetch from the booksDownload
     * 
    **/
    select?: booksDownloadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: booksDownloadInclude | null
    /**
     * The filter to search for the booksDownload to update in case it exists.
     * 
    **/
    where: booksDownloadWhereUniqueInput
    /**
     * In case the booksDownload found by the `where` argument doesn't exist, create a new booksDownload with this data.
     * 
    **/
    create: XOR<booksDownloadCreateInput, booksDownloadUncheckedCreateInput>
    /**
     * In case the booksDownload was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<booksDownloadUpdateInput, booksDownloadUncheckedUpdateInput>
  }


  /**
   * booksDownload delete
   */
  export type booksDownloadDeleteArgs = {
    /**
     * Select specific fields to fetch from the booksDownload
     * 
    **/
    select?: booksDownloadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: booksDownloadInclude | null
    /**
     * Filter which booksDownload to delete.
     * 
    **/
    where: booksDownloadWhereUniqueInput
  }


  /**
   * booksDownload deleteMany
   */
  export type booksDownloadDeleteManyArgs = {
    /**
     * Filter which booksDownloads to delete
     * 
    **/
    where?: booksDownloadWhereInput
  }


  /**
   * booksDownload: findUniqueOrThrow
   */
  export type booksDownloadFindUniqueOrThrowArgs = booksDownloadFindUniqueArgsBase
      

  /**
   * booksDownload: findFirstOrThrow
   */
  export type booksDownloadFindFirstOrThrowArgs = booksDownloadFindFirstArgsBase
      

  /**
   * booksDownload without action
   */
  export type booksDownloadArgs = {
    /**
     * Select specific fields to fetch from the booksDownload
     * 
    **/
    select?: booksDownloadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: booksDownloadInclude | null
  }



  /**
   * Model purchase
   */


  export type AggregatePurchase = {
    _count: PurchaseCountAggregateOutputType | null
    _avg: PurchaseAvgAggregateOutputType | null
    _sum: PurchaseSumAggregateOutputType | null
    _min: PurchaseMinAggregateOutputType | null
    _max: PurchaseMaxAggregateOutputType | null
  }

  export type PurchaseAvgAggregateOutputType = {
    id: number | null
    value: number | null
    usersId: number | null
  }

  export type PurchaseSumAggregateOutputType = {
    id: number | null
    value: number | null
    usersId: number | null
  }

  export type PurchaseMinAggregateOutputType = {
    id: number | null
    name: string | null
    value: number | null
    usersId: number | null
  }

  export type PurchaseMaxAggregateOutputType = {
    id: number | null
    name: string | null
    value: number | null
    usersId: number | null
  }

  export type PurchaseCountAggregateOutputType = {
    id: number
    name: number
    value: number
    usersId: number
    _all: number
  }


  export type PurchaseAvgAggregateInputType = {
    id?: true
    value?: true
    usersId?: true
  }

  export type PurchaseSumAggregateInputType = {
    id?: true
    value?: true
    usersId?: true
  }

  export type PurchaseMinAggregateInputType = {
    id?: true
    name?: true
    value?: true
    usersId?: true
  }

  export type PurchaseMaxAggregateInputType = {
    id?: true
    name?: true
    value?: true
    usersId?: true
  }

  export type PurchaseCountAggregateInputType = {
    id?: true
    name?: true
    value?: true
    usersId?: true
    _all?: true
  }

  export type PurchaseAggregateArgs = {
    /**
     * Filter which purchase to aggregate.
     * 
    **/
    where?: purchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of purchases to fetch.
     * 
    **/
    orderBy?: Enumerable<purchaseOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: purchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` purchases from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` purchases.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned purchases
    **/
    _count?: true | PurchaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseMaxAggregateInputType
  }

  export type GetPurchaseAggregateType<T extends PurchaseAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchase]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchase[P]>
      : GetScalarType<T[P], AggregatePurchase[P]>
  }




  export type PurchaseGroupByArgs = {
    where?: purchaseWhereInput
    orderBy?: Enumerable<purchaseOrderByWithAggregationInput>
    by: Array<PurchaseScalarFieldEnum>
    having?: purchaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseCountAggregateInputType | true
    _avg?: PurchaseAvgAggregateInputType
    _sum?: PurchaseSumAggregateInputType
    _min?: PurchaseMinAggregateInputType
    _max?: PurchaseMaxAggregateInputType
  }


  export type PurchaseGroupByOutputType = {
    id: number
    name: string
    value: number
    usersId: number
    _count: PurchaseCountAggregateOutputType | null
    _avg: PurchaseAvgAggregateOutputType | null
    _sum: PurchaseSumAggregateOutputType | null
    _min: PurchaseMinAggregateOutputType | null
    _max: PurchaseMaxAggregateOutputType | null
  }

  type GetPurchaseGroupByPayload<T extends PurchaseGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PurchaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseGroupByOutputType[P]>
        }
      >
    >


  export type purchaseSelect = {
    id?: boolean
    name?: boolean
    value?: boolean
    usersId?: boolean
    users?: boolean | usersArgs
  }

  export type purchaseInclude = {
    users?: boolean | usersArgs
  }

  export type purchaseGetPayload<
    S extends boolean | null | undefined | purchaseArgs,
    U = keyof S
      > = S extends true
        ? purchase
    : S extends undefined
    ? never
    : S extends purchaseArgs | purchaseFindManyArgs
    ?'include' extends U
    ? purchase  & {
    [P in TrueKeys<S['include']>]:
        P extends 'users' ? usersGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'users' ? usersGetPayload<S['select'][P]> :  P extends keyof purchase ? purchase[P] : never
  } 
    : purchase
  : purchase


  type purchaseCountArgs = Merge<
    Omit<purchaseFindManyArgs, 'select' | 'include'> & {
      select?: PurchaseCountAggregateInputType | true
    }
  >

  export interface purchaseDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Purchase that matches the filter.
     * @param {purchaseFindUniqueArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends purchaseFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, purchaseFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'purchase'> extends True ? CheckSelect<T, Prisma__purchaseClient<purchase>, Prisma__purchaseClient<purchaseGetPayload<T>>> : CheckSelect<T, Prisma__purchaseClient<purchase | null >, Prisma__purchaseClient<purchaseGetPayload<T> | null >>

    /**
     * Find the first Purchase that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {purchaseFindFirstArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends purchaseFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, purchaseFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'purchase'> extends True ? CheckSelect<T, Prisma__purchaseClient<purchase>, Prisma__purchaseClient<purchaseGetPayload<T>>> : CheckSelect<T, Prisma__purchaseClient<purchase | null >, Prisma__purchaseClient<purchaseGetPayload<T> | null >>

    /**
     * Find zero or more Purchases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {purchaseFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Purchases
     * const purchases = await prisma.purchase.findMany()
     * 
     * // Get first 10 Purchases
     * const purchases = await prisma.purchase.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseWithIdOnly = await prisma.purchase.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends purchaseFindManyArgs>(
      args?: SelectSubset<T, purchaseFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<purchase>>, PrismaPromise<Array<purchaseGetPayload<T>>>>

    /**
     * Create a Purchase.
     * @param {purchaseCreateArgs} args - Arguments to create a Purchase.
     * @example
     * // Create one Purchase
     * const Purchase = await prisma.purchase.create({
     *   data: {
     *     // ... data to create a Purchase
     *   }
     * })
     * 
    **/
    create<T extends purchaseCreateArgs>(
      args: SelectSubset<T, purchaseCreateArgs>
    ): CheckSelect<T, Prisma__purchaseClient<purchase>, Prisma__purchaseClient<purchaseGetPayload<T>>>

    /**
     * Create many Purchases.
     *     @param {purchaseCreateManyArgs} args - Arguments to create many Purchases.
     *     @example
     *     // Create many Purchases
     *     const purchase = await prisma.purchase.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends purchaseCreateManyArgs>(
      args?: SelectSubset<T, purchaseCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Purchase.
     * @param {purchaseDeleteArgs} args - Arguments to delete one Purchase.
     * @example
     * // Delete one Purchase
     * const Purchase = await prisma.purchase.delete({
     *   where: {
     *     // ... filter to delete one Purchase
     *   }
     * })
     * 
    **/
    delete<T extends purchaseDeleteArgs>(
      args: SelectSubset<T, purchaseDeleteArgs>
    ): CheckSelect<T, Prisma__purchaseClient<purchase>, Prisma__purchaseClient<purchaseGetPayload<T>>>

    /**
     * Update one Purchase.
     * @param {purchaseUpdateArgs} args - Arguments to update one Purchase.
     * @example
     * // Update one Purchase
     * const purchase = await prisma.purchase.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends purchaseUpdateArgs>(
      args: SelectSubset<T, purchaseUpdateArgs>
    ): CheckSelect<T, Prisma__purchaseClient<purchase>, Prisma__purchaseClient<purchaseGetPayload<T>>>

    /**
     * Delete zero or more Purchases.
     * @param {purchaseDeleteManyArgs} args - Arguments to filter Purchases to delete.
     * @example
     * // Delete a few Purchases
     * const { count } = await prisma.purchase.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends purchaseDeleteManyArgs>(
      args?: SelectSubset<T, purchaseDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Purchases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {purchaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Purchases
     * const purchase = await prisma.purchase.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends purchaseUpdateManyArgs>(
      args: SelectSubset<T, purchaseUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Purchase.
     * @param {purchaseUpsertArgs} args - Arguments to update or create a Purchase.
     * @example
     * // Update or create a Purchase
     * const purchase = await prisma.purchase.upsert({
     *   create: {
     *     // ... data to create a Purchase
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Purchase we want to update
     *   }
     * })
    **/
    upsert<T extends purchaseUpsertArgs>(
      args: SelectSubset<T, purchaseUpsertArgs>
    ): CheckSelect<T, Prisma__purchaseClient<purchase>, Prisma__purchaseClient<purchaseGetPayload<T>>>

    /**
     * Find one Purchase that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {purchaseFindUniqueOrThrowArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends purchaseFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, purchaseFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__purchaseClient<purchase>, Prisma__purchaseClient<purchaseGetPayload<T>>>

    /**
     * Find the first Purchase that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {purchaseFindFirstOrThrowArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends purchaseFindFirstOrThrowArgs>(
      args?: SelectSubset<T, purchaseFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__purchaseClient<purchase>, Prisma__purchaseClient<purchaseGetPayload<T>>>

    /**
     * Count the number of Purchases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {purchaseCountArgs} args - Arguments to filter Purchases to count.
     * @example
     * // Count the number of Purchases
     * const count = await prisma.purchase.count({
     *   where: {
     *     // ... the filter for the Purchases we want to count
     *   }
     * })
    **/
    count<T extends purchaseCountArgs>(
      args?: Subset<T, purchaseCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Purchase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseAggregateArgs>(args: Subset<T, PurchaseAggregateArgs>): PrismaPromise<GetPurchaseAggregateType<T>>

    /**
     * Group by Purchase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for purchase.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__purchaseClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    users<T extends usersArgs = {}>(args?: Subset<T, usersArgs>): CheckSelect<T, Prisma__usersClient<users | null >, Prisma__usersClient<usersGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * purchase base type for findUnique actions
   */
  export type purchaseFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the purchase
     * 
    **/
    select?: purchaseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: purchaseInclude | null
    /**
     * Filter, which purchase to fetch.
     * 
    **/
    where: purchaseWhereUniqueInput
  }

  /**
   * purchase: findUnique
   */
  export interface purchaseFindUniqueArgs extends purchaseFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * purchase base type for findFirst actions
   */
  export type purchaseFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the purchase
     * 
    **/
    select?: purchaseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: purchaseInclude | null
    /**
     * Filter, which purchase to fetch.
     * 
    **/
    where?: purchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of purchases to fetch.
     * 
    **/
    orderBy?: Enumerable<purchaseOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for purchases.
     * 
    **/
    cursor?: purchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` purchases from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` purchases.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of purchases.
     * 
    **/
    distinct?: Enumerable<PurchaseScalarFieldEnum>
  }

  /**
   * purchase: findFirst
   */
  export interface purchaseFindFirstArgs extends purchaseFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * purchase findMany
   */
  export type purchaseFindManyArgs = {
    /**
     * Select specific fields to fetch from the purchase
     * 
    **/
    select?: purchaseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: purchaseInclude | null
    /**
     * Filter, which purchases to fetch.
     * 
    **/
    where?: purchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of purchases to fetch.
     * 
    **/
    orderBy?: Enumerable<purchaseOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing purchases.
     * 
    **/
    cursor?: purchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` purchases from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` purchases.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PurchaseScalarFieldEnum>
  }


  /**
   * purchase create
   */
  export type purchaseCreateArgs = {
    /**
     * Select specific fields to fetch from the purchase
     * 
    **/
    select?: purchaseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: purchaseInclude | null
    /**
     * The data needed to create a purchase.
     * 
    **/
    data: XOR<purchaseCreateInput, purchaseUncheckedCreateInput>
  }


  /**
   * purchase createMany
   */
  export type purchaseCreateManyArgs = {
    /**
     * The data used to create many purchases.
     * 
    **/
    data: Enumerable<purchaseCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * purchase update
   */
  export type purchaseUpdateArgs = {
    /**
     * Select specific fields to fetch from the purchase
     * 
    **/
    select?: purchaseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: purchaseInclude | null
    /**
     * The data needed to update a purchase.
     * 
    **/
    data: XOR<purchaseUpdateInput, purchaseUncheckedUpdateInput>
    /**
     * Choose, which purchase to update.
     * 
    **/
    where: purchaseWhereUniqueInput
  }


  /**
   * purchase updateMany
   */
  export type purchaseUpdateManyArgs = {
    /**
     * The data used to update purchases.
     * 
    **/
    data: XOR<purchaseUpdateManyMutationInput, purchaseUncheckedUpdateManyInput>
    /**
     * Filter which purchases to update
     * 
    **/
    where?: purchaseWhereInput
  }


  /**
   * purchase upsert
   */
  export type purchaseUpsertArgs = {
    /**
     * Select specific fields to fetch from the purchase
     * 
    **/
    select?: purchaseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: purchaseInclude | null
    /**
     * The filter to search for the purchase to update in case it exists.
     * 
    **/
    where: purchaseWhereUniqueInput
    /**
     * In case the purchase found by the `where` argument doesn't exist, create a new purchase with this data.
     * 
    **/
    create: XOR<purchaseCreateInput, purchaseUncheckedCreateInput>
    /**
     * In case the purchase was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<purchaseUpdateInput, purchaseUncheckedUpdateInput>
  }


  /**
   * purchase delete
   */
  export type purchaseDeleteArgs = {
    /**
     * Select specific fields to fetch from the purchase
     * 
    **/
    select?: purchaseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: purchaseInclude | null
    /**
     * Filter which purchase to delete.
     * 
    **/
    where: purchaseWhereUniqueInput
  }


  /**
   * purchase deleteMany
   */
  export type purchaseDeleteManyArgs = {
    /**
     * Filter which purchases to delete
     * 
    **/
    where?: purchaseWhereInput
  }


  /**
   * purchase: findUniqueOrThrow
   */
  export type purchaseFindUniqueOrThrowArgs = purchaseFindUniqueArgsBase
      

  /**
   * purchase: findFirstOrThrow
   */
  export type purchaseFindFirstOrThrowArgs = purchaseFindFirstArgsBase
      

  /**
   * purchase without action
   */
  export type purchaseArgs = {
    /**
     * Select specific fields to fetch from the purchase
     * 
    **/
    select?: purchaseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: purchaseInclude | null
  }



  /**
   * Model subject
   */


  export type AggregateSubject = {
    _count: SubjectCountAggregateOutputType | null
    _avg: SubjectAvgAggregateOutputType | null
    _sum: SubjectSumAggregateOutputType | null
    _min: SubjectMinAggregateOutputType | null
    _max: SubjectMaxAggregateOutputType | null
  }

  export type SubjectAvgAggregateOutputType = {
    id: number | null
    usersId: number | null
  }

  export type SubjectSumAggregateOutputType = {
    id: number | null
    usersId: number | null
  }

  export type SubjectMinAggregateOutputType = {
    id: number | null
    subjectName: string | null
    subjectDefinition: string | null
    imageLocation: string | null
    published: boolean | null
    usersId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubjectMaxAggregateOutputType = {
    id: number | null
    subjectName: string | null
    subjectDefinition: string | null
    imageLocation: string | null
    published: boolean | null
    usersId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubjectCountAggregateOutputType = {
    id: number
    subjectName: number
    subjectDefinition: number
    imageLocation: number
    published: number
    usersId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubjectAvgAggregateInputType = {
    id?: true
    usersId?: true
  }

  export type SubjectSumAggregateInputType = {
    id?: true
    usersId?: true
  }

  export type SubjectMinAggregateInputType = {
    id?: true
    subjectName?: true
    subjectDefinition?: true
    imageLocation?: true
    published?: true
    usersId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubjectMaxAggregateInputType = {
    id?: true
    subjectName?: true
    subjectDefinition?: true
    imageLocation?: true
    published?: true
    usersId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubjectCountAggregateInputType = {
    id?: true
    subjectName?: true
    subjectDefinition?: true
    imageLocation?: true
    published?: true
    usersId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubjectAggregateArgs = {
    /**
     * Filter which subject to aggregate.
     * 
    **/
    where?: subjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subjects to fetch.
     * 
    **/
    orderBy?: Enumerable<subjectOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: subjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subjects from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subjects.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned subjects
    **/
    _count?: true | SubjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubjectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubjectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubjectMaxAggregateInputType
  }

  export type GetSubjectAggregateType<T extends SubjectAggregateArgs> = {
        [P in keyof T & keyof AggregateSubject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubject[P]>
      : GetScalarType<T[P], AggregateSubject[P]>
  }




  export type SubjectGroupByArgs = {
    where?: subjectWhereInput
    orderBy?: Enumerable<subjectOrderByWithAggregationInput>
    by: Array<SubjectScalarFieldEnum>
    having?: subjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubjectCountAggregateInputType | true
    _avg?: SubjectAvgAggregateInputType
    _sum?: SubjectSumAggregateInputType
    _min?: SubjectMinAggregateInputType
    _max?: SubjectMaxAggregateInputType
  }


  export type SubjectGroupByOutputType = {
    id: number
    subjectName: string
    subjectDefinition: string
    imageLocation: string | null
    published: boolean
    usersId: number
    createdAt: Date
    updatedAt: Date
    _count: SubjectCountAggregateOutputType | null
    _avg: SubjectAvgAggregateOutputType | null
    _sum: SubjectSumAggregateOutputType | null
    _min: SubjectMinAggregateOutputType | null
    _max: SubjectMaxAggregateOutputType | null
  }

  type GetSubjectGroupByPayload<T extends SubjectGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SubjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubjectGroupByOutputType[P]>
            : GetScalarType<T[P], SubjectGroupByOutputType[P]>
        }
      >
    >


  export type subjectSelect = {
    id?: boolean
    subjectName?: boolean
    subjectDefinition?: boolean
    imageLocation?: boolean
    published?: boolean
    usersId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | usersArgs
    note?: boolean | noteFindManyArgs
    notesDownloadable?: boolean | notesDownloadableFindManyArgs
    topic?: boolean | topicFindManyArgs
    forms?: boolean | formFindManyArgs
    _count?: boolean | SubjectCountOutputTypeArgs
  }

  export type subjectInclude = {
    users?: boolean | usersArgs
    note?: boolean | noteFindManyArgs
    notesDownloadable?: boolean | notesDownloadableFindManyArgs
    topic?: boolean | topicFindManyArgs
    forms?: boolean | formFindManyArgs
    _count?: boolean | SubjectCountOutputTypeArgs
  }

  export type subjectGetPayload<
    S extends boolean | null | undefined | subjectArgs,
    U = keyof S
      > = S extends true
        ? subject
    : S extends undefined
    ? never
    : S extends subjectArgs | subjectFindManyArgs
    ?'include' extends U
    ? subject  & {
    [P in TrueKeys<S['include']>]:
        P extends 'users' ? usersGetPayload<S['include'][P]> :
        P extends 'note' ? Array < noteGetPayload<S['include'][P]>>  :
        P extends 'notesDownloadable' ? Array < notesDownloadableGetPayload<S['include'][P]>>  :
        P extends 'topic' ? Array < topicGetPayload<S['include'][P]>>  :
        P extends 'forms' ? Array < formGetPayload<S['include'][P]>>  :
        P extends '_count' ? SubjectCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'users' ? usersGetPayload<S['select'][P]> :
        P extends 'note' ? Array < noteGetPayload<S['select'][P]>>  :
        P extends 'notesDownloadable' ? Array < notesDownloadableGetPayload<S['select'][P]>>  :
        P extends 'topic' ? Array < topicGetPayload<S['select'][P]>>  :
        P extends 'forms' ? Array < formGetPayload<S['select'][P]>>  :
        P extends '_count' ? SubjectCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof subject ? subject[P] : never
  } 
    : subject
  : subject


  type subjectCountArgs = Merge<
    Omit<subjectFindManyArgs, 'select' | 'include'> & {
      select?: SubjectCountAggregateInputType | true
    }
  >

  export interface subjectDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Subject that matches the filter.
     * @param {subjectFindUniqueArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends subjectFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, subjectFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'subject'> extends True ? CheckSelect<T, Prisma__subjectClient<subject>, Prisma__subjectClient<subjectGetPayload<T>>> : CheckSelect<T, Prisma__subjectClient<subject | null >, Prisma__subjectClient<subjectGetPayload<T> | null >>

    /**
     * Find the first Subject that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subjectFindFirstArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends subjectFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, subjectFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'subject'> extends True ? CheckSelect<T, Prisma__subjectClient<subject>, Prisma__subjectClient<subjectGetPayload<T>>> : CheckSelect<T, Prisma__subjectClient<subject | null >, Prisma__subjectClient<subjectGetPayload<T> | null >>

    /**
     * Find zero or more Subjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subjectFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subjects
     * const subjects = await prisma.subject.findMany()
     * 
     * // Get first 10 Subjects
     * const subjects = await prisma.subject.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subjectWithIdOnly = await prisma.subject.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends subjectFindManyArgs>(
      args?: SelectSubset<T, subjectFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<subject>>, PrismaPromise<Array<subjectGetPayload<T>>>>

    /**
     * Create a Subject.
     * @param {subjectCreateArgs} args - Arguments to create a Subject.
     * @example
     * // Create one Subject
     * const Subject = await prisma.subject.create({
     *   data: {
     *     // ... data to create a Subject
     *   }
     * })
     * 
    **/
    create<T extends subjectCreateArgs>(
      args: SelectSubset<T, subjectCreateArgs>
    ): CheckSelect<T, Prisma__subjectClient<subject>, Prisma__subjectClient<subjectGetPayload<T>>>

    /**
     * Create many Subjects.
     *     @param {subjectCreateManyArgs} args - Arguments to create many Subjects.
     *     @example
     *     // Create many Subjects
     *     const subject = await prisma.subject.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends subjectCreateManyArgs>(
      args?: SelectSubset<T, subjectCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Subject.
     * @param {subjectDeleteArgs} args - Arguments to delete one Subject.
     * @example
     * // Delete one Subject
     * const Subject = await prisma.subject.delete({
     *   where: {
     *     // ... filter to delete one Subject
     *   }
     * })
     * 
    **/
    delete<T extends subjectDeleteArgs>(
      args: SelectSubset<T, subjectDeleteArgs>
    ): CheckSelect<T, Prisma__subjectClient<subject>, Prisma__subjectClient<subjectGetPayload<T>>>

    /**
     * Update one Subject.
     * @param {subjectUpdateArgs} args - Arguments to update one Subject.
     * @example
     * // Update one Subject
     * const subject = await prisma.subject.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends subjectUpdateArgs>(
      args: SelectSubset<T, subjectUpdateArgs>
    ): CheckSelect<T, Prisma__subjectClient<subject>, Prisma__subjectClient<subjectGetPayload<T>>>

    /**
     * Delete zero or more Subjects.
     * @param {subjectDeleteManyArgs} args - Arguments to filter Subjects to delete.
     * @example
     * // Delete a few Subjects
     * const { count } = await prisma.subject.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends subjectDeleteManyArgs>(
      args?: SelectSubset<T, subjectDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subjects
     * const subject = await prisma.subject.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends subjectUpdateManyArgs>(
      args: SelectSubset<T, subjectUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Subject.
     * @param {subjectUpsertArgs} args - Arguments to update or create a Subject.
     * @example
     * // Update or create a Subject
     * const subject = await prisma.subject.upsert({
     *   create: {
     *     // ... data to create a Subject
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subject we want to update
     *   }
     * })
    **/
    upsert<T extends subjectUpsertArgs>(
      args: SelectSubset<T, subjectUpsertArgs>
    ): CheckSelect<T, Prisma__subjectClient<subject>, Prisma__subjectClient<subjectGetPayload<T>>>

    /**
     * Find one Subject that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {subjectFindUniqueOrThrowArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends subjectFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, subjectFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__subjectClient<subject>, Prisma__subjectClient<subjectGetPayload<T>>>

    /**
     * Find the first Subject that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subjectFindFirstOrThrowArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends subjectFindFirstOrThrowArgs>(
      args?: SelectSubset<T, subjectFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__subjectClient<subject>, Prisma__subjectClient<subjectGetPayload<T>>>

    /**
     * Count the number of Subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subjectCountArgs} args - Arguments to filter Subjects to count.
     * @example
     * // Count the number of Subjects
     * const count = await prisma.subject.count({
     *   where: {
     *     // ... the filter for the Subjects we want to count
     *   }
     * })
    **/
    count<T extends subjectCountArgs>(
      args?: Subset<T, subjectCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubjectAggregateArgs>(args: Subset<T, SubjectAggregateArgs>): PrismaPromise<GetSubjectAggregateType<T>>

    /**
     * Group by Subject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubjectGroupByArgs['orderBy'] }
        : { orderBy?: SubjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubjectGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for subject.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__subjectClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    users<T extends usersArgs = {}>(args?: Subset<T, usersArgs>): CheckSelect<T, Prisma__usersClient<users | null >, Prisma__usersClient<usersGetPayload<T> | null >>;

    note<T extends noteFindManyArgs = {}>(args?: Subset<T, noteFindManyArgs>): CheckSelect<T, PrismaPromise<Array<note>>, PrismaPromise<Array<noteGetPayload<T>>>>;

    notesDownloadable<T extends notesDownloadableFindManyArgs = {}>(args?: Subset<T, notesDownloadableFindManyArgs>): CheckSelect<T, PrismaPromise<Array<notesDownloadable>>, PrismaPromise<Array<notesDownloadableGetPayload<T>>>>;

    topic<T extends topicFindManyArgs = {}>(args?: Subset<T, topicFindManyArgs>): CheckSelect<T, PrismaPromise<Array<topic>>, PrismaPromise<Array<topicGetPayload<T>>>>;

    forms<T extends formFindManyArgs = {}>(args?: Subset<T, formFindManyArgs>): CheckSelect<T, PrismaPromise<Array<form>>, PrismaPromise<Array<formGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * subject base type for findUnique actions
   */
  export type subjectFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the subject
     * 
    **/
    select?: subjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: subjectInclude | null
    /**
     * Filter, which subject to fetch.
     * 
    **/
    where: subjectWhereUniqueInput
  }

  /**
   * subject: findUnique
   */
  export interface subjectFindUniqueArgs extends subjectFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * subject base type for findFirst actions
   */
  export type subjectFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the subject
     * 
    **/
    select?: subjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: subjectInclude | null
    /**
     * Filter, which subject to fetch.
     * 
    **/
    where?: subjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subjects to fetch.
     * 
    **/
    orderBy?: Enumerable<subjectOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for subjects.
     * 
    **/
    cursor?: subjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subjects from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subjects.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of subjects.
     * 
    **/
    distinct?: Enumerable<SubjectScalarFieldEnum>
  }

  /**
   * subject: findFirst
   */
  export interface subjectFindFirstArgs extends subjectFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * subject findMany
   */
  export type subjectFindManyArgs = {
    /**
     * Select specific fields to fetch from the subject
     * 
    **/
    select?: subjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: subjectInclude | null
    /**
     * Filter, which subjects to fetch.
     * 
    **/
    where?: subjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subjects to fetch.
     * 
    **/
    orderBy?: Enumerable<subjectOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing subjects.
     * 
    **/
    cursor?: subjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subjects from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subjects.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SubjectScalarFieldEnum>
  }


  /**
   * subject create
   */
  export type subjectCreateArgs = {
    /**
     * Select specific fields to fetch from the subject
     * 
    **/
    select?: subjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: subjectInclude | null
    /**
     * The data needed to create a subject.
     * 
    **/
    data: XOR<subjectCreateInput, subjectUncheckedCreateInput>
  }


  /**
   * subject createMany
   */
  export type subjectCreateManyArgs = {
    /**
     * The data used to create many subjects.
     * 
    **/
    data: Enumerable<subjectCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * subject update
   */
  export type subjectUpdateArgs = {
    /**
     * Select specific fields to fetch from the subject
     * 
    **/
    select?: subjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: subjectInclude | null
    /**
     * The data needed to update a subject.
     * 
    **/
    data: XOR<subjectUpdateInput, subjectUncheckedUpdateInput>
    /**
     * Choose, which subject to update.
     * 
    **/
    where: subjectWhereUniqueInput
  }


  /**
   * subject updateMany
   */
  export type subjectUpdateManyArgs = {
    /**
     * The data used to update subjects.
     * 
    **/
    data: XOR<subjectUpdateManyMutationInput, subjectUncheckedUpdateManyInput>
    /**
     * Filter which subjects to update
     * 
    **/
    where?: subjectWhereInput
  }


  /**
   * subject upsert
   */
  export type subjectUpsertArgs = {
    /**
     * Select specific fields to fetch from the subject
     * 
    **/
    select?: subjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: subjectInclude | null
    /**
     * The filter to search for the subject to update in case it exists.
     * 
    **/
    where: subjectWhereUniqueInput
    /**
     * In case the subject found by the `where` argument doesn't exist, create a new subject with this data.
     * 
    **/
    create: XOR<subjectCreateInput, subjectUncheckedCreateInput>
    /**
     * In case the subject was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<subjectUpdateInput, subjectUncheckedUpdateInput>
  }


  /**
   * subject delete
   */
  export type subjectDeleteArgs = {
    /**
     * Select specific fields to fetch from the subject
     * 
    **/
    select?: subjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: subjectInclude | null
    /**
     * Filter which subject to delete.
     * 
    **/
    where: subjectWhereUniqueInput
  }


  /**
   * subject deleteMany
   */
  export type subjectDeleteManyArgs = {
    /**
     * Filter which subjects to delete
     * 
    **/
    where?: subjectWhereInput
  }


  /**
   * subject: findUniqueOrThrow
   */
  export type subjectFindUniqueOrThrowArgs = subjectFindUniqueArgsBase
      

  /**
   * subject: findFirstOrThrow
   */
  export type subjectFindFirstOrThrowArgs = subjectFindFirstArgsBase
      

  /**
   * subject without action
   */
  export type subjectArgs = {
    /**
     * Select specific fields to fetch from the subject
     * 
    **/
    select?: subjectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: subjectInclude | null
  }



  /**
   * Model form
   */


  export type AggregateForm = {
    _count: FormCountAggregateOutputType | null
    _avg: FormAvgAggregateOutputType | null
    _sum: FormSumAggregateOutputType | null
    _min: FormMinAggregateOutputType | null
    _max: FormMaxAggregateOutputType | null
  }

  export type FormAvgAggregateOutputType = {
    id: number | null
    usersId: number | null
  }

  export type FormSumAggregateOutputType = {
    id: number | null
    usersId: number | null
  }

  export type FormMinAggregateOutputType = {
    id: number | null
    formName: string | null
    usersId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FormMaxAggregateOutputType = {
    id: number | null
    formName: string | null
    usersId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FormCountAggregateOutputType = {
    id: number
    formName: number
    usersId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FormAvgAggregateInputType = {
    id?: true
    usersId?: true
  }

  export type FormSumAggregateInputType = {
    id?: true
    usersId?: true
  }

  export type FormMinAggregateInputType = {
    id?: true
    formName?: true
    usersId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FormMaxAggregateInputType = {
    id?: true
    formName?: true
    usersId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FormCountAggregateInputType = {
    id?: true
    formName?: true
    usersId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FormAggregateArgs = {
    /**
     * Filter which form to aggregate.
     * 
    **/
    where?: formWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of forms to fetch.
     * 
    **/
    orderBy?: Enumerable<formOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: formWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` forms from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` forms.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned forms
    **/
    _count?: true | FormCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FormAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FormSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FormMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FormMaxAggregateInputType
  }

  export type GetFormAggregateType<T extends FormAggregateArgs> = {
        [P in keyof T & keyof AggregateForm]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateForm[P]>
      : GetScalarType<T[P], AggregateForm[P]>
  }




  export type FormGroupByArgs = {
    where?: formWhereInput
    orderBy?: Enumerable<formOrderByWithAggregationInput>
    by: Array<FormScalarFieldEnum>
    having?: formScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FormCountAggregateInputType | true
    _avg?: FormAvgAggregateInputType
    _sum?: FormSumAggregateInputType
    _min?: FormMinAggregateInputType
    _max?: FormMaxAggregateInputType
  }


  export type FormGroupByOutputType = {
    id: number
    formName: string
    usersId: number
    createdAt: Date
    updatedAt: Date
    _count: FormCountAggregateOutputType | null
    _avg: FormAvgAggregateOutputType | null
    _sum: FormSumAggregateOutputType | null
    _min: FormMinAggregateOutputType | null
    _max: FormMaxAggregateOutputType | null
  }

  type GetFormGroupByPayload<T extends FormGroupByArgs> = PrismaPromise<
    Array<
      PickArray<FormGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FormGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FormGroupByOutputType[P]>
            : GetScalarType<T[P], FormGroupByOutputType[P]>
        }
      >
    >


  export type formSelect = {
    id?: boolean
    formName?: boolean
    usersId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | usersArgs
    note?: boolean | noteFindManyArgs
    notesDownloadable?: boolean | notesDownloadableFindManyArgs
    topic?: boolean | topicFindManyArgs
    subjects?: boolean | subjectFindManyArgs
    _count?: boolean | FormCountOutputTypeArgs
  }

  export type formInclude = {
    users?: boolean | usersArgs
    note?: boolean | noteFindManyArgs
    notesDownloadable?: boolean | notesDownloadableFindManyArgs
    topic?: boolean | topicFindManyArgs
    subjects?: boolean | subjectFindManyArgs
    _count?: boolean | FormCountOutputTypeArgs
  }

  export type formGetPayload<
    S extends boolean | null | undefined | formArgs,
    U = keyof S
      > = S extends true
        ? form
    : S extends undefined
    ? never
    : S extends formArgs | formFindManyArgs
    ?'include' extends U
    ? form  & {
    [P in TrueKeys<S['include']>]:
        P extends 'users' ? usersGetPayload<S['include'][P]> :
        P extends 'note' ? Array < noteGetPayload<S['include'][P]>>  :
        P extends 'notesDownloadable' ? Array < notesDownloadableGetPayload<S['include'][P]>>  :
        P extends 'topic' ? Array < topicGetPayload<S['include'][P]>>  :
        P extends 'subjects' ? Array < subjectGetPayload<S['include'][P]>>  :
        P extends '_count' ? FormCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'users' ? usersGetPayload<S['select'][P]> :
        P extends 'note' ? Array < noteGetPayload<S['select'][P]>>  :
        P extends 'notesDownloadable' ? Array < notesDownloadableGetPayload<S['select'][P]>>  :
        P extends 'topic' ? Array < topicGetPayload<S['select'][P]>>  :
        P extends 'subjects' ? Array < subjectGetPayload<S['select'][P]>>  :
        P extends '_count' ? FormCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof form ? form[P] : never
  } 
    : form
  : form


  type formCountArgs = Merge<
    Omit<formFindManyArgs, 'select' | 'include'> & {
      select?: FormCountAggregateInputType | true
    }
  >

  export interface formDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Form that matches the filter.
     * @param {formFindUniqueArgs} args - Arguments to find a Form
     * @example
     * // Get one Form
     * const form = await prisma.form.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends formFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, formFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'form'> extends True ? CheckSelect<T, Prisma__formClient<form>, Prisma__formClient<formGetPayload<T>>> : CheckSelect<T, Prisma__formClient<form | null >, Prisma__formClient<formGetPayload<T> | null >>

    /**
     * Find the first Form that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formFindFirstArgs} args - Arguments to find a Form
     * @example
     * // Get one Form
     * const form = await prisma.form.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends formFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, formFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'form'> extends True ? CheckSelect<T, Prisma__formClient<form>, Prisma__formClient<formGetPayload<T>>> : CheckSelect<T, Prisma__formClient<form | null >, Prisma__formClient<formGetPayload<T> | null >>

    /**
     * Find zero or more Forms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Forms
     * const forms = await prisma.form.findMany()
     * 
     * // Get first 10 Forms
     * const forms = await prisma.form.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const formWithIdOnly = await prisma.form.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends formFindManyArgs>(
      args?: SelectSubset<T, formFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<form>>, PrismaPromise<Array<formGetPayload<T>>>>

    /**
     * Create a Form.
     * @param {formCreateArgs} args - Arguments to create a Form.
     * @example
     * // Create one Form
     * const Form = await prisma.form.create({
     *   data: {
     *     // ... data to create a Form
     *   }
     * })
     * 
    **/
    create<T extends formCreateArgs>(
      args: SelectSubset<T, formCreateArgs>
    ): CheckSelect<T, Prisma__formClient<form>, Prisma__formClient<formGetPayload<T>>>

    /**
     * Create many Forms.
     *     @param {formCreateManyArgs} args - Arguments to create many Forms.
     *     @example
     *     // Create many Forms
     *     const form = await prisma.form.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends formCreateManyArgs>(
      args?: SelectSubset<T, formCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Form.
     * @param {formDeleteArgs} args - Arguments to delete one Form.
     * @example
     * // Delete one Form
     * const Form = await prisma.form.delete({
     *   where: {
     *     // ... filter to delete one Form
     *   }
     * })
     * 
    **/
    delete<T extends formDeleteArgs>(
      args: SelectSubset<T, formDeleteArgs>
    ): CheckSelect<T, Prisma__formClient<form>, Prisma__formClient<formGetPayload<T>>>

    /**
     * Update one Form.
     * @param {formUpdateArgs} args - Arguments to update one Form.
     * @example
     * // Update one Form
     * const form = await prisma.form.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends formUpdateArgs>(
      args: SelectSubset<T, formUpdateArgs>
    ): CheckSelect<T, Prisma__formClient<form>, Prisma__formClient<formGetPayload<T>>>

    /**
     * Delete zero or more Forms.
     * @param {formDeleteManyArgs} args - Arguments to filter Forms to delete.
     * @example
     * // Delete a few Forms
     * const { count } = await prisma.form.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends formDeleteManyArgs>(
      args?: SelectSubset<T, formDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Forms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Forms
     * const form = await prisma.form.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends formUpdateManyArgs>(
      args: SelectSubset<T, formUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Form.
     * @param {formUpsertArgs} args - Arguments to update or create a Form.
     * @example
     * // Update or create a Form
     * const form = await prisma.form.upsert({
     *   create: {
     *     // ... data to create a Form
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Form we want to update
     *   }
     * })
    **/
    upsert<T extends formUpsertArgs>(
      args: SelectSubset<T, formUpsertArgs>
    ): CheckSelect<T, Prisma__formClient<form>, Prisma__formClient<formGetPayload<T>>>

    /**
     * Find one Form that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {formFindUniqueOrThrowArgs} args - Arguments to find a Form
     * @example
     * // Get one Form
     * const form = await prisma.form.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends formFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, formFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__formClient<form>, Prisma__formClient<formGetPayload<T>>>

    /**
     * Find the first Form that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formFindFirstOrThrowArgs} args - Arguments to find a Form
     * @example
     * // Get one Form
     * const form = await prisma.form.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends formFindFirstOrThrowArgs>(
      args?: SelectSubset<T, formFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__formClient<form>, Prisma__formClient<formGetPayload<T>>>

    /**
     * Count the number of Forms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formCountArgs} args - Arguments to filter Forms to count.
     * @example
     * // Count the number of Forms
     * const count = await prisma.form.count({
     *   where: {
     *     // ... the filter for the Forms we want to count
     *   }
     * })
    **/
    count<T extends formCountArgs>(
      args?: Subset<T, formCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FormCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Form.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FormAggregateArgs>(args: Subset<T, FormAggregateArgs>): PrismaPromise<GetFormAggregateType<T>>

    /**
     * Group by Form.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FormGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FormGroupByArgs['orderBy'] }
        : { orderBy?: FormGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FormGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFormGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for form.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__formClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    users<T extends usersArgs = {}>(args?: Subset<T, usersArgs>): CheckSelect<T, Prisma__usersClient<users | null >, Prisma__usersClient<usersGetPayload<T> | null >>;

    note<T extends noteFindManyArgs = {}>(args?: Subset<T, noteFindManyArgs>): CheckSelect<T, PrismaPromise<Array<note>>, PrismaPromise<Array<noteGetPayload<T>>>>;

    notesDownloadable<T extends notesDownloadableFindManyArgs = {}>(args?: Subset<T, notesDownloadableFindManyArgs>): CheckSelect<T, PrismaPromise<Array<notesDownloadable>>, PrismaPromise<Array<notesDownloadableGetPayload<T>>>>;

    topic<T extends topicFindManyArgs = {}>(args?: Subset<T, topicFindManyArgs>): CheckSelect<T, PrismaPromise<Array<topic>>, PrismaPromise<Array<topicGetPayload<T>>>>;

    subjects<T extends subjectFindManyArgs = {}>(args?: Subset<T, subjectFindManyArgs>): CheckSelect<T, PrismaPromise<Array<subject>>, PrismaPromise<Array<subjectGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * form base type for findUnique actions
   */
  export type formFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the form
     * 
    **/
    select?: formSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: formInclude | null
    /**
     * Filter, which form to fetch.
     * 
    **/
    where: formWhereUniqueInput
  }

  /**
   * form: findUnique
   */
  export interface formFindUniqueArgs extends formFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * form base type for findFirst actions
   */
  export type formFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the form
     * 
    **/
    select?: formSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: formInclude | null
    /**
     * Filter, which form to fetch.
     * 
    **/
    where?: formWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of forms to fetch.
     * 
    **/
    orderBy?: Enumerable<formOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for forms.
     * 
    **/
    cursor?: formWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` forms from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` forms.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of forms.
     * 
    **/
    distinct?: Enumerable<FormScalarFieldEnum>
  }

  /**
   * form: findFirst
   */
  export interface formFindFirstArgs extends formFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * form findMany
   */
  export type formFindManyArgs = {
    /**
     * Select specific fields to fetch from the form
     * 
    **/
    select?: formSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: formInclude | null
    /**
     * Filter, which forms to fetch.
     * 
    **/
    where?: formWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of forms to fetch.
     * 
    **/
    orderBy?: Enumerable<formOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing forms.
     * 
    **/
    cursor?: formWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` forms from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` forms.
     * 
    **/
    skip?: number
    distinct?: Enumerable<FormScalarFieldEnum>
  }


  /**
   * form create
   */
  export type formCreateArgs = {
    /**
     * Select specific fields to fetch from the form
     * 
    **/
    select?: formSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: formInclude | null
    /**
     * The data needed to create a form.
     * 
    **/
    data: XOR<formCreateInput, formUncheckedCreateInput>
  }


  /**
   * form createMany
   */
  export type formCreateManyArgs = {
    /**
     * The data used to create many forms.
     * 
    **/
    data: Enumerable<formCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * form update
   */
  export type formUpdateArgs = {
    /**
     * Select specific fields to fetch from the form
     * 
    **/
    select?: formSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: formInclude | null
    /**
     * The data needed to update a form.
     * 
    **/
    data: XOR<formUpdateInput, formUncheckedUpdateInput>
    /**
     * Choose, which form to update.
     * 
    **/
    where: formWhereUniqueInput
  }


  /**
   * form updateMany
   */
  export type formUpdateManyArgs = {
    /**
     * The data used to update forms.
     * 
    **/
    data: XOR<formUpdateManyMutationInput, formUncheckedUpdateManyInput>
    /**
     * Filter which forms to update
     * 
    **/
    where?: formWhereInput
  }


  /**
   * form upsert
   */
  export type formUpsertArgs = {
    /**
     * Select specific fields to fetch from the form
     * 
    **/
    select?: formSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: formInclude | null
    /**
     * The filter to search for the form to update in case it exists.
     * 
    **/
    where: formWhereUniqueInput
    /**
     * In case the form found by the `where` argument doesn't exist, create a new form with this data.
     * 
    **/
    create: XOR<formCreateInput, formUncheckedCreateInput>
    /**
     * In case the form was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<formUpdateInput, formUncheckedUpdateInput>
  }


  /**
   * form delete
   */
  export type formDeleteArgs = {
    /**
     * Select specific fields to fetch from the form
     * 
    **/
    select?: formSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: formInclude | null
    /**
     * Filter which form to delete.
     * 
    **/
    where: formWhereUniqueInput
  }


  /**
   * form deleteMany
   */
  export type formDeleteManyArgs = {
    /**
     * Filter which forms to delete
     * 
    **/
    where?: formWhereInput
  }


  /**
   * form: findUniqueOrThrow
   */
  export type formFindUniqueOrThrowArgs = formFindUniqueArgsBase
      

  /**
   * form: findFirstOrThrow
   */
  export type formFindFirstOrThrowArgs = formFindFirstArgsBase
      

  /**
   * form without action
   */
  export type formArgs = {
    /**
     * Select specific fields to fetch from the form
     * 
    **/
    select?: formSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: formInclude | null
  }



  /**
   * Model topic
   */


  export type AggregateTopic = {
    _count: TopicCountAggregateOutputType | null
    _avg: TopicAvgAggregateOutputType | null
    _sum: TopicSumAggregateOutputType | null
    _min: TopicMinAggregateOutputType | null
    _max: TopicMaxAggregateOutputType | null
  }

  export type TopicAvgAggregateOutputType = {
    id: number | null
    subjectId: number | null
    formId: number | null
    usersId: number | null
  }

  export type TopicSumAggregateOutputType = {
    id: number | null
    subjectId: number | null
    formId: number | null
    usersId: number | null
  }

  export type TopicMinAggregateOutputType = {
    id: number | null
    topicName: string | null
    topicDefinition: string | null
    published: boolean | null
    subjectId: number | null
    formId: number | null
    usersId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TopicMaxAggregateOutputType = {
    id: number | null
    topicName: string | null
    topicDefinition: string | null
    published: boolean | null
    subjectId: number | null
    formId: number | null
    usersId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TopicCountAggregateOutputType = {
    id: number
    topicName: number
    topicDefinition: number
    published: number
    subjectId: number
    formId: number
    usersId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TopicAvgAggregateInputType = {
    id?: true
    subjectId?: true
    formId?: true
    usersId?: true
  }

  export type TopicSumAggregateInputType = {
    id?: true
    subjectId?: true
    formId?: true
    usersId?: true
  }

  export type TopicMinAggregateInputType = {
    id?: true
    topicName?: true
    topicDefinition?: true
    published?: true
    subjectId?: true
    formId?: true
    usersId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TopicMaxAggregateInputType = {
    id?: true
    topicName?: true
    topicDefinition?: true
    published?: true
    subjectId?: true
    formId?: true
    usersId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TopicCountAggregateInputType = {
    id?: true
    topicName?: true
    topicDefinition?: true
    published?: true
    subjectId?: true
    formId?: true
    usersId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TopicAggregateArgs = {
    /**
     * Filter which topic to aggregate.
     * 
    **/
    where?: topicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of topics to fetch.
     * 
    **/
    orderBy?: Enumerable<topicOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: topicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` topics from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` topics.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned topics
    **/
    _count?: true | TopicCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TopicAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TopicSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TopicMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TopicMaxAggregateInputType
  }

  export type GetTopicAggregateType<T extends TopicAggregateArgs> = {
        [P in keyof T & keyof AggregateTopic]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTopic[P]>
      : GetScalarType<T[P], AggregateTopic[P]>
  }




  export type TopicGroupByArgs = {
    where?: topicWhereInput
    orderBy?: Enumerable<topicOrderByWithAggregationInput>
    by: Array<TopicScalarFieldEnum>
    having?: topicScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TopicCountAggregateInputType | true
    _avg?: TopicAvgAggregateInputType
    _sum?: TopicSumAggregateInputType
    _min?: TopicMinAggregateInputType
    _max?: TopicMaxAggregateInputType
  }


  export type TopicGroupByOutputType = {
    id: number
    topicName: string
    topicDefinition: string | null
    published: boolean
    subjectId: number
    formId: number
    usersId: number
    createdAt: Date
    updatedAt: Date
    _count: TopicCountAggregateOutputType | null
    _avg: TopicAvgAggregateOutputType | null
    _sum: TopicSumAggregateOutputType | null
    _min: TopicMinAggregateOutputType | null
    _max: TopicMaxAggregateOutputType | null
  }

  type GetTopicGroupByPayload<T extends TopicGroupByArgs> = PrismaPromise<
    Array<
      PickArray<TopicGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TopicGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TopicGroupByOutputType[P]>
            : GetScalarType<T[P], TopicGroupByOutputType[P]>
        }
      >
    >


  export type topicSelect = {
    id?: boolean
    topicName?: boolean
    topicDefinition?: boolean
    published?: boolean
    subjectId?: boolean
    formId?: boolean
    usersId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    form?: boolean | formArgs
    subject?: boolean | subjectArgs
    users?: boolean | usersArgs
    note?: boolean | noteArgs
  }

  export type topicInclude = {
    form?: boolean | formArgs
    subject?: boolean | subjectArgs
    users?: boolean | usersArgs
    note?: boolean | noteArgs
  }

  export type topicGetPayload<
    S extends boolean | null | undefined | topicArgs,
    U = keyof S
      > = S extends true
        ? topic
    : S extends undefined
    ? never
    : S extends topicArgs | topicFindManyArgs
    ?'include' extends U
    ? topic  & {
    [P in TrueKeys<S['include']>]:
        P extends 'form' ? formGetPayload<S['include'][P]> :
        P extends 'subject' ? subjectGetPayload<S['include'][P]> :
        P extends 'users' ? usersGetPayload<S['include'][P]> :
        P extends 'note' ? noteGetPayload<S['include'][P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'form' ? formGetPayload<S['select'][P]> :
        P extends 'subject' ? subjectGetPayload<S['select'][P]> :
        P extends 'users' ? usersGetPayload<S['select'][P]> :
        P extends 'note' ? noteGetPayload<S['select'][P]> | null :  P extends keyof topic ? topic[P] : never
  } 
    : topic
  : topic


  type topicCountArgs = Merge<
    Omit<topicFindManyArgs, 'select' | 'include'> & {
      select?: TopicCountAggregateInputType | true
    }
  >

  export interface topicDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Topic that matches the filter.
     * @param {topicFindUniqueArgs} args - Arguments to find a Topic
     * @example
     * // Get one Topic
     * const topic = await prisma.topic.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends topicFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, topicFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'topic'> extends True ? CheckSelect<T, Prisma__topicClient<topic>, Prisma__topicClient<topicGetPayload<T>>> : CheckSelect<T, Prisma__topicClient<topic | null >, Prisma__topicClient<topicGetPayload<T> | null >>

    /**
     * Find the first Topic that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {topicFindFirstArgs} args - Arguments to find a Topic
     * @example
     * // Get one Topic
     * const topic = await prisma.topic.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends topicFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, topicFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'topic'> extends True ? CheckSelect<T, Prisma__topicClient<topic>, Prisma__topicClient<topicGetPayload<T>>> : CheckSelect<T, Prisma__topicClient<topic | null >, Prisma__topicClient<topicGetPayload<T> | null >>

    /**
     * Find zero or more Topics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {topicFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Topics
     * const topics = await prisma.topic.findMany()
     * 
     * // Get first 10 Topics
     * const topics = await prisma.topic.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const topicWithIdOnly = await prisma.topic.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends topicFindManyArgs>(
      args?: SelectSubset<T, topicFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<topic>>, PrismaPromise<Array<topicGetPayload<T>>>>

    /**
     * Create a Topic.
     * @param {topicCreateArgs} args - Arguments to create a Topic.
     * @example
     * // Create one Topic
     * const Topic = await prisma.topic.create({
     *   data: {
     *     // ... data to create a Topic
     *   }
     * })
     * 
    **/
    create<T extends topicCreateArgs>(
      args: SelectSubset<T, topicCreateArgs>
    ): CheckSelect<T, Prisma__topicClient<topic>, Prisma__topicClient<topicGetPayload<T>>>

    /**
     * Create many Topics.
     *     @param {topicCreateManyArgs} args - Arguments to create many Topics.
     *     @example
     *     // Create many Topics
     *     const topic = await prisma.topic.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends topicCreateManyArgs>(
      args?: SelectSubset<T, topicCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Topic.
     * @param {topicDeleteArgs} args - Arguments to delete one Topic.
     * @example
     * // Delete one Topic
     * const Topic = await prisma.topic.delete({
     *   where: {
     *     // ... filter to delete one Topic
     *   }
     * })
     * 
    **/
    delete<T extends topicDeleteArgs>(
      args: SelectSubset<T, topicDeleteArgs>
    ): CheckSelect<T, Prisma__topicClient<topic>, Prisma__topicClient<topicGetPayload<T>>>

    /**
     * Update one Topic.
     * @param {topicUpdateArgs} args - Arguments to update one Topic.
     * @example
     * // Update one Topic
     * const topic = await prisma.topic.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends topicUpdateArgs>(
      args: SelectSubset<T, topicUpdateArgs>
    ): CheckSelect<T, Prisma__topicClient<topic>, Prisma__topicClient<topicGetPayload<T>>>

    /**
     * Delete zero or more Topics.
     * @param {topicDeleteManyArgs} args - Arguments to filter Topics to delete.
     * @example
     * // Delete a few Topics
     * const { count } = await prisma.topic.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends topicDeleteManyArgs>(
      args?: SelectSubset<T, topicDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Topics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {topicUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Topics
     * const topic = await prisma.topic.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends topicUpdateManyArgs>(
      args: SelectSubset<T, topicUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Topic.
     * @param {topicUpsertArgs} args - Arguments to update or create a Topic.
     * @example
     * // Update or create a Topic
     * const topic = await prisma.topic.upsert({
     *   create: {
     *     // ... data to create a Topic
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Topic we want to update
     *   }
     * })
    **/
    upsert<T extends topicUpsertArgs>(
      args: SelectSubset<T, topicUpsertArgs>
    ): CheckSelect<T, Prisma__topicClient<topic>, Prisma__topicClient<topicGetPayload<T>>>

    /**
     * Find one Topic that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {topicFindUniqueOrThrowArgs} args - Arguments to find a Topic
     * @example
     * // Get one Topic
     * const topic = await prisma.topic.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends topicFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, topicFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__topicClient<topic>, Prisma__topicClient<topicGetPayload<T>>>

    /**
     * Find the first Topic that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {topicFindFirstOrThrowArgs} args - Arguments to find a Topic
     * @example
     * // Get one Topic
     * const topic = await prisma.topic.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends topicFindFirstOrThrowArgs>(
      args?: SelectSubset<T, topicFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__topicClient<topic>, Prisma__topicClient<topicGetPayload<T>>>

    /**
     * Count the number of Topics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {topicCountArgs} args - Arguments to filter Topics to count.
     * @example
     * // Count the number of Topics
     * const count = await prisma.topic.count({
     *   where: {
     *     // ... the filter for the Topics we want to count
     *   }
     * })
    **/
    count<T extends topicCountArgs>(
      args?: Subset<T, topicCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TopicCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Topic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TopicAggregateArgs>(args: Subset<T, TopicAggregateArgs>): PrismaPromise<GetTopicAggregateType<T>>

    /**
     * Group by Topic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TopicGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TopicGroupByArgs['orderBy'] }
        : { orderBy?: TopicGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TopicGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTopicGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for topic.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__topicClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    form<T extends formArgs = {}>(args?: Subset<T, formArgs>): CheckSelect<T, Prisma__formClient<form | null >, Prisma__formClient<formGetPayload<T> | null >>;

    subject<T extends subjectArgs = {}>(args?: Subset<T, subjectArgs>): CheckSelect<T, Prisma__subjectClient<subject | null >, Prisma__subjectClient<subjectGetPayload<T> | null >>;

    users<T extends usersArgs = {}>(args?: Subset<T, usersArgs>): CheckSelect<T, Prisma__usersClient<users | null >, Prisma__usersClient<usersGetPayload<T> | null >>;

    note<T extends noteArgs = {}>(args?: Subset<T, noteArgs>): CheckSelect<T, Prisma__noteClient<note | null >, Prisma__noteClient<noteGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * topic base type for findUnique actions
   */
  export type topicFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the topic
     * 
    **/
    select?: topicSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: topicInclude | null
    /**
     * Filter, which topic to fetch.
     * 
    **/
    where: topicWhereUniqueInput
  }

  /**
   * topic: findUnique
   */
  export interface topicFindUniqueArgs extends topicFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * topic base type for findFirst actions
   */
  export type topicFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the topic
     * 
    **/
    select?: topicSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: topicInclude | null
    /**
     * Filter, which topic to fetch.
     * 
    **/
    where?: topicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of topics to fetch.
     * 
    **/
    orderBy?: Enumerable<topicOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for topics.
     * 
    **/
    cursor?: topicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` topics from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` topics.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of topics.
     * 
    **/
    distinct?: Enumerable<TopicScalarFieldEnum>
  }

  /**
   * topic: findFirst
   */
  export interface topicFindFirstArgs extends topicFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * topic findMany
   */
  export type topicFindManyArgs = {
    /**
     * Select specific fields to fetch from the topic
     * 
    **/
    select?: topicSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: topicInclude | null
    /**
     * Filter, which topics to fetch.
     * 
    **/
    where?: topicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of topics to fetch.
     * 
    **/
    orderBy?: Enumerable<topicOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing topics.
     * 
    **/
    cursor?: topicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` topics from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` topics.
     * 
    **/
    skip?: number
    distinct?: Enumerable<TopicScalarFieldEnum>
  }


  /**
   * topic create
   */
  export type topicCreateArgs = {
    /**
     * Select specific fields to fetch from the topic
     * 
    **/
    select?: topicSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: topicInclude | null
    /**
     * The data needed to create a topic.
     * 
    **/
    data: XOR<topicCreateInput, topicUncheckedCreateInput>
  }


  /**
   * topic createMany
   */
  export type topicCreateManyArgs = {
    /**
     * The data used to create many topics.
     * 
    **/
    data: Enumerable<topicCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * topic update
   */
  export type topicUpdateArgs = {
    /**
     * Select specific fields to fetch from the topic
     * 
    **/
    select?: topicSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: topicInclude | null
    /**
     * The data needed to update a topic.
     * 
    **/
    data: XOR<topicUpdateInput, topicUncheckedUpdateInput>
    /**
     * Choose, which topic to update.
     * 
    **/
    where: topicWhereUniqueInput
  }


  /**
   * topic updateMany
   */
  export type topicUpdateManyArgs = {
    /**
     * The data used to update topics.
     * 
    **/
    data: XOR<topicUpdateManyMutationInput, topicUncheckedUpdateManyInput>
    /**
     * Filter which topics to update
     * 
    **/
    where?: topicWhereInput
  }


  /**
   * topic upsert
   */
  export type topicUpsertArgs = {
    /**
     * Select specific fields to fetch from the topic
     * 
    **/
    select?: topicSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: topicInclude | null
    /**
     * The filter to search for the topic to update in case it exists.
     * 
    **/
    where: topicWhereUniqueInput
    /**
     * In case the topic found by the `where` argument doesn't exist, create a new topic with this data.
     * 
    **/
    create: XOR<topicCreateInput, topicUncheckedCreateInput>
    /**
     * In case the topic was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<topicUpdateInput, topicUncheckedUpdateInput>
  }


  /**
   * topic delete
   */
  export type topicDeleteArgs = {
    /**
     * Select specific fields to fetch from the topic
     * 
    **/
    select?: topicSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: topicInclude | null
    /**
     * Filter which topic to delete.
     * 
    **/
    where: topicWhereUniqueInput
  }


  /**
   * topic deleteMany
   */
  export type topicDeleteManyArgs = {
    /**
     * Filter which topics to delete
     * 
    **/
    where?: topicWhereInput
  }


  /**
   * topic: findUniqueOrThrow
   */
  export type topicFindUniqueOrThrowArgs = topicFindUniqueArgsBase
      

  /**
   * topic: findFirstOrThrow
   */
  export type topicFindFirstOrThrowArgs = topicFindFirstArgsBase
      

  /**
   * topic without action
   */
  export type topicArgs = {
    /**
     * Select specific fields to fetch from the topic
     * 
    **/
    select?: topicSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: topicInclude | null
  }



  /**
   * Model note
   */


  export type AggregateNote = {
    _count: NoteCountAggregateOutputType | null
    _avg: NoteAvgAggregateOutputType | null
    _sum: NoteSumAggregateOutputType | null
    _min: NoteMinAggregateOutputType | null
    _max: NoteMaxAggregateOutputType | null
  }

  export type NoteAvgAggregateOutputType = {
    id: number | null
    subjectId: number | null
    formId: number | null
    usersId: number | null
    topicId: number | null
  }

  export type NoteSumAggregateOutputType = {
    id: number | null
    subjectId: number | null
    formId: number | null
    usersId: number | null
    topicId: number | null
  }

  export type NoteMinAggregateOutputType = {
    id: number | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
    published: boolean | null
    subjectId: number | null
    formId: number | null
    usersId: number | null
    topicId: number | null
  }

  export type NoteMaxAggregateOutputType = {
    id: number | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
    published: boolean | null
    subjectId: number | null
    formId: number | null
    usersId: number | null
    topicId: number | null
  }

  export type NoteCountAggregateOutputType = {
    id: number
    content: number
    createdAt: number
    updatedAt: number
    published: number
    subjectId: number
    formId: number
    usersId: number
    topicId: number
    _all: number
  }


  export type NoteAvgAggregateInputType = {
    id?: true
    subjectId?: true
    formId?: true
    usersId?: true
    topicId?: true
  }

  export type NoteSumAggregateInputType = {
    id?: true
    subjectId?: true
    formId?: true
    usersId?: true
    topicId?: true
  }

  export type NoteMinAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    published?: true
    subjectId?: true
    formId?: true
    usersId?: true
    topicId?: true
  }

  export type NoteMaxAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    published?: true
    subjectId?: true
    formId?: true
    usersId?: true
    topicId?: true
  }

  export type NoteCountAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    published?: true
    subjectId?: true
    formId?: true
    usersId?: true
    topicId?: true
    _all?: true
  }

  export type NoteAggregateArgs = {
    /**
     * Filter which note to aggregate.
     * 
    **/
    where?: noteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notes to fetch.
     * 
    **/
    orderBy?: Enumerable<noteOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: noteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned notes
    **/
    _count?: true | NoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NoteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NoteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NoteMaxAggregateInputType
  }

  export type GetNoteAggregateType<T extends NoteAggregateArgs> = {
        [P in keyof T & keyof AggregateNote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNote[P]>
      : GetScalarType<T[P], AggregateNote[P]>
  }




  export type NoteGroupByArgs = {
    where?: noteWhereInput
    orderBy?: Enumerable<noteOrderByWithAggregationInput>
    by: Array<NoteScalarFieldEnum>
    having?: noteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NoteCountAggregateInputType | true
    _avg?: NoteAvgAggregateInputType
    _sum?: NoteSumAggregateInputType
    _min?: NoteMinAggregateInputType
    _max?: NoteMaxAggregateInputType
  }


  export type NoteGroupByOutputType = {
    id: number
    content: string
    createdAt: Date
    updatedAt: Date
    published: boolean
    subjectId: number
    formId: number
    usersId: number
    topicId: number
    _count: NoteCountAggregateOutputType | null
    _avg: NoteAvgAggregateOutputType | null
    _sum: NoteSumAggregateOutputType | null
    _min: NoteMinAggregateOutputType | null
    _max: NoteMaxAggregateOutputType | null
  }

  type GetNoteGroupByPayload<T extends NoteGroupByArgs> = PrismaPromise<
    Array<
      PickArray<NoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NoteGroupByOutputType[P]>
            : GetScalarType<T[P], NoteGroupByOutputType[P]>
        }
      >
    >


  export type noteSelect = {
    id?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    published?: boolean
    subjectId?: boolean
    formId?: boolean
    usersId?: boolean
    topicId?: boolean
    form?: boolean | formArgs
    subject?: boolean | subjectArgs
    topic?: boolean | topicArgs
    users?: boolean | usersArgs
  }

  export type noteInclude = {
    form?: boolean | formArgs
    subject?: boolean | subjectArgs
    topic?: boolean | topicArgs
    users?: boolean | usersArgs
  }

  export type noteGetPayload<
    S extends boolean | null | undefined | noteArgs,
    U = keyof S
      > = S extends true
        ? note
    : S extends undefined
    ? never
    : S extends noteArgs | noteFindManyArgs
    ?'include' extends U
    ? note  & {
    [P in TrueKeys<S['include']>]:
        P extends 'form' ? formGetPayload<S['include'][P]> :
        P extends 'subject' ? subjectGetPayload<S['include'][P]> :
        P extends 'topic' ? topicGetPayload<S['include'][P]> :
        P extends 'users' ? usersGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'form' ? formGetPayload<S['select'][P]> :
        P extends 'subject' ? subjectGetPayload<S['select'][P]> :
        P extends 'topic' ? topicGetPayload<S['select'][P]> :
        P extends 'users' ? usersGetPayload<S['select'][P]> :  P extends keyof note ? note[P] : never
  } 
    : note
  : note


  type noteCountArgs = Merge<
    Omit<noteFindManyArgs, 'select' | 'include'> & {
      select?: NoteCountAggregateInputType | true
    }
  >

  export interface noteDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Note that matches the filter.
     * @param {noteFindUniqueArgs} args - Arguments to find a Note
     * @example
     * // Get one Note
     * const note = await prisma.note.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends noteFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, noteFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'note'> extends True ? CheckSelect<T, Prisma__noteClient<note>, Prisma__noteClient<noteGetPayload<T>>> : CheckSelect<T, Prisma__noteClient<note | null >, Prisma__noteClient<noteGetPayload<T> | null >>

    /**
     * Find the first Note that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {noteFindFirstArgs} args - Arguments to find a Note
     * @example
     * // Get one Note
     * const note = await prisma.note.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends noteFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, noteFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'note'> extends True ? CheckSelect<T, Prisma__noteClient<note>, Prisma__noteClient<noteGetPayload<T>>> : CheckSelect<T, Prisma__noteClient<note | null >, Prisma__noteClient<noteGetPayload<T> | null >>

    /**
     * Find zero or more Notes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {noteFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notes
     * const notes = await prisma.note.findMany()
     * 
     * // Get first 10 Notes
     * const notes = await prisma.note.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const noteWithIdOnly = await prisma.note.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends noteFindManyArgs>(
      args?: SelectSubset<T, noteFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<note>>, PrismaPromise<Array<noteGetPayload<T>>>>

    /**
     * Create a Note.
     * @param {noteCreateArgs} args - Arguments to create a Note.
     * @example
     * // Create one Note
     * const Note = await prisma.note.create({
     *   data: {
     *     // ... data to create a Note
     *   }
     * })
     * 
    **/
    create<T extends noteCreateArgs>(
      args: SelectSubset<T, noteCreateArgs>
    ): CheckSelect<T, Prisma__noteClient<note>, Prisma__noteClient<noteGetPayload<T>>>

    /**
     * Create many Notes.
     *     @param {noteCreateManyArgs} args - Arguments to create many Notes.
     *     @example
     *     // Create many Notes
     *     const note = await prisma.note.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends noteCreateManyArgs>(
      args?: SelectSubset<T, noteCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Note.
     * @param {noteDeleteArgs} args - Arguments to delete one Note.
     * @example
     * // Delete one Note
     * const Note = await prisma.note.delete({
     *   where: {
     *     // ... filter to delete one Note
     *   }
     * })
     * 
    **/
    delete<T extends noteDeleteArgs>(
      args: SelectSubset<T, noteDeleteArgs>
    ): CheckSelect<T, Prisma__noteClient<note>, Prisma__noteClient<noteGetPayload<T>>>

    /**
     * Update one Note.
     * @param {noteUpdateArgs} args - Arguments to update one Note.
     * @example
     * // Update one Note
     * const note = await prisma.note.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends noteUpdateArgs>(
      args: SelectSubset<T, noteUpdateArgs>
    ): CheckSelect<T, Prisma__noteClient<note>, Prisma__noteClient<noteGetPayload<T>>>

    /**
     * Delete zero or more Notes.
     * @param {noteDeleteManyArgs} args - Arguments to filter Notes to delete.
     * @example
     * // Delete a few Notes
     * const { count } = await prisma.note.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends noteDeleteManyArgs>(
      args?: SelectSubset<T, noteDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {noteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notes
     * const note = await prisma.note.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends noteUpdateManyArgs>(
      args: SelectSubset<T, noteUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Note.
     * @param {noteUpsertArgs} args - Arguments to update or create a Note.
     * @example
     * // Update or create a Note
     * const note = await prisma.note.upsert({
     *   create: {
     *     // ... data to create a Note
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Note we want to update
     *   }
     * })
    **/
    upsert<T extends noteUpsertArgs>(
      args: SelectSubset<T, noteUpsertArgs>
    ): CheckSelect<T, Prisma__noteClient<note>, Prisma__noteClient<noteGetPayload<T>>>

    /**
     * Find one Note that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {noteFindUniqueOrThrowArgs} args - Arguments to find a Note
     * @example
     * // Get one Note
     * const note = await prisma.note.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends noteFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, noteFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__noteClient<note>, Prisma__noteClient<noteGetPayload<T>>>

    /**
     * Find the first Note that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {noteFindFirstOrThrowArgs} args - Arguments to find a Note
     * @example
     * // Get one Note
     * const note = await prisma.note.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends noteFindFirstOrThrowArgs>(
      args?: SelectSubset<T, noteFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__noteClient<note>, Prisma__noteClient<noteGetPayload<T>>>

    /**
     * Count the number of Notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {noteCountArgs} args - Arguments to filter Notes to count.
     * @example
     * // Count the number of Notes
     * const count = await prisma.note.count({
     *   where: {
     *     // ... the filter for the Notes we want to count
     *   }
     * })
    **/
    count<T extends noteCountArgs>(
      args?: Subset<T, noteCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Note.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NoteAggregateArgs>(args: Subset<T, NoteAggregateArgs>): PrismaPromise<GetNoteAggregateType<T>>

    /**
     * Group by Note.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NoteGroupByArgs['orderBy'] }
        : { orderBy?: NoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNoteGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for note.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__noteClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    form<T extends formArgs = {}>(args?: Subset<T, formArgs>): CheckSelect<T, Prisma__formClient<form | null >, Prisma__formClient<formGetPayload<T> | null >>;

    subject<T extends subjectArgs = {}>(args?: Subset<T, subjectArgs>): CheckSelect<T, Prisma__subjectClient<subject | null >, Prisma__subjectClient<subjectGetPayload<T> | null >>;

    topic<T extends topicArgs = {}>(args?: Subset<T, topicArgs>): CheckSelect<T, Prisma__topicClient<topic | null >, Prisma__topicClient<topicGetPayload<T> | null >>;

    users<T extends usersArgs = {}>(args?: Subset<T, usersArgs>): CheckSelect<T, Prisma__usersClient<users | null >, Prisma__usersClient<usersGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * note base type for findUnique actions
   */
  export type noteFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the note
     * 
    **/
    select?: noteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: noteInclude | null
    /**
     * Filter, which note to fetch.
     * 
    **/
    where: noteWhereUniqueInput
  }

  /**
   * note: findUnique
   */
  export interface noteFindUniqueArgs extends noteFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * note base type for findFirst actions
   */
  export type noteFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the note
     * 
    **/
    select?: noteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: noteInclude | null
    /**
     * Filter, which note to fetch.
     * 
    **/
    where?: noteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notes to fetch.
     * 
    **/
    orderBy?: Enumerable<noteOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notes.
     * 
    **/
    cursor?: noteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notes.
     * 
    **/
    distinct?: Enumerable<NoteScalarFieldEnum>
  }

  /**
   * note: findFirst
   */
  export interface noteFindFirstArgs extends noteFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * note findMany
   */
  export type noteFindManyArgs = {
    /**
     * Select specific fields to fetch from the note
     * 
    **/
    select?: noteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: noteInclude | null
    /**
     * Filter, which notes to fetch.
     * 
    **/
    where?: noteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notes to fetch.
     * 
    **/
    orderBy?: Enumerable<noteOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing notes.
     * 
    **/
    cursor?: noteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<NoteScalarFieldEnum>
  }


  /**
   * note create
   */
  export type noteCreateArgs = {
    /**
     * Select specific fields to fetch from the note
     * 
    **/
    select?: noteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: noteInclude | null
    /**
     * The data needed to create a note.
     * 
    **/
    data: XOR<noteCreateInput, noteUncheckedCreateInput>
  }


  /**
   * note createMany
   */
  export type noteCreateManyArgs = {
    /**
     * The data used to create many notes.
     * 
    **/
    data: Enumerable<noteCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * note update
   */
  export type noteUpdateArgs = {
    /**
     * Select specific fields to fetch from the note
     * 
    **/
    select?: noteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: noteInclude | null
    /**
     * The data needed to update a note.
     * 
    **/
    data: XOR<noteUpdateInput, noteUncheckedUpdateInput>
    /**
     * Choose, which note to update.
     * 
    **/
    where: noteWhereUniqueInput
  }


  /**
   * note updateMany
   */
  export type noteUpdateManyArgs = {
    /**
     * The data used to update notes.
     * 
    **/
    data: XOR<noteUpdateManyMutationInput, noteUncheckedUpdateManyInput>
    /**
     * Filter which notes to update
     * 
    **/
    where?: noteWhereInput
  }


  /**
   * note upsert
   */
  export type noteUpsertArgs = {
    /**
     * Select specific fields to fetch from the note
     * 
    **/
    select?: noteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: noteInclude | null
    /**
     * The filter to search for the note to update in case it exists.
     * 
    **/
    where: noteWhereUniqueInput
    /**
     * In case the note found by the `where` argument doesn't exist, create a new note with this data.
     * 
    **/
    create: XOR<noteCreateInput, noteUncheckedCreateInput>
    /**
     * In case the note was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<noteUpdateInput, noteUncheckedUpdateInput>
  }


  /**
   * note delete
   */
  export type noteDeleteArgs = {
    /**
     * Select specific fields to fetch from the note
     * 
    **/
    select?: noteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: noteInclude | null
    /**
     * Filter which note to delete.
     * 
    **/
    where: noteWhereUniqueInput
  }


  /**
   * note deleteMany
   */
  export type noteDeleteManyArgs = {
    /**
     * Filter which notes to delete
     * 
    **/
    where?: noteWhereInput
  }


  /**
   * note: findUniqueOrThrow
   */
  export type noteFindUniqueOrThrowArgs = noteFindUniqueArgsBase
      

  /**
   * note: findFirstOrThrow
   */
  export type noteFindFirstOrThrowArgs = noteFindFirstArgsBase
      

  /**
   * note without action
   */
  export type noteArgs = {
    /**
     * Select specific fields to fetch from the note
     * 
    **/
    select?: noteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: noteInclude | null
  }



  /**
   * Model notesDownloadable
   */


  export type AggregateNotesDownloadable = {
    _count: NotesDownloadableCountAggregateOutputType | null
    _avg: NotesDownloadableAvgAggregateOutputType | null
    _sum: NotesDownloadableSumAggregateOutputType | null
    _min: NotesDownloadableMinAggregateOutputType | null
    _max: NotesDownloadableMaxAggregateOutputType | null
  }

  export type NotesDownloadableAvgAggregateOutputType = {
    id: number | null
    formId: number | null
    subjectId: number | null
    usersId: number | null
  }

  export type NotesDownloadableSumAggregateOutputType = {
    id: number | null
    formId: number | null
    subjectId: number | null
    usersId: number | null
  }

  export type NotesDownloadableMinAggregateOutputType = {
    id: number | null
    link: string | null
    fileExtension: string | null
    published: boolean | null
    formId: number | null
    subjectId: number | null
    usersId: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotesDownloadableMaxAggregateOutputType = {
    id: number | null
    link: string | null
    fileExtension: string | null
    published: boolean | null
    formId: number | null
    subjectId: number | null
    usersId: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotesDownloadableCountAggregateOutputType = {
    id: number
    link: number
    fileExtension: number
    published: number
    formId: number
    subjectId: number
    usersId: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotesDownloadableAvgAggregateInputType = {
    id?: true
    formId?: true
    subjectId?: true
    usersId?: true
  }

  export type NotesDownloadableSumAggregateInputType = {
    id?: true
    formId?: true
    subjectId?: true
    usersId?: true
  }

  export type NotesDownloadableMinAggregateInputType = {
    id?: true
    link?: true
    fileExtension?: true
    published?: true
    formId?: true
    subjectId?: true
    usersId?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotesDownloadableMaxAggregateInputType = {
    id?: true
    link?: true
    fileExtension?: true
    published?: true
    formId?: true
    subjectId?: true
    usersId?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotesDownloadableCountAggregateInputType = {
    id?: true
    link?: true
    fileExtension?: true
    published?: true
    formId?: true
    subjectId?: true
    usersId?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotesDownloadableAggregateArgs = {
    /**
     * Filter which notesDownloadable to aggregate.
     * 
    **/
    where?: notesDownloadableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notesDownloadables to fetch.
     * 
    **/
    orderBy?: Enumerable<notesDownloadableOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: notesDownloadableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notesDownloadables from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notesDownloadables.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned notesDownloadables
    **/
    _count?: true | NotesDownloadableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotesDownloadableAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotesDownloadableSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotesDownloadableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotesDownloadableMaxAggregateInputType
  }

  export type GetNotesDownloadableAggregateType<T extends NotesDownloadableAggregateArgs> = {
        [P in keyof T & keyof AggregateNotesDownloadable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotesDownloadable[P]>
      : GetScalarType<T[P], AggregateNotesDownloadable[P]>
  }




  export type NotesDownloadableGroupByArgs = {
    where?: notesDownloadableWhereInput
    orderBy?: Enumerable<notesDownloadableOrderByWithAggregationInput>
    by: Array<NotesDownloadableScalarFieldEnum>
    having?: notesDownloadableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotesDownloadableCountAggregateInputType | true
    _avg?: NotesDownloadableAvgAggregateInputType
    _sum?: NotesDownloadableSumAggregateInputType
    _min?: NotesDownloadableMinAggregateInputType
    _max?: NotesDownloadableMaxAggregateInputType
  }


  export type NotesDownloadableGroupByOutputType = {
    id: number
    link: string
    fileExtension: string
    published: boolean
    formId: number
    subjectId: number
    usersId: number
    name: string
    createdAt: Date
    updatedAt: Date
    _count: NotesDownloadableCountAggregateOutputType | null
    _avg: NotesDownloadableAvgAggregateOutputType | null
    _sum: NotesDownloadableSumAggregateOutputType | null
    _min: NotesDownloadableMinAggregateOutputType | null
    _max: NotesDownloadableMaxAggregateOutputType | null
  }

  type GetNotesDownloadableGroupByPayload<T extends NotesDownloadableGroupByArgs> = PrismaPromise<
    Array<
      PickArray<NotesDownloadableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotesDownloadableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotesDownloadableGroupByOutputType[P]>
            : GetScalarType<T[P], NotesDownloadableGroupByOutputType[P]>
        }
      >
    >


  export type notesDownloadableSelect = {
    id?: boolean
    link?: boolean
    fileExtension?: boolean
    published?: boolean
    formId?: boolean
    subjectId?: boolean
    usersId?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    form?: boolean | formArgs
    subject?: boolean | subjectArgs
    users?: boolean | usersArgs
  }

  export type notesDownloadableInclude = {
    form?: boolean | formArgs
    subject?: boolean | subjectArgs
    users?: boolean | usersArgs
  }

  export type notesDownloadableGetPayload<
    S extends boolean | null | undefined | notesDownloadableArgs,
    U = keyof S
      > = S extends true
        ? notesDownloadable
    : S extends undefined
    ? never
    : S extends notesDownloadableArgs | notesDownloadableFindManyArgs
    ?'include' extends U
    ? notesDownloadable  & {
    [P in TrueKeys<S['include']>]:
        P extends 'form' ? formGetPayload<S['include'][P]> :
        P extends 'subject' ? subjectGetPayload<S['include'][P]> :
        P extends 'users' ? usersGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'form' ? formGetPayload<S['select'][P]> :
        P extends 'subject' ? subjectGetPayload<S['select'][P]> :
        P extends 'users' ? usersGetPayload<S['select'][P]> :  P extends keyof notesDownloadable ? notesDownloadable[P] : never
  } 
    : notesDownloadable
  : notesDownloadable


  type notesDownloadableCountArgs = Merge<
    Omit<notesDownloadableFindManyArgs, 'select' | 'include'> & {
      select?: NotesDownloadableCountAggregateInputType | true
    }
  >

  export interface notesDownloadableDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one NotesDownloadable that matches the filter.
     * @param {notesDownloadableFindUniqueArgs} args - Arguments to find a NotesDownloadable
     * @example
     * // Get one NotesDownloadable
     * const notesDownloadable = await prisma.notesDownloadable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends notesDownloadableFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, notesDownloadableFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'notesDownloadable'> extends True ? CheckSelect<T, Prisma__notesDownloadableClient<notesDownloadable>, Prisma__notesDownloadableClient<notesDownloadableGetPayload<T>>> : CheckSelect<T, Prisma__notesDownloadableClient<notesDownloadable | null >, Prisma__notesDownloadableClient<notesDownloadableGetPayload<T> | null >>

    /**
     * Find the first NotesDownloadable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notesDownloadableFindFirstArgs} args - Arguments to find a NotesDownloadable
     * @example
     * // Get one NotesDownloadable
     * const notesDownloadable = await prisma.notesDownloadable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends notesDownloadableFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, notesDownloadableFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'notesDownloadable'> extends True ? CheckSelect<T, Prisma__notesDownloadableClient<notesDownloadable>, Prisma__notesDownloadableClient<notesDownloadableGetPayload<T>>> : CheckSelect<T, Prisma__notesDownloadableClient<notesDownloadable | null >, Prisma__notesDownloadableClient<notesDownloadableGetPayload<T> | null >>

    /**
     * Find zero or more NotesDownloadables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notesDownloadableFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotesDownloadables
     * const notesDownloadables = await prisma.notesDownloadable.findMany()
     * 
     * // Get first 10 NotesDownloadables
     * const notesDownloadables = await prisma.notesDownloadable.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notesDownloadableWithIdOnly = await prisma.notesDownloadable.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends notesDownloadableFindManyArgs>(
      args?: SelectSubset<T, notesDownloadableFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<notesDownloadable>>, PrismaPromise<Array<notesDownloadableGetPayload<T>>>>

    /**
     * Create a NotesDownloadable.
     * @param {notesDownloadableCreateArgs} args - Arguments to create a NotesDownloadable.
     * @example
     * // Create one NotesDownloadable
     * const NotesDownloadable = await prisma.notesDownloadable.create({
     *   data: {
     *     // ... data to create a NotesDownloadable
     *   }
     * })
     * 
    **/
    create<T extends notesDownloadableCreateArgs>(
      args: SelectSubset<T, notesDownloadableCreateArgs>
    ): CheckSelect<T, Prisma__notesDownloadableClient<notesDownloadable>, Prisma__notesDownloadableClient<notesDownloadableGetPayload<T>>>

    /**
     * Create many NotesDownloadables.
     *     @param {notesDownloadableCreateManyArgs} args - Arguments to create many NotesDownloadables.
     *     @example
     *     // Create many NotesDownloadables
     *     const notesDownloadable = await prisma.notesDownloadable.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends notesDownloadableCreateManyArgs>(
      args?: SelectSubset<T, notesDownloadableCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a NotesDownloadable.
     * @param {notesDownloadableDeleteArgs} args - Arguments to delete one NotesDownloadable.
     * @example
     * // Delete one NotesDownloadable
     * const NotesDownloadable = await prisma.notesDownloadable.delete({
     *   where: {
     *     // ... filter to delete one NotesDownloadable
     *   }
     * })
     * 
    **/
    delete<T extends notesDownloadableDeleteArgs>(
      args: SelectSubset<T, notesDownloadableDeleteArgs>
    ): CheckSelect<T, Prisma__notesDownloadableClient<notesDownloadable>, Prisma__notesDownloadableClient<notesDownloadableGetPayload<T>>>

    /**
     * Update one NotesDownloadable.
     * @param {notesDownloadableUpdateArgs} args - Arguments to update one NotesDownloadable.
     * @example
     * // Update one NotesDownloadable
     * const notesDownloadable = await prisma.notesDownloadable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends notesDownloadableUpdateArgs>(
      args: SelectSubset<T, notesDownloadableUpdateArgs>
    ): CheckSelect<T, Prisma__notesDownloadableClient<notesDownloadable>, Prisma__notesDownloadableClient<notesDownloadableGetPayload<T>>>

    /**
     * Delete zero or more NotesDownloadables.
     * @param {notesDownloadableDeleteManyArgs} args - Arguments to filter NotesDownloadables to delete.
     * @example
     * // Delete a few NotesDownloadables
     * const { count } = await prisma.notesDownloadable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends notesDownloadableDeleteManyArgs>(
      args?: SelectSubset<T, notesDownloadableDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotesDownloadables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notesDownloadableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotesDownloadables
     * const notesDownloadable = await prisma.notesDownloadable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends notesDownloadableUpdateManyArgs>(
      args: SelectSubset<T, notesDownloadableUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one NotesDownloadable.
     * @param {notesDownloadableUpsertArgs} args - Arguments to update or create a NotesDownloadable.
     * @example
     * // Update or create a NotesDownloadable
     * const notesDownloadable = await prisma.notesDownloadable.upsert({
     *   create: {
     *     // ... data to create a NotesDownloadable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotesDownloadable we want to update
     *   }
     * })
    **/
    upsert<T extends notesDownloadableUpsertArgs>(
      args: SelectSubset<T, notesDownloadableUpsertArgs>
    ): CheckSelect<T, Prisma__notesDownloadableClient<notesDownloadable>, Prisma__notesDownloadableClient<notesDownloadableGetPayload<T>>>

    /**
     * Find one NotesDownloadable that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {notesDownloadableFindUniqueOrThrowArgs} args - Arguments to find a NotesDownloadable
     * @example
     * // Get one NotesDownloadable
     * const notesDownloadable = await prisma.notesDownloadable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends notesDownloadableFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, notesDownloadableFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__notesDownloadableClient<notesDownloadable>, Prisma__notesDownloadableClient<notesDownloadableGetPayload<T>>>

    /**
     * Find the first NotesDownloadable that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notesDownloadableFindFirstOrThrowArgs} args - Arguments to find a NotesDownloadable
     * @example
     * // Get one NotesDownloadable
     * const notesDownloadable = await prisma.notesDownloadable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends notesDownloadableFindFirstOrThrowArgs>(
      args?: SelectSubset<T, notesDownloadableFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__notesDownloadableClient<notesDownloadable>, Prisma__notesDownloadableClient<notesDownloadableGetPayload<T>>>

    /**
     * Count the number of NotesDownloadables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notesDownloadableCountArgs} args - Arguments to filter NotesDownloadables to count.
     * @example
     * // Count the number of NotesDownloadables
     * const count = await prisma.notesDownloadable.count({
     *   where: {
     *     // ... the filter for the NotesDownloadables we want to count
     *   }
     * })
    **/
    count<T extends notesDownloadableCountArgs>(
      args?: Subset<T, notesDownloadableCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotesDownloadableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotesDownloadable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotesDownloadableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotesDownloadableAggregateArgs>(args: Subset<T, NotesDownloadableAggregateArgs>): PrismaPromise<GetNotesDownloadableAggregateType<T>>

    /**
     * Group by NotesDownloadable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotesDownloadableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotesDownloadableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotesDownloadableGroupByArgs['orderBy'] }
        : { orderBy?: NotesDownloadableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotesDownloadableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotesDownloadableGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for notesDownloadable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__notesDownloadableClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    form<T extends formArgs = {}>(args?: Subset<T, formArgs>): CheckSelect<T, Prisma__formClient<form | null >, Prisma__formClient<formGetPayload<T> | null >>;

    subject<T extends subjectArgs = {}>(args?: Subset<T, subjectArgs>): CheckSelect<T, Prisma__subjectClient<subject | null >, Prisma__subjectClient<subjectGetPayload<T> | null >>;

    users<T extends usersArgs = {}>(args?: Subset<T, usersArgs>): CheckSelect<T, Prisma__usersClient<users | null >, Prisma__usersClient<usersGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * notesDownloadable base type for findUnique actions
   */
  export type notesDownloadableFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the notesDownloadable
     * 
    **/
    select?: notesDownloadableSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: notesDownloadableInclude | null
    /**
     * Filter, which notesDownloadable to fetch.
     * 
    **/
    where: notesDownloadableWhereUniqueInput
  }

  /**
   * notesDownloadable: findUnique
   */
  export interface notesDownloadableFindUniqueArgs extends notesDownloadableFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * notesDownloadable base type for findFirst actions
   */
  export type notesDownloadableFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the notesDownloadable
     * 
    **/
    select?: notesDownloadableSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: notesDownloadableInclude | null
    /**
     * Filter, which notesDownloadable to fetch.
     * 
    **/
    where?: notesDownloadableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notesDownloadables to fetch.
     * 
    **/
    orderBy?: Enumerable<notesDownloadableOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notesDownloadables.
     * 
    **/
    cursor?: notesDownloadableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notesDownloadables from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notesDownloadables.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notesDownloadables.
     * 
    **/
    distinct?: Enumerable<NotesDownloadableScalarFieldEnum>
  }

  /**
   * notesDownloadable: findFirst
   */
  export interface notesDownloadableFindFirstArgs extends notesDownloadableFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * notesDownloadable findMany
   */
  export type notesDownloadableFindManyArgs = {
    /**
     * Select specific fields to fetch from the notesDownloadable
     * 
    **/
    select?: notesDownloadableSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: notesDownloadableInclude | null
    /**
     * Filter, which notesDownloadables to fetch.
     * 
    **/
    where?: notesDownloadableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notesDownloadables to fetch.
     * 
    **/
    orderBy?: Enumerable<notesDownloadableOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing notesDownloadables.
     * 
    **/
    cursor?: notesDownloadableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notesDownloadables from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notesDownloadables.
     * 
    **/
    skip?: number
    distinct?: Enumerable<NotesDownloadableScalarFieldEnum>
  }


  /**
   * notesDownloadable create
   */
  export type notesDownloadableCreateArgs = {
    /**
     * Select specific fields to fetch from the notesDownloadable
     * 
    **/
    select?: notesDownloadableSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: notesDownloadableInclude | null
    /**
     * The data needed to create a notesDownloadable.
     * 
    **/
    data: XOR<notesDownloadableCreateInput, notesDownloadableUncheckedCreateInput>
  }


  /**
   * notesDownloadable createMany
   */
  export type notesDownloadableCreateManyArgs = {
    /**
     * The data used to create many notesDownloadables.
     * 
    **/
    data: Enumerable<notesDownloadableCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * notesDownloadable update
   */
  export type notesDownloadableUpdateArgs = {
    /**
     * Select specific fields to fetch from the notesDownloadable
     * 
    **/
    select?: notesDownloadableSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: notesDownloadableInclude | null
    /**
     * The data needed to update a notesDownloadable.
     * 
    **/
    data: XOR<notesDownloadableUpdateInput, notesDownloadableUncheckedUpdateInput>
    /**
     * Choose, which notesDownloadable to update.
     * 
    **/
    where: notesDownloadableWhereUniqueInput
  }


  /**
   * notesDownloadable updateMany
   */
  export type notesDownloadableUpdateManyArgs = {
    /**
     * The data used to update notesDownloadables.
     * 
    **/
    data: XOR<notesDownloadableUpdateManyMutationInput, notesDownloadableUncheckedUpdateManyInput>
    /**
     * Filter which notesDownloadables to update
     * 
    **/
    where?: notesDownloadableWhereInput
  }


  /**
   * notesDownloadable upsert
   */
  export type notesDownloadableUpsertArgs = {
    /**
     * Select specific fields to fetch from the notesDownloadable
     * 
    **/
    select?: notesDownloadableSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: notesDownloadableInclude | null
    /**
     * The filter to search for the notesDownloadable to update in case it exists.
     * 
    **/
    where: notesDownloadableWhereUniqueInput
    /**
     * In case the notesDownloadable found by the `where` argument doesn't exist, create a new notesDownloadable with this data.
     * 
    **/
    create: XOR<notesDownloadableCreateInput, notesDownloadableUncheckedCreateInput>
    /**
     * In case the notesDownloadable was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<notesDownloadableUpdateInput, notesDownloadableUncheckedUpdateInput>
  }


  /**
   * notesDownloadable delete
   */
  export type notesDownloadableDeleteArgs = {
    /**
     * Select specific fields to fetch from the notesDownloadable
     * 
    **/
    select?: notesDownloadableSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: notesDownloadableInclude | null
    /**
     * Filter which notesDownloadable to delete.
     * 
    **/
    where: notesDownloadableWhereUniqueInput
  }


  /**
   * notesDownloadable deleteMany
   */
  export type notesDownloadableDeleteManyArgs = {
    /**
     * Filter which notesDownloadables to delete
     * 
    **/
    where?: notesDownloadableWhereInput
  }


  /**
   * notesDownloadable: findUniqueOrThrow
   */
  export type notesDownloadableFindUniqueOrThrowArgs = notesDownloadableFindUniqueArgsBase
      

  /**
   * notesDownloadable: findFirstOrThrow
   */
  export type notesDownloadableFindFirstOrThrowArgs = notesDownloadableFindFirstArgsBase
      

  /**
   * notesDownloadable without action
   */
  export type notesDownloadableArgs = {
    /**
     * Select specific fields to fetch from the notesDownloadable
     * 
    **/
    select?: notesDownloadableSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: notesDownloadableInclude | null
  }



  /**
   * Model subjectReview
   */


  export type AggregateSubjectReview = {
    _count: SubjectReviewCountAggregateOutputType | null
    _avg: SubjectReviewAvgAggregateOutputType | null
    _sum: SubjectReviewSumAggregateOutputType | null
    _min: SubjectReviewMinAggregateOutputType | null
    _max: SubjectReviewMaxAggregateOutputType | null
  }

  export type SubjectReviewAvgAggregateOutputType = {
    id: number | null
    usersId: number | null
  }

  export type SubjectReviewSumAggregateOutputType = {
    id: number | null
    usersId: number | null
  }

  export type SubjectReviewMinAggregateOutputType = {
    id: number | null
    subjectName: string | null
    subjectDefinition: string | null
    imageLocation: string | null
    published: boolean | null
    usersId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubjectReviewMaxAggregateOutputType = {
    id: number | null
    subjectName: string | null
    subjectDefinition: string | null
    imageLocation: string | null
    published: boolean | null
    usersId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubjectReviewCountAggregateOutputType = {
    id: number
    subjectName: number
    subjectDefinition: number
    imageLocation: number
    published: number
    usersId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubjectReviewAvgAggregateInputType = {
    id?: true
    usersId?: true
  }

  export type SubjectReviewSumAggregateInputType = {
    id?: true
    usersId?: true
  }

  export type SubjectReviewMinAggregateInputType = {
    id?: true
    subjectName?: true
    subjectDefinition?: true
    imageLocation?: true
    published?: true
    usersId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubjectReviewMaxAggregateInputType = {
    id?: true
    subjectName?: true
    subjectDefinition?: true
    imageLocation?: true
    published?: true
    usersId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubjectReviewCountAggregateInputType = {
    id?: true
    subjectName?: true
    subjectDefinition?: true
    imageLocation?: true
    published?: true
    usersId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubjectReviewAggregateArgs = {
    /**
     * Filter which subjectReview to aggregate.
     * 
    **/
    where?: subjectReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subjectReviews to fetch.
     * 
    **/
    orderBy?: Enumerable<subjectReviewOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: subjectReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subjectReviews from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subjectReviews.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned subjectReviews
    **/
    _count?: true | SubjectReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubjectReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubjectReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubjectReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubjectReviewMaxAggregateInputType
  }

  export type GetSubjectReviewAggregateType<T extends SubjectReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateSubjectReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubjectReview[P]>
      : GetScalarType<T[P], AggregateSubjectReview[P]>
  }




  export type SubjectReviewGroupByArgs = {
    where?: subjectReviewWhereInput
    orderBy?: Enumerable<subjectReviewOrderByWithAggregationInput>
    by: Array<SubjectReviewScalarFieldEnum>
    having?: subjectReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubjectReviewCountAggregateInputType | true
    _avg?: SubjectReviewAvgAggregateInputType
    _sum?: SubjectReviewSumAggregateInputType
    _min?: SubjectReviewMinAggregateInputType
    _max?: SubjectReviewMaxAggregateInputType
  }


  export type SubjectReviewGroupByOutputType = {
    id: number
    subjectName: string
    subjectDefinition: string
    imageLocation: string | null
    published: boolean
    usersId: number
    createdAt: Date
    updatedAt: Date
    _count: SubjectReviewCountAggregateOutputType | null
    _avg: SubjectReviewAvgAggregateOutputType | null
    _sum: SubjectReviewSumAggregateOutputType | null
    _min: SubjectReviewMinAggregateOutputType | null
    _max: SubjectReviewMaxAggregateOutputType | null
  }

  type GetSubjectReviewGroupByPayload<T extends SubjectReviewGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SubjectReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubjectReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubjectReviewGroupByOutputType[P]>
            : GetScalarType<T[P], SubjectReviewGroupByOutputType[P]>
        }
      >
    >


  export type subjectReviewSelect = {
    id?: boolean
    subjectName?: boolean
    subjectDefinition?: boolean
    imageLocation?: boolean
    published?: boolean
    usersId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | usersArgs
    review?: boolean | reviewFindManyArgs
    topic?: boolean | topicReviewFindManyArgs
    forms?: boolean | formReviewFindManyArgs
    _count?: boolean | SubjectReviewCountOutputTypeArgs
  }

  export type subjectReviewInclude = {
    users?: boolean | usersArgs
    review?: boolean | reviewFindManyArgs
    topic?: boolean | topicReviewFindManyArgs
    forms?: boolean | formReviewFindManyArgs
    _count?: boolean | SubjectReviewCountOutputTypeArgs
  }

  export type subjectReviewGetPayload<
    S extends boolean | null | undefined | subjectReviewArgs,
    U = keyof S
      > = S extends true
        ? subjectReview
    : S extends undefined
    ? never
    : S extends subjectReviewArgs | subjectReviewFindManyArgs
    ?'include' extends U
    ? subjectReview  & {
    [P in TrueKeys<S['include']>]:
        P extends 'users' ? usersGetPayload<S['include'][P]> :
        P extends 'review' ? Array < reviewGetPayload<S['include'][P]>>  :
        P extends 'topic' ? Array < topicReviewGetPayload<S['include'][P]>>  :
        P extends 'forms' ? Array < formReviewGetPayload<S['include'][P]>>  :
        P extends '_count' ? SubjectReviewCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'users' ? usersGetPayload<S['select'][P]> :
        P extends 'review' ? Array < reviewGetPayload<S['select'][P]>>  :
        P extends 'topic' ? Array < topicReviewGetPayload<S['select'][P]>>  :
        P extends 'forms' ? Array < formReviewGetPayload<S['select'][P]>>  :
        P extends '_count' ? SubjectReviewCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof subjectReview ? subjectReview[P] : never
  } 
    : subjectReview
  : subjectReview


  type subjectReviewCountArgs = Merge<
    Omit<subjectReviewFindManyArgs, 'select' | 'include'> & {
      select?: SubjectReviewCountAggregateInputType | true
    }
  >

  export interface subjectReviewDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one SubjectReview that matches the filter.
     * @param {subjectReviewFindUniqueArgs} args - Arguments to find a SubjectReview
     * @example
     * // Get one SubjectReview
     * const subjectReview = await prisma.subjectReview.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends subjectReviewFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, subjectReviewFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'subjectReview'> extends True ? CheckSelect<T, Prisma__subjectReviewClient<subjectReview>, Prisma__subjectReviewClient<subjectReviewGetPayload<T>>> : CheckSelect<T, Prisma__subjectReviewClient<subjectReview | null >, Prisma__subjectReviewClient<subjectReviewGetPayload<T> | null >>

    /**
     * Find the first SubjectReview that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subjectReviewFindFirstArgs} args - Arguments to find a SubjectReview
     * @example
     * // Get one SubjectReview
     * const subjectReview = await prisma.subjectReview.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends subjectReviewFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, subjectReviewFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'subjectReview'> extends True ? CheckSelect<T, Prisma__subjectReviewClient<subjectReview>, Prisma__subjectReviewClient<subjectReviewGetPayload<T>>> : CheckSelect<T, Prisma__subjectReviewClient<subjectReview | null >, Prisma__subjectReviewClient<subjectReviewGetPayload<T> | null >>

    /**
     * Find zero or more SubjectReviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subjectReviewFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubjectReviews
     * const subjectReviews = await prisma.subjectReview.findMany()
     * 
     * // Get first 10 SubjectReviews
     * const subjectReviews = await prisma.subjectReview.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subjectReviewWithIdOnly = await prisma.subjectReview.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends subjectReviewFindManyArgs>(
      args?: SelectSubset<T, subjectReviewFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<subjectReview>>, PrismaPromise<Array<subjectReviewGetPayload<T>>>>

    /**
     * Create a SubjectReview.
     * @param {subjectReviewCreateArgs} args - Arguments to create a SubjectReview.
     * @example
     * // Create one SubjectReview
     * const SubjectReview = await prisma.subjectReview.create({
     *   data: {
     *     // ... data to create a SubjectReview
     *   }
     * })
     * 
    **/
    create<T extends subjectReviewCreateArgs>(
      args: SelectSubset<T, subjectReviewCreateArgs>
    ): CheckSelect<T, Prisma__subjectReviewClient<subjectReview>, Prisma__subjectReviewClient<subjectReviewGetPayload<T>>>

    /**
     * Create many SubjectReviews.
     *     @param {subjectReviewCreateManyArgs} args - Arguments to create many SubjectReviews.
     *     @example
     *     // Create many SubjectReviews
     *     const subjectReview = await prisma.subjectReview.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends subjectReviewCreateManyArgs>(
      args?: SelectSubset<T, subjectReviewCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a SubjectReview.
     * @param {subjectReviewDeleteArgs} args - Arguments to delete one SubjectReview.
     * @example
     * // Delete one SubjectReview
     * const SubjectReview = await prisma.subjectReview.delete({
     *   where: {
     *     // ... filter to delete one SubjectReview
     *   }
     * })
     * 
    **/
    delete<T extends subjectReviewDeleteArgs>(
      args: SelectSubset<T, subjectReviewDeleteArgs>
    ): CheckSelect<T, Prisma__subjectReviewClient<subjectReview>, Prisma__subjectReviewClient<subjectReviewGetPayload<T>>>

    /**
     * Update one SubjectReview.
     * @param {subjectReviewUpdateArgs} args - Arguments to update one SubjectReview.
     * @example
     * // Update one SubjectReview
     * const subjectReview = await prisma.subjectReview.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends subjectReviewUpdateArgs>(
      args: SelectSubset<T, subjectReviewUpdateArgs>
    ): CheckSelect<T, Prisma__subjectReviewClient<subjectReview>, Prisma__subjectReviewClient<subjectReviewGetPayload<T>>>

    /**
     * Delete zero or more SubjectReviews.
     * @param {subjectReviewDeleteManyArgs} args - Arguments to filter SubjectReviews to delete.
     * @example
     * // Delete a few SubjectReviews
     * const { count } = await prisma.subjectReview.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends subjectReviewDeleteManyArgs>(
      args?: SelectSubset<T, subjectReviewDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubjectReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subjectReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubjectReviews
     * const subjectReview = await prisma.subjectReview.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends subjectReviewUpdateManyArgs>(
      args: SelectSubset<T, subjectReviewUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one SubjectReview.
     * @param {subjectReviewUpsertArgs} args - Arguments to update or create a SubjectReview.
     * @example
     * // Update or create a SubjectReview
     * const subjectReview = await prisma.subjectReview.upsert({
     *   create: {
     *     // ... data to create a SubjectReview
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubjectReview we want to update
     *   }
     * })
    **/
    upsert<T extends subjectReviewUpsertArgs>(
      args: SelectSubset<T, subjectReviewUpsertArgs>
    ): CheckSelect<T, Prisma__subjectReviewClient<subjectReview>, Prisma__subjectReviewClient<subjectReviewGetPayload<T>>>

    /**
     * Find one SubjectReview that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {subjectReviewFindUniqueOrThrowArgs} args - Arguments to find a SubjectReview
     * @example
     * // Get one SubjectReview
     * const subjectReview = await prisma.subjectReview.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends subjectReviewFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, subjectReviewFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__subjectReviewClient<subjectReview>, Prisma__subjectReviewClient<subjectReviewGetPayload<T>>>

    /**
     * Find the first SubjectReview that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subjectReviewFindFirstOrThrowArgs} args - Arguments to find a SubjectReview
     * @example
     * // Get one SubjectReview
     * const subjectReview = await prisma.subjectReview.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends subjectReviewFindFirstOrThrowArgs>(
      args?: SelectSubset<T, subjectReviewFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__subjectReviewClient<subjectReview>, Prisma__subjectReviewClient<subjectReviewGetPayload<T>>>

    /**
     * Count the number of SubjectReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subjectReviewCountArgs} args - Arguments to filter SubjectReviews to count.
     * @example
     * // Count the number of SubjectReviews
     * const count = await prisma.subjectReview.count({
     *   where: {
     *     // ... the filter for the SubjectReviews we want to count
     *   }
     * })
    **/
    count<T extends subjectReviewCountArgs>(
      args?: Subset<T, subjectReviewCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubjectReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubjectReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubjectReviewAggregateArgs>(args: Subset<T, SubjectReviewAggregateArgs>): PrismaPromise<GetSubjectReviewAggregateType<T>>

    /**
     * Group by SubjectReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubjectReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubjectReviewGroupByArgs['orderBy'] }
        : { orderBy?: SubjectReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubjectReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubjectReviewGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for subjectReview.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__subjectReviewClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    users<T extends usersArgs = {}>(args?: Subset<T, usersArgs>): CheckSelect<T, Prisma__usersClient<users | null >, Prisma__usersClient<usersGetPayload<T> | null >>;

    review<T extends reviewFindManyArgs = {}>(args?: Subset<T, reviewFindManyArgs>): CheckSelect<T, PrismaPromise<Array<review>>, PrismaPromise<Array<reviewGetPayload<T>>>>;

    topic<T extends topicReviewFindManyArgs = {}>(args?: Subset<T, topicReviewFindManyArgs>): CheckSelect<T, PrismaPromise<Array<topicReview>>, PrismaPromise<Array<topicReviewGetPayload<T>>>>;

    forms<T extends formReviewFindManyArgs = {}>(args?: Subset<T, formReviewFindManyArgs>): CheckSelect<T, PrismaPromise<Array<formReview>>, PrismaPromise<Array<formReviewGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * subjectReview base type for findUnique actions
   */
  export type subjectReviewFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the subjectReview
     * 
    **/
    select?: subjectReviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: subjectReviewInclude | null
    /**
     * Filter, which subjectReview to fetch.
     * 
    **/
    where: subjectReviewWhereUniqueInput
  }

  /**
   * subjectReview: findUnique
   */
  export interface subjectReviewFindUniqueArgs extends subjectReviewFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * subjectReview base type for findFirst actions
   */
  export type subjectReviewFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the subjectReview
     * 
    **/
    select?: subjectReviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: subjectReviewInclude | null
    /**
     * Filter, which subjectReview to fetch.
     * 
    **/
    where?: subjectReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subjectReviews to fetch.
     * 
    **/
    orderBy?: Enumerable<subjectReviewOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for subjectReviews.
     * 
    **/
    cursor?: subjectReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subjectReviews from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subjectReviews.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of subjectReviews.
     * 
    **/
    distinct?: Enumerable<SubjectReviewScalarFieldEnum>
  }

  /**
   * subjectReview: findFirst
   */
  export interface subjectReviewFindFirstArgs extends subjectReviewFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * subjectReview findMany
   */
  export type subjectReviewFindManyArgs = {
    /**
     * Select specific fields to fetch from the subjectReview
     * 
    **/
    select?: subjectReviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: subjectReviewInclude | null
    /**
     * Filter, which subjectReviews to fetch.
     * 
    **/
    where?: subjectReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subjectReviews to fetch.
     * 
    **/
    orderBy?: Enumerable<subjectReviewOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing subjectReviews.
     * 
    **/
    cursor?: subjectReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subjectReviews from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subjectReviews.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SubjectReviewScalarFieldEnum>
  }


  /**
   * subjectReview create
   */
  export type subjectReviewCreateArgs = {
    /**
     * Select specific fields to fetch from the subjectReview
     * 
    **/
    select?: subjectReviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: subjectReviewInclude | null
    /**
     * The data needed to create a subjectReview.
     * 
    **/
    data: XOR<subjectReviewCreateInput, subjectReviewUncheckedCreateInput>
  }


  /**
   * subjectReview createMany
   */
  export type subjectReviewCreateManyArgs = {
    /**
     * The data used to create many subjectReviews.
     * 
    **/
    data: Enumerable<subjectReviewCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * subjectReview update
   */
  export type subjectReviewUpdateArgs = {
    /**
     * Select specific fields to fetch from the subjectReview
     * 
    **/
    select?: subjectReviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: subjectReviewInclude | null
    /**
     * The data needed to update a subjectReview.
     * 
    **/
    data: XOR<subjectReviewUpdateInput, subjectReviewUncheckedUpdateInput>
    /**
     * Choose, which subjectReview to update.
     * 
    **/
    where: subjectReviewWhereUniqueInput
  }


  /**
   * subjectReview updateMany
   */
  export type subjectReviewUpdateManyArgs = {
    /**
     * The data used to update subjectReviews.
     * 
    **/
    data: XOR<subjectReviewUpdateManyMutationInput, subjectReviewUncheckedUpdateManyInput>
    /**
     * Filter which subjectReviews to update
     * 
    **/
    where?: subjectReviewWhereInput
  }


  /**
   * subjectReview upsert
   */
  export type subjectReviewUpsertArgs = {
    /**
     * Select specific fields to fetch from the subjectReview
     * 
    **/
    select?: subjectReviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: subjectReviewInclude | null
    /**
     * The filter to search for the subjectReview to update in case it exists.
     * 
    **/
    where: subjectReviewWhereUniqueInput
    /**
     * In case the subjectReview found by the `where` argument doesn't exist, create a new subjectReview with this data.
     * 
    **/
    create: XOR<subjectReviewCreateInput, subjectReviewUncheckedCreateInput>
    /**
     * In case the subjectReview was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<subjectReviewUpdateInput, subjectReviewUncheckedUpdateInput>
  }


  /**
   * subjectReview delete
   */
  export type subjectReviewDeleteArgs = {
    /**
     * Select specific fields to fetch from the subjectReview
     * 
    **/
    select?: subjectReviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: subjectReviewInclude | null
    /**
     * Filter which subjectReview to delete.
     * 
    **/
    where: subjectReviewWhereUniqueInput
  }


  /**
   * subjectReview deleteMany
   */
  export type subjectReviewDeleteManyArgs = {
    /**
     * Filter which subjectReviews to delete
     * 
    **/
    where?: subjectReviewWhereInput
  }


  /**
   * subjectReview: findUniqueOrThrow
   */
  export type subjectReviewFindUniqueOrThrowArgs = subjectReviewFindUniqueArgsBase
      

  /**
   * subjectReview: findFirstOrThrow
   */
  export type subjectReviewFindFirstOrThrowArgs = subjectReviewFindFirstArgsBase
      

  /**
   * subjectReview without action
   */
  export type subjectReviewArgs = {
    /**
     * Select specific fields to fetch from the subjectReview
     * 
    **/
    select?: subjectReviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: subjectReviewInclude | null
  }



  /**
   * Model formReview
   */


  export type AggregateFormReview = {
    _count: FormReviewCountAggregateOutputType | null
    _avg: FormReviewAvgAggregateOutputType | null
    _sum: FormReviewSumAggregateOutputType | null
    _min: FormReviewMinAggregateOutputType | null
    _max: FormReviewMaxAggregateOutputType | null
  }

  export type FormReviewAvgAggregateOutputType = {
    id: number | null
    usersId: number | null
  }

  export type FormReviewSumAggregateOutputType = {
    id: number | null
    usersId: number | null
  }

  export type FormReviewMinAggregateOutputType = {
    id: number | null
    formName: string | null
    usersId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FormReviewMaxAggregateOutputType = {
    id: number | null
    formName: string | null
    usersId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FormReviewCountAggregateOutputType = {
    id: number
    formName: number
    usersId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FormReviewAvgAggregateInputType = {
    id?: true
    usersId?: true
  }

  export type FormReviewSumAggregateInputType = {
    id?: true
    usersId?: true
  }

  export type FormReviewMinAggregateInputType = {
    id?: true
    formName?: true
    usersId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FormReviewMaxAggregateInputType = {
    id?: true
    formName?: true
    usersId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FormReviewCountAggregateInputType = {
    id?: true
    formName?: true
    usersId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FormReviewAggregateArgs = {
    /**
     * Filter which formReview to aggregate.
     * 
    **/
    where?: formReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of formReviews to fetch.
     * 
    **/
    orderBy?: Enumerable<formReviewOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: formReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` formReviews from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` formReviews.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned formReviews
    **/
    _count?: true | FormReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FormReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FormReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FormReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FormReviewMaxAggregateInputType
  }

  export type GetFormReviewAggregateType<T extends FormReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateFormReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFormReview[P]>
      : GetScalarType<T[P], AggregateFormReview[P]>
  }




  export type FormReviewGroupByArgs = {
    where?: formReviewWhereInput
    orderBy?: Enumerable<formReviewOrderByWithAggregationInput>
    by: Array<FormReviewScalarFieldEnum>
    having?: formReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FormReviewCountAggregateInputType | true
    _avg?: FormReviewAvgAggregateInputType
    _sum?: FormReviewSumAggregateInputType
    _min?: FormReviewMinAggregateInputType
    _max?: FormReviewMaxAggregateInputType
  }


  export type FormReviewGroupByOutputType = {
    id: number
    formName: string
    usersId: number
    createdAt: Date
    updatedAt: Date
    _count: FormReviewCountAggregateOutputType | null
    _avg: FormReviewAvgAggregateOutputType | null
    _sum: FormReviewSumAggregateOutputType | null
    _min: FormReviewMinAggregateOutputType | null
    _max: FormReviewMaxAggregateOutputType | null
  }

  type GetFormReviewGroupByPayload<T extends FormReviewGroupByArgs> = PrismaPromise<
    Array<
      PickArray<FormReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FormReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FormReviewGroupByOutputType[P]>
            : GetScalarType<T[P], FormReviewGroupByOutputType[P]>
        }
      >
    >


  export type formReviewSelect = {
    id?: boolean
    formName?: boolean
    usersId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | usersArgs
    review?: boolean | reviewFindManyArgs
    topic?: boolean | topicReviewFindManyArgs
    subjects?: boolean | subjectReviewFindManyArgs
    _count?: boolean | FormReviewCountOutputTypeArgs
  }

  export type formReviewInclude = {
    users?: boolean | usersArgs
    review?: boolean | reviewFindManyArgs
    topic?: boolean | topicReviewFindManyArgs
    subjects?: boolean | subjectReviewFindManyArgs
    _count?: boolean | FormReviewCountOutputTypeArgs
  }

  export type formReviewGetPayload<
    S extends boolean | null | undefined | formReviewArgs,
    U = keyof S
      > = S extends true
        ? formReview
    : S extends undefined
    ? never
    : S extends formReviewArgs | formReviewFindManyArgs
    ?'include' extends U
    ? formReview  & {
    [P in TrueKeys<S['include']>]:
        P extends 'users' ? usersGetPayload<S['include'][P]> :
        P extends 'review' ? Array < reviewGetPayload<S['include'][P]>>  :
        P extends 'topic' ? Array < topicReviewGetPayload<S['include'][P]>>  :
        P extends 'subjects' ? Array < subjectReviewGetPayload<S['include'][P]>>  :
        P extends '_count' ? FormReviewCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'users' ? usersGetPayload<S['select'][P]> :
        P extends 'review' ? Array < reviewGetPayload<S['select'][P]>>  :
        P extends 'topic' ? Array < topicReviewGetPayload<S['select'][P]>>  :
        P extends 'subjects' ? Array < subjectReviewGetPayload<S['select'][P]>>  :
        P extends '_count' ? FormReviewCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof formReview ? formReview[P] : never
  } 
    : formReview
  : formReview


  type formReviewCountArgs = Merge<
    Omit<formReviewFindManyArgs, 'select' | 'include'> & {
      select?: FormReviewCountAggregateInputType | true
    }
  >

  export interface formReviewDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one FormReview that matches the filter.
     * @param {formReviewFindUniqueArgs} args - Arguments to find a FormReview
     * @example
     * // Get one FormReview
     * const formReview = await prisma.formReview.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends formReviewFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, formReviewFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'formReview'> extends True ? CheckSelect<T, Prisma__formReviewClient<formReview>, Prisma__formReviewClient<formReviewGetPayload<T>>> : CheckSelect<T, Prisma__formReviewClient<formReview | null >, Prisma__formReviewClient<formReviewGetPayload<T> | null >>

    /**
     * Find the first FormReview that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formReviewFindFirstArgs} args - Arguments to find a FormReview
     * @example
     * // Get one FormReview
     * const formReview = await prisma.formReview.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends formReviewFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, formReviewFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'formReview'> extends True ? CheckSelect<T, Prisma__formReviewClient<formReview>, Prisma__formReviewClient<formReviewGetPayload<T>>> : CheckSelect<T, Prisma__formReviewClient<formReview | null >, Prisma__formReviewClient<formReviewGetPayload<T> | null >>

    /**
     * Find zero or more FormReviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formReviewFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FormReviews
     * const formReviews = await prisma.formReview.findMany()
     * 
     * // Get first 10 FormReviews
     * const formReviews = await prisma.formReview.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const formReviewWithIdOnly = await prisma.formReview.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends formReviewFindManyArgs>(
      args?: SelectSubset<T, formReviewFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<formReview>>, PrismaPromise<Array<formReviewGetPayload<T>>>>

    /**
     * Create a FormReview.
     * @param {formReviewCreateArgs} args - Arguments to create a FormReview.
     * @example
     * // Create one FormReview
     * const FormReview = await prisma.formReview.create({
     *   data: {
     *     // ... data to create a FormReview
     *   }
     * })
     * 
    **/
    create<T extends formReviewCreateArgs>(
      args: SelectSubset<T, formReviewCreateArgs>
    ): CheckSelect<T, Prisma__formReviewClient<formReview>, Prisma__formReviewClient<formReviewGetPayload<T>>>

    /**
     * Create many FormReviews.
     *     @param {formReviewCreateManyArgs} args - Arguments to create many FormReviews.
     *     @example
     *     // Create many FormReviews
     *     const formReview = await prisma.formReview.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends formReviewCreateManyArgs>(
      args?: SelectSubset<T, formReviewCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a FormReview.
     * @param {formReviewDeleteArgs} args - Arguments to delete one FormReview.
     * @example
     * // Delete one FormReview
     * const FormReview = await prisma.formReview.delete({
     *   where: {
     *     // ... filter to delete one FormReview
     *   }
     * })
     * 
    **/
    delete<T extends formReviewDeleteArgs>(
      args: SelectSubset<T, formReviewDeleteArgs>
    ): CheckSelect<T, Prisma__formReviewClient<formReview>, Prisma__formReviewClient<formReviewGetPayload<T>>>

    /**
     * Update one FormReview.
     * @param {formReviewUpdateArgs} args - Arguments to update one FormReview.
     * @example
     * // Update one FormReview
     * const formReview = await prisma.formReview.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends formReviewUpdateArgs>(
      args: SelectSubset<T, formReviewUpdateArgs>
    ): CheckSelect<T, Prisma__formReviewClient<formReview>, Prisma__formReviewClient<formReviewGetPayload<T>>>

    /**
     * Delete zero or more FormReviews.
     * @param {formReviewDeleteManyArgs} args - Arguments to filter FormReviews to delete.
     * @example
     * // Delete a few FormReviews
     * const { count } = await prisma.formReview.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends formReviewDeleteManyArgs>(
      args?: SelectSubset<T, formReviewDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more FormReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FormReviews
     * const formReview = await prisma.formReview.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends formReviewUpdateManyArgs>(
      args: SelectSubset<T, formReviewUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one FormReview.
     * @param {formReviewUpsertArgs} args - Arguments to update or create a FormReview.
     * @example
     * // Update or create a FormReview
     * const formReview = await prisma.formReview.upsert({
     *   create: {
     *     // ... data to create a FormReview
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FormReview we want to update
     *   }
     * })
    **/
    upsert<T extends formReviewUpsertArgs>(
      args: SelectSubset<T, formReviewUpsertArgs>
    ): CheckSelect<T, Prisma__formReviewClient<formReview>, Prisma__formReviewClient<formReviewGetPayload<T>>>

    /**
     * Find one FormReview that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {formReviewFindUniqueOrThrowArgs} args - Arguments to find a FormReview
     * @example
     * // Get one FormReview
     * const formReview = await prisma.formReview.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends formReviewFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, formReviewFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__formReviewClient<formReview>, Prisma__formReviewClient<formReviewGetPayload<T>>>

    /**
     * Find the first FormReview that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formReviewFindFirstOrThrowArgs} args - Arguments to find a FormReview
     * @example
     * // Get one FormReview
     * const formReview = await prisma.formReview.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends formReviewFindFirstOrThrowArgs>(
      args?: SelectSubset<T, formReviewFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__formReviewClient<formReview>, Prisma__formReviewClient<formReviewGetPayload<T>>>

    /**
     * Count the number of FormReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formReviewCountArgs} args - Arguments to filter FormReviews to count.
     * @example
     * // Count the number of FormReviews
     * const count = await prisma.formReview.count({
     *   where: {
     *     // ... the filter for the FormReviews we want to count
     *   }
     * })
    **/
    count<T extends formReviewCountArgs>(
      args?: Subset<T, formReviewCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FormReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FormReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FormReviewAggregateArgs>(args: Subset<T, FormReviewAggregateArgs>): PrismaPromise<GetFormReviewAggregateType<T>>

    /**
     * Group by FormReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FormReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FormReviewGroupByArgs['orderBy'] }
        : { orderBy?: FormReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FormReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFormReviewGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for formReview.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__formReviewClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    users<T extends usersArgs = {}>(args?: Subset<T, usersArgs>): CheckSelect<T, Prisma__usersClient<users | null >, Prisma__usersClient<usersGetPayload<T> | null >>;

    review<T extends reviewFindManyArgs = {}>(args?: Subset<T, reviewFindManyArgs>): CheckSelect<T, PrismaPromise<Array<review>>, PrismaPromise<Array<reviewGetPayload<T>>>>;

    topic<T extends topicReviewFindManyArgs = {}>(args?: Subset<T, topicReviewFindManyArgs>): CheckSelect<T, PrismaPromise<Array<topicReview>>, PrismaPromise<Array<topicReviewGetPayload<T>>>>;

    subjects<T extends subjectReviewFindManyArgs = {}>(args?: Subset<T, subjectReviewFindManyArgs>): CheckSelect<T, PrismaPromise<Array<subjectReview>>, PrismaPromise<Array<subjectReviewGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * formReview base type for findUnique actions
   */
  export type formReviewFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the formReview
     * 
    **/
    select?: formReviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: formReviewInclude | null
    /**
     * Filter, which formReview to fetch.
     * 
    **/
    where: formReviewWhereUniqueInput
  }

  /**
   * formReview: findUnique
   */
  export interface formReviewFindUniqueArgs extends formReviewFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * formReview base type for findFirst actions
   */
  export type formReviewFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the formReview
     * 
    **/
    select?: formReviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: formReviewInclude | null
    /**
     * Filter, which formReview to fetch.
     * 
    **/
    where?: formReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of formReviews to fetch.
     * 
    **/
    orderBy?: Enumerable<formReviewOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for formReviews.
     * 
    **/
    cursor?: formReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` formReviews from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` formReviews.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of formReviews.
     * 
    **/
    distinct?: Enumerable<FormReviewScalarFieldEnum>
  }

  /**
   * formReview: findFirst
   */
  export interface formReviewFindFirstArgs extends formReviewFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * formReview findMany
   */
  export type formReviewFindManyArgs = {
    /**
     * Select specific fields to fetch from the formReview
     * 
    **/
    select?: formReviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: formReviewInclude | null
    /**
     * Filter, which formReviews to fetch.
     * 
    **/
    where?: formReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of formReviews to fetch.
     * 
    **/
    orderBy?: Enumerable<formReviewOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing formReviews.
     * 
    **/
    cursor?: formReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` formReviews from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` formReviews.
     * 
    **/
    skip?: number
    distinct?: Enumerable<FormReviewScalarFieldEnum>
  }


  /**
   * formReview create
   */
  export type formReviewCreateArgs = {
    /**
     * Select specific fields to fetch from the formReview
     * 
    **/
    select?: formReviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: formReviewInclude | null
    /**
     * The data needed to create a formReview.
     * 
    **/
    data: XOR<formReviewCreateInput, formReviewUncheckedCreateInput>
  }


  /**
   * formReview createMany
   */
  export type formReviewCreateManyArgs = {
    /**
     * The data used to create many formReviews.
     * 
    **/
    data: Enumerable<formReviewCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * formReview update
   */
  export type formReviewUpdateArgs = {
    /**
     * Select specific fields to fetch from the formReview
     * 
    **/
    select?: formReviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: formReviewInclude | null
    /**
     * The data needed to update a formReview.
     * 
    **/
    data: XOR<formReviewUpdateInput, formReviewUncheckedUpdateInput>
    /**
     * Choose, which formReview to update.
     * 
    **/
    where: formReviewWhereUniqueInput
  }


  /**
   * formReview updateMany
   */
  export type formReviewUpdateManyArgs = {
    /**
     * The data used to update formReviews.
     * 
    **/
    data: XOR<formReviewUpdateManyMutationInput, formReviewUncheckedUpdateManyInput>
    /**
     * Filter which formReviews to update
     * 
    **/
    where?: formReviewWhereInput
  }


  /**
   * formReview upsert
   */
  export type formReviewUpsertArgs = {
    /**
     * Select specific fields to fetch from the formReview
     * 
    **/
    select?: formReviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: formReviewInclude | null
    /**
     * The filter to search for the formReview to update in case it exists.
     * 
    **/
    where: formReviewWhereUniqueInput
    /**
     * In case the formReview found by the `where` argument doesn't exist, create a new formReview with this data.
     * 
    **/
    create: XOR<formReviewCreateInput, formReviewUncheckedCreateInput>
    /**
     * In case the formReview was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<formReviewUpdateInput, formReviewUncheckedUpdateInput>
  }


  /**
   * formReview delete
   */
  export type formReviewDeleteArgs = {
    /**
     * Select specific fields to fetch from the formReview
     * 
    **/
    select?: formReviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: formReviewInclude | null
    /**
     * Filter which formReview to delete.
     * 
    **/
    where: formReviewWhereUniqueInput
  }


  /**
   * formReview deleteMany
   */
  export type formReviewDeleteManyArgs = {
    /**
     * Filter which formReviews to delete
     * 
    **/
    where?: formReviewWhereInput
  }


  /**
   * formReview: findUniqueOrThrow
   */
  export type formReviewFindUniqueOrThrowArgs = formReviewFindUniqueArgsBase
      

  /**
   * formReview: findFirstOrThrow
   */
  export type formReviewFindFirstOrThrowArgs = formReviewFindFirstArgsBase
      

  /**
   * formReview without action
   */
  export type formReviewArgs = {
    /**
     * Select specific fields to fetch from the formReview
     * 
    **/
    select?: formReviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: formReviewInclude | null
  }



  /**
   * Model topicReview
   */


  export type AggregateTopicReview = {
    _count: TopicReviewCountAggregateOutputType | null
    _avg: TopicReviewAvgAggregateOutputType | null
    _sum: TopicReviewSumAggregateOutputType | null
    _min: TopicReviewMinAggregateOutputType | null
    _max: TopicReviewMaxAggregateOutputType | null
  }

  export type TopicReviewAvgAggregateOutputType = {
    id: number | null
    subjectId: number | null
    formId: number | null
    usersId: number | null
  }

  export type TopicReviewSumAggregateOutputType = {
    id: number | null
    subjectId: number | null
    formId: number | null
    usersId: number | null
  }

  export type TopicReviewMinAggregateOutputType = {
    id: number | null
    topicName: string | null
    topicDefinition: string | null
    published: boolean | null
    subjectId: number | null
    formId: number | null
    usersId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TopicReviewMaxAggregateOutputType = {
    id: number | null
    topicName: string | null
    topicDefinition: string | null
    published: boolean | null
    subjectId: number | null
    formId: number | null
    usersId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TopicReviewCountAggregateOutputType = {
    id: number
    topicName: number
    topicDefinition: number
    published: number
    subjectId: number
    formId: number
    usersId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TopicReviewAvgAggregateInputType = {
    id?: true
    subjectId?: true
    formId?: true
    usersId?: true
  }

  export type TopicReviewSumAggregateInputType = {
    id?: true
    subjectId?: true
    formId?: true
    usersId?: true
  }

  export type TopicReviewMinAggregateInputType = {
    id?: true
    topicName?: true
    topicDefinition?: true
    published?: true
    subjectId?: true
    formId?: true
    usersId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TopicReviewMaxAggregateInputType = {
    id?: true
    topicName?: true
    topicDefinition?: true
    published?: true
    subjectId?: true
    formId?: true
    usersId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TopicReviewCountAggregateInputType = {
    id?: true
    topicName?: true
    topicDefinition?: true
    published?: true
    subjectId?: true
    formId?: true
    usersId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TopicReviewAggregateArgs = {
    /**
     * Filter which topicReview to aggregate.
     * 
    **/
    where?: topicReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of topicReviews to fetch.
     * 
    **/
    orderBy?: Enumerable<topicReviewOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: topicReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` topicReviews from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` topicReviews.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned topicReviews
    **/
    _count?: true | TopicReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TopicReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TopicReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TopicReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TopicReviewMaxAggregateInputType
  }

  export type GetTopicReviewAggregateType<T extends TopicReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateTopicReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTopicReview[P]>
      : GetScalarType<T[P], AggregateTopicReview[P]>
  }




  export type TopicReviewGroupByArgs = {
    where?: topicReviewWhereInput
    orderBy?: Enumerable<topicReviewOrderByWithAggregationInput>
    by: Array<TopicReviewScalarFieldEnum>
    having?: topicReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TopicReviewCountAggregateInputType | true
    _avg?: TopicReviewAvgAggregateInputType
    _sum?: TopicReviewSumAggregateInputType
    _min?: TopicReviewMinAggregateInputType
    _max?: TopicReviewMaxAggregateInputType
  }


  export type TopicReviewGroupByOutputType = {
    id: number
    topicName: string
    topicDefinition: string | null
    published: boolean
    subjectId: number
    formId: number
    usersId: number
    createdAt: Date
    updatedAt: Date
    _count: TopicReviewCountAggregateOutputType | null
    _avg: TopicReviewAvgAggregateOutputType | null
    _sum: TopicReviewSumAggregateOutputType | null
    _min: TopicReviewMinAggregateOutputType | null
    _max: TopicReviewMaxAggregateOutputType | null
  }

  type GetTopicReviewGroupByPayload<T extends TopicReviewGroupByArgs> = PrismaPromise<
    Array<
      PickArray<TopicReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TopicReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TopicReviewGroupByOutputType[P]>
            : GetScalarType<T[P], TopicReviewGroupByOutputType[P]>
        }
      >
    >


  export type topicReviewSelect = {
    id?: boolean
    topicName?: boolean
    topicDefinition?: boolean
    published?: boolean
    subjectId?: boolean
    formId?: boolean
    usersId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    form?: boolean | formReviewArgs
    subject?: boolean | subjectReviewArgs
    users?: boolean | usersArgs
    review?: boolean | reviewFindManyArgs
    _count?: boolean | TopicReviewCountOutputTypeArgs
  }

  export type topicReviewInclude = {
    form?: boolean | formReviewArgs
    subject?: boolean | subjectReviewArgs
    users?: boolean | usersArgs
    review?: boolean | reviewFindManyArgs
    _count?: boolean | TopicReviewCountOutputTypeArgs
  }

  export type topicReviewGetPayload<
    S extends boolean | null | undefined | topicReviewArgs,
    U = keyof S
      > = S extends true
        ? topicReview
    : S extends undefined
    ? never
    : S extends topicReviewArgs | topicReviewFindManyArgs
    ?'include' extends U
    ? topicReview  & {
    [P in TrueKeys<S['include']>]:
        P extends 'form' ? formReviewGetPayload<S['include'][P]> :
        P extends 'subject' ? subjectReviewGetPayload<S['include'][P]> :
        P extends 'users' ? usersGetPayload<S['include'][P]> :
        P extends 'review' ? Array < reviewGetPayload<S['include'][P]>>  :
        P extends '_count' ? TopicReviewCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'form' ? formReviewGetPayload<S['select'][P]> :
        P extends 'subject' ? subjectReviewGetPayload<S['select'][P]> :
        P extends 'users' ? usersGetPayload<S['select'][P]> :
        P extends 'review' ? Array < reviewGetPayload<S['select'][P]>>  :
        P extends '_count' ? TopicReviewCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof topicReview ? topicReview[P] : never
  } 
    : topicReview
  : topicReview


  type topicReviewCountArgs = Merge<
    Omit<topicReviewFindManyArgs, 'select' | 'include'> & {
      select?: TopicReviewCountAggregateInputType | true
    }
  >

  export interface topicReviewDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one TopicReview that matches the filter.
     * @param {topicReviewFindUniqueArgs} args - Arguments to find a TopicReview
     * @example
     * // Get one TopicReview
     * const topicReview = await prisma.topicReview.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends topicReviewFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, topicReviewFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'topicReview'> extends True ? CheckSelect<T, Prisma__topicReviewClient<topicReview>, Prisma__topicReviewClient<topicReviewGetPayload<T>>> : CheckSelect<T, Prisma__topicReviewClient<topicReview | null >, Prisma__topicReviewClient<topicReviewGetPayload<T> | null >>

    /**
     * Find the first TopicReview that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {topicReviewFindFirstArgs} args - Arguments to find a TopicReview
     * @example
     * // Get one TopicReview
     * const topicReview = await prisma.topicReview.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends topicReviewFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, topicReviewFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'topicReview'> extends True ? CheckSelect<T, Prisma__topicReviewClient<topicReview>, Prisma__topicReviewClient<topicReviewGetPayload<T>>> : CheckSelect<T, Prisma__topicReviewClient<topicReview | null >, Prisma__topicReviewClient<topicReviewGetPayload<T> | null >>

    /**
     * Find zero or more TopicReviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {topicReviewFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TopicReviews
     * const topicReviews = await prisma.topicReview.findMany()
     * 
     * // Get first 10 TopicReviews
     * const topicReviews = await prisma.topicReview.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const topicReviewWithIdOnly = await prisma.topicReview.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends topicReviewFindManyArgs>(
      args?: SelectSubset<T, topicReviewFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<topicReview>>, PrismaPromise<Array<topicReviewGetPayload<T>>>>

    /**
     * Create a TopicReview.
     * @param {topicReviewCreateArgs} args - Arguments to create a TopicReview.
     * @example
     * // Create one TopicReview
     * const TopicReview = await prisma.topicReview.create({
     *   data: {
     *     // ... data to create a TopicReview
     *   }
     * })
     * 
    **/
    create<T extends topicReviewCreateArgs>(
      args: SelectSubset<T, topicReviewCreateArgs>
    ): CheckSelect<T, Prisma__topicReviewClient<topicReview>, Prisma__topicReviewClient<topicReviewGetPayload<T>>>

    /**
     * Create many TopicReviews.
     *     @param {topicReviewCreateManyArgs} args - Arguments to create many TopicReviews.
     *     @example
     *     // Create many TopicReviews
     *     const topicReview = await prisma.topicReview.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends topicReviewCreateManyArgs>(
      args?: SelectSubset<T, topicReviewCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a TopicReview.
     * @param {topicReviewDeleteArgs} args - Arguments to delete one TopicReview.
     * @example
     * // Delete one TopicReview
     * const TopicReview = await prisma.topicReview.delete({
     *   where: {
     *     // ... filter to delete one TopicReview
     *   }
     * })
     * 
    **/
    delete<T extends topicReviewDeleteArgs>(
      args: SelectSubset<T, topicReviewDeleteArgs>
    ): CheckSelect<T, Prisma__topicReviewClient<topicReview>, Prisma__topicReviewClient<topicReviewGetPayload<T>>>

    /**
     * Update one TopicReview.
     * @param {topicReviewUpdateArgs} args - Arguments to update one TopicReview.
     * @example
     * // Update one TopicReview
     * const topicReview = await prisma.topicReview.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends topicReviewUpdateArgs>(
      args: SelectSubset<T, topicReviewUpdateArgs>
    ): CheckSelect<T, Prisma__topicReviewClient<topicReview>, Prisma__topicReviewClient<topicReviewGetPayload<T>>>

    /**
     * Delete zero or more TopicReviews.
     * @param {topicReviewDeleteManyArgs} args - Arguments to filter TopicReviews to delete.
     * @example
     * // Delete a few TopicReviews
     * const { count } = await prisma.topicReview.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends topicReviewDeleteManyArgs>(
      args?: SelectSubset<T, topicReviewDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more TopicReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {topicReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TopicReviews
     * const topicReview = await prisma.topicReview.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends topicReviewUpdateManyArgs>(
      args: SelectSubset<T, topicReviewUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one TopicReview.
     * @param {topicReviewUpsertArgs} args - Arguments to update or create a TopicReview.
     * @example
     * // Update or create a TopicReview
     * const topicReview = await prisma.topicReview.upsert({
     *   create: {
     *     // ... data to create a TopicReview
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TopicReview we want to update
     *   }
     * })
    **/
    upsert<T extends topicReviewUpsertArgs>(
      args: SelectSubset<T, topicReviewUpsertArgs>
    ): CheckSelect<T, Prisma__topicReviewClient<topicReview>, Prisma__topicReviewClient<topicReviewGetPayload<T>>>

    /**
     * Find one TopicReview that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {topicReviewFindUniqueOrThrowArgs} args - Arguments to find a TopicReview
     * @example
     * // Get one TopicReview
     * const topicReview = await prisma.topicReview.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends topicReviewFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, topicReviewFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__topicReviewClient<topicReview>, Prisma__topicReviewClient<topicReviewGetPayload<T>>>

    /**
     * Find the first TopicReview that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {topicReviewFindFirstOrThrowArgs} args - Arguments to find a TopicReview
     * @example
     * // Get one TopicReview
     * const topicReview = await prisma.topicReview.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends topicReviewFindFirstOrThrowArgs>(
      args?: SelectSubset<T, topicReviewFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__topicReviewClient<topicReview>, Prisma__topicReviewClient<topicReviewGetPayload<T>>>

    /**
     * Count the number of TopicReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {topicReviewCountArgs} args - Arguments to filter TopicReviews to count.
     * @example
     * // Count the number of TopicReviews
     * const count = await prisma.topicReview.count({
     *   where: {
     *     // ... the filter for the TopicReviews we want to count
     *   }
     * })
    **/
    count<T extends topicReviewCountArgs>(
      args?: Subset<T, topicReviewCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TopicReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TopicReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TopicReviewAggregateArgs>(args: Subset<T, TopicReviewAggregateArgs>): PrismaPromise<GetTopicReviewAggregateType<T>>

    /**
     * Group by TopicReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TopicReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TopicReviewGroupByArgs['orderBy'] }
        : { orderBy?: TopicReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TopicReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTopicReviewGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for topicReview.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__topicReviewClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    form<T extends formReviewArgs = {}>(args?: Subset<T, formReviewArgs>): CheckSelect<T, Prisma__formReviewClient<formReview | null >, Prisma__formReviewClient<formReviewGetPayload<T> | null >>;

    subject<T extends subjectReviewArgs = {}>(args?: Subset<T, subjectReviewArgs>): CheckSelect<T, Prisma__subjectReviewClient<subjectReview | null >, Prisma__subjectReviewClient<subjectReviewGetPayload<T> | null >>;

    users<T extends usersArgs = {}>(args?: Subset<T, usersArgs>): CheckSelect<T, Prisma__usersClient<users | null >, Prisma__usersClient<usersGetPayload<T> | null >>;

    review<T extends reviewFindManyArgs = {}>(args?: Subset<T, reviewFindManyArgs>): CheckSelect<T, PrismaPromise<Array<review>>, PrismaPromise<Array<reviewGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * topicReview base type for findUnique actions
   */
  export type topicReviewFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the topicReview
     * 
    **/
    select?: topicReviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: topicReviewInclude | null
    /**
     * Filter, which topicReview to fetch.
     * 
    **/
    where: topicReviewWhereUniqueInput
  }

  /**
   * topicReview: findUnique
   */
  export interface topicReviewFindUniqueArgs extends topicReviewFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * topicReview base type for findFirst actions
   */
  export type topicReviewFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the topicReview
     * 
    **/
    select?: topicReviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: topicReviewInclude | null
    /**
     * Filter, which topicReview to fetch.
     * 
    **/
    where?: topicReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of topicReviews to fetch.
     * 
    **/
    orderBy?: Enumerable<topicReviewOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for topicReviews.
     * 
    **/
    cursor?: topicReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` topicReviews from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` topicReviews.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of topicReviews.
     * 
    **/
    distinct?: Enumerable<TopicReviewScalarFieldEnum>
  }

  /**
   * topicReview: findFirst
   */
  export interface topicReviewFindFirstArgs extends topicReviewFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * topicReview findMany
   */
  export type topicReviewFindManyArgs = {
    /**
     * Select specific fields to fetch from the topicReview
     * 
    **/
    select?: topicReviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: topicReviewInclude | null
    /**
     * Filter, which topicReviews to fetch.
     * 
    **/
    where?: topicReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of topicReviews to fetch.
     * 
    **/
    orderBy?: Enumerable<topicReviewOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing topicReviews.
     * 
    **/
    cursor?: topicReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` topicReviews from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` topicReviews.
     * 
    **/
    skip?: number
    distinct?: Enumerable<TopicReviewScalarFieldEnum>
  }


  /**
   * topicReview create
   */
  export type topicReviewCreateArgs = {
    /**
     * Select specific fields to fetch from the topicReview
     * 
    **/
    select?: topicReviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: topicReviewInclude | null
    /**
     * The data needed to create a topicReview.
     * 
    **/
    data: XOR<topicReviewCreateInput, topicReviewUncheckedCreateInput>
  }


  /**
   * topicReview createMany
   */
  export type topicReviewCreateManyArgs = {
    /**
     * The data used to create many topicReviews.
     * 
    **/
    data: Enumerable<topicReviewCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * topicReview update
   */
  export type topicReviewUpdateArgs = {
    /**
     * Select specific fields to fetch from the topicReview
     * 
    **/
    select?: topicReviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: topicReviewInclude | null
    /**
     * The data needed to update a topicReview.
     * 
    **/
    data: XOR<topicReviewUpdateInput, topicReviewUncheckedUpdateInput>
    /**
     * Choose, which topicReview to update.
     * 
    **/
    where: topicReviewWhereUniqueInput
  }


  /**
   * topicReview updateMany
   */
  export type topicReviewUpdateManyArgs = {
    /**
     * The data used to update topicReviews.
     * 
    **/
    data: XOR<topicReviewUpdateManyMutationInput, topicReviewUncheckedUpdateManyInput>
    /**
     * Filter which topicReviews to update
     * 
    **/
    where?: topicReviewWhereInput
  }


  /**
   * topicReview upsert
   */
  export type topicReviewUpsertArgs = {
    /**
     * Select specific fields to fetch from the topicReview
     * 
    **/
    select?: topicReviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: topicReviewInclude | null
    /**
     * The filter to search for the topicReview to update in case it exists.
     * 
    **/
    where: topicReviewWhereUniqueInput
    /**
     * In case the topicReview found by the `where` argument doesn't exist, create a new topicReview with this data.
     * 
    **/
    create: XOR<topicReviewCreateInput, topicReviewUncheckedCreateInput>
    /**
     * In case the topicReview was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<topicReviewUpdateInput, topicReviewUncheckedUpdateInput>
  }


  /**
   * topicReview delete
   */
  export type topicReviewDeleteArgs = {
    /**
     * Select specific fields to fetch from the topicReview
     * 
    **/
    select?: topicReviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: topicReviewInclude | null
    /**
     * Filter which topicReview to delete.
     * 
    **/
    where: topicReviewWhereUniqueInput
  }


  /**
   * topicReview deleteMany
   */
  export type topicReviewDeleteManyArgs = {
    /**
     * Filter which topicReviews to delete
     * 
    **/
    where?: topicReviewWhereInput
  }


  /**
   * topicReview: findUniqueOrThrow
   */
  export type topicReviewFindUniqueOrThrowArgs = topicReviewFindUniqueArgsBase
      

  /**
   * topicReview: findFirstOrThrow
   */
  export type topicReviewFindFirstOrThrowArgs = topicReviewFindFirstArgsBase
      

  /**
   * topicReview without action
   */
  export type topicReviewArgs = {
    /**
     * Select specific fields to fetch from the topicReview
     * 
    **/
    select?: topicReviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: topicReviewInclude | null
  }



  /**
   * Model review
   */


  export type AggregateReview = {
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  export type ReviewAvgAggregateOutputType = {
    id: number | null
    topicId: number | null
    subjectId: number | null
    formId: number | null
    usersId: number | null
  }

  export type ReviewSumAggregateOutputType = {
    id: number | null
    topicId: number | null
    subjectId: number | null
    formId: number | null
    usersId: number | null
  }

  export type ReviewMinAggregateOutputType = {
    id: number | null
    name: string | null
    published: boolean | null
    topicId: number | null
    subjectId: number | null
    formId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    usersId: number | null
  }

  export type ReviewMaxAggregateOutputType = {
    id: number | null
    name: string | null
    published: boolean | null
    topicId: number | null
    subjectId: number | null
    formId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    usersId: number | null
  }

  export type ReviewCountAggregateOutputType = {
    id: number
    name: number
    published: number
    topicId: number
    subjectId: number
    formId: number
    createdAt: number
    updatedAt: number
    usersId: number
    _all: number
  }


  export type ReviewAvgAggregateInputType = {
    id?: true
    topicId?: true
    subjectId?: true
    formId?: true
    usersId?: true
  }

  export type ReviewSumAggregateInputType = {
    id?: true
    topicId?: true
    subjectId?: true
    formId?: true
    usersId?: true
  }

  export type ReviewMinAggregateInputType = {
    id?: true
    name?: true
    published?: true
    topicId?: true
    subjectId?: true
    formId?: true
    createdAt?: true
    updatedAt?: true
    usersId?: true
  }

  export type ReviewMaxAggregateInputType = {
    id?: true
    name?: true
    published?: true
    topicId?: true
    subjectId?: true
    formId?: true
    createdAt?: true
    updatedAt?: true
    usersId?: true
  }

  export type ReviewCountAggregateInputType = {
    id?: true
    name?: true
    published?: true
    topicId?: true
    subjectId?: true
    formId?: true
    createdAt?: true
    updatedAt?: true
    usersId?: true
    _all?: true
  }

  export type ReviewAggregateArgs = {
    /**
     * Filter which review to aggregate.
     * 
    **/
    where?: reviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reviews to fetch.
     * 
    **/
    orderBy?: Enumerable<reviewOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: reviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reviews from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reviews.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned reviews
    **/
    _count?: true | ReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewMaxAggregateInputType
  }

  export type GetReviewAggregateType<T extends ReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReview[P]>
      : GetScalarType<T[P], AggregateReview[P]>
  }




  export type ReviewGroupByArgs = {
    where?: reviewWhereInput
    orderBy?: Enumerable<reviewOrderByWithAggregationInput>
    by: Array<ReviewScalarFieldEnum>
    having?: reviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewCountAggregateInputType | true
    _avg?: ReviewAvgAggregateInputType
    _sum?: ReviewSumAggregateInputType
    _min?: ReviewMinAggregateInputType
    _max?: ReviewMaxAggregateInputType
  }


  export type ReviewGroupByOutputType = {
    id: number
    name: string
    published: boolean
    topicId: number
    subjectId: number
    formId: number
    createdAt: Date
    updatedAt: Date
    usersId: number
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  type GetReviewGroupByPayload<T extends ReviewGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewGroupByOutputType[P]>
        }
      >
    >


  export type reviewSelect = {
    id?: boolean
    name?: boolean
    published?: boolean
    topicId?: boolean
    subjectId?: boolean
    formId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    usersId?: boolean
    form?: boolean | formReviewArgs
    subject?: boolean | subjectReviewArgs
    topic?: boolean | topicReviewArgs
    users?: boolean | usersArgs
    question?: boolean | questionFindManyArgs
    _count?: boolean | ReviewCountOutputTypeArgs
  }

  export type reviewInclude = {
    form?: boolean | formReviewArgs
    subject?: boolean | subjectReviewArgs
    topic?: boolean | topicReviewArgs
    users?: boolean | usersArgs
    question?: boolean | questionFindManyArgs
    _count?: boolean | ReviewCountOutputTypeArgs
  }

  export type reviewGetPayload<
    S extends boolean | null | undefined | reviewArgs,
    U = keyof S
      > = S extends true
        ? review
    : S extends undefined
    ? never
    : S extends reviewArgs | reviewFindManyArgs
    ?'include' extends U
    ? review  & {
    [P in TrueKeys<S['include']>]:
        P extends 'form' ? formReviewGetPayload<S['include'][P]> :
        P extends 'subject' ? subjectReviewGetPayload<S['include'][P]> :
        P extends 'topic' ? topicReviewGetPayload<S['include'][P]> :
        P extends 'users' ? usersGetPayload<S['include'][P]> :
        P extends 'question' ? Array < questionGetPayload<S['include'][P]>>  :
        P extends '_count' ? ReviewCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'form' ? formReviewGetPayload<S['select'][P]> :
        P extends 'subject' ? subjectReviewGetPayload<S['select'][P]> :
        P extends 'topic' ? topicReviewGetPayload<S['select'][P]> :
        P extends 'users' ? usersGetPayload<S['select'][P]> :
        P extends 'question' ? Array < questionGetPayload<S['select'][P]>>  :
        P extends '_count' ? ReviewCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof review ? review[P] : never
  } 
    : review
  : review


  type reviewCountArgs = Merge<
    Omit<reviewFindManyArgs, 'select' | 'include'> & {
      select?: ReviewCountAggregateInputType | true
    }
  >

  export interface reviewDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Review that matches the filter.
     * @param {reviewFindUniqueArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends reviewFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, reviewFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'review'> extends True ? CheckSelect<T, Prisma__reviewClient<review>, Prisma__reviewClient<reviewGetPayload<T>>> : CheckSelect<T, Prisma__reviewClient<review | null >, Prisma__reviewClient<reviewGetPayload<T> | null >>

    /**
     * Find the first Review that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewFindFirstArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends reviewFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, reviewFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'review'> extends True ? CheckSelect<T, Prisma__reviewClient<review>, Prisma__reviewClient<reviewGetPayload<T>>> : CheckSelect<T, Prisma__reviewClient<review | null >, Prisma__reviewClient<reviewGetPayload<T> | null >>

    /**
     * Find zero or more Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reviews
     * const reviews = await prisma.review.findMany()
     * 
     * // Get first 10 Reviews
     * const reviews = await prisma.review.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewWithIdOnly = await prisma.review.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends reviewFindManyArgs>(
      args?: SelectSubset<T, reviewFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<review>>, PrismaPromise<Array<reviewGetPayload<T>>>>

    /**
     * Create a Review.
     * @param {reviewCreateArgs} args - Arguments to create a Review.
     * @example
     * // Create one Review
     * const Review = await prisma.review.create({
     *   data: {
     *     // ... data to create a Review
     *   }
     * })
     * 
    **/
    create<T extends reviewCreateArgs>(
      args: SelectSubset<T, reviewCreateArgs>
    ): CheckSelect<T, Prisma__reviewClient<review>, Prisma__reviewClient<reviewGetPayload<T>>>

    /**
     * Create many Reviews.
     *     @param {reviewCreateManyArgs} args - Arguments to create many Reviews.
     *     @example
     *     // Create many Reviews
     *     const review = await prisma.review.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends reviewCreateManyArgs>(
      args?: SelectSubset<T, reviewCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Review.
     * @param {reviewDeleteArgs} args - Arguments to delete one Review.
     * @example
     * // Delete one Review
     * const Review = await prisma.review.delete({
     *   where: {
     *     // ... filter to delete one Review
     *   }
     * })
     * 
    **/
    delete<T extends reviewDeleteArgs>(
      args: SelectSubset<T, reviewDeleteArgs>
    ): CheckSelect<T, Prisma__reviewClient<review>, Prisma__reviewClient<reviewGetPayload<T>>>

    /**
     * Update one Review.
     * @param {reviewUpdateArgs} args - Arguments to update one Review.
     * @example
     * // Update one Review
     * const review = await prisma.review.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends reviewUpdateArgs>(
      args: SelectSubset<T, reviewUpdateArgs>
    ): CheckSelect<T, Prisma__reviewClient<review>, Prisma__reviewClient<reviewGetPayload<T>>>

    /**
     * Delete zero or more Reviews.
     * @param {reviewDeleteManyArgs} args - Arguments to filter Reviews to delete.
     * @example
     * // Delete a few Reviews
     * const { count } = await prisma.review.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends reviewDeleteManyArgs>(
      args?: SelectSubset<T, reviewDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends reviewUpdateManyArgs>(
      args: SelectSubset<T, reviewUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Review.
     * @param {reviewUpsertArgs} args - Arguments to update or create a Review.
     * @example
     * // Update or create a Review
     * const review = await prisma.review.upsert({
     *   create: {
     *     // ... data to create a Review
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Review we want to update
     *   }
     * })
    **/
    upsert<T extends reviewUpsertArgs>(
      args: SelectSubset<T, reviewUpsertArgs>
    ): CheckSelect<T, Prisma__reviewClient<review>, Prisma__reviewClient<reviewGetPayload<T>>>

    /**
     * Find one Review that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {reviewFindUniqueOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends reviewFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, reviewFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__reviewClient<review>, Prisma__reviewClient<reviewGetPayload<T>>>

    /**
     * Find the first Review that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewFindFirstOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends reviewFindFirstOrThrowArgs>(
      args?: SelectSubset<T, reviewFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__reviewClient<review>, Prisma__reviewClient<reviewGetPayload<T>>>

    /**
     * Count the number of Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewCountArgs} args - Arguments to filter Reviews to count.
     * @example
     * // Count the number of Reviews
     * const count = await prisma.review.count({
     *   where: {
     *     // ... the filter for the Reviews we want to count
     *   }
     * })
    **/
    count<T extends reviewCountArgs>(
      args?: Subset<T, reviewCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewAggregateArgs>(args: Subset<T, ReviewAggregateArgs>): PrismaPromise<GetReviewAggregateType<T>>

    /**
     * Group by Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewGroupByArgs['orderBy'] }
        : { orderBy?: ReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for review.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__reviewClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    form<T extends formReviewArgs = {}>(args?: Subset<T, formReviewArgs>): CheckSelect<T, Prisma__formReviewClient<formReview | null >, Prisma__formReviewClient<formReviewGetPayload<T> | null >>;

    subject<T extends subjectReviewArgs = {}>(args?: Subset<T, subjectReviewArgs>): CheckSelect<T, Prisma__subjectReviewClient<subjectReview | null >, Prisma__subjectReviewClient<subjectReviewGetPayload<T> | null >>;

    topic<T extends topicReviewArgs = {}>(args?: Subset<T, topicReviewArgs>): CheckSelect<T, Prisma__topicReviewClient<topicReview | null >, Prisma__topicReviewClient<topicReviewGetPayload<T> | null >>;

    users<T extends usersArgs = {}>(args?: Subset<T, usersArgs>): CheckSelect<T, Prisma__usersClient<users | null >, Prisma__usersClient<usersGetPayload<T> | null >>;

    question<T extends questionFindManyArgs = {}>(args?: Subset<T, questionFindManyArgs>): CheckSelect<T, PrismaPromise<Array<question>>, PrismaPromise<Array<questionGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * review base type for findUnique actions
   */
  export type reviewFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the review
     * 
    **/
    select?: reviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: reviewInclude | null
    /**
     * Filter, which review to fetch.
     * 
    **/
    where: reviewWhereUniqueInput
  }

  /**
   * review: findUnique
   */
  export interface reviewFindUniqueArgs extends reviewFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * review base type for findFirst actions
   */
  export type reviewFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the review
     * 
    **/
    select?: reviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: reviewInclude | null
    /**
     * Filter, which review to fetch.
     * 
    **/
    where?: reviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reviews to fetch.
     * 
    **/
    orderBy?: Enumerable<reviewOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reviews.
     * 
    **/
    cursor?: reviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reviews from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reviews.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reviews.
     * 
    **/
    distinct?: Enumerable<ReviewScalarFieldEnum>
  }

  /**
   * review: findFirst
   */
  export interface reviewFindFirstArgs extends reviewFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * review findMany
   */
  export type reviewFindManyArgs = {
    /**
     * Select specific fields to fetch from the review
     * 
    **/
    select?: reviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: reviewInclude | null
    /**
     * Filter, which reviews to fetch.
     * 
    **/
    where?: reviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reviews to fetch.
     * 
    **/
    orderBy?: Enumerable<reviewOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing reviews.
     * 
    **/
    cursor?: reviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reviews from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reviews.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ReviewScalarFieldEnum>
  }


  /**
   * review create
   */
  export type reviewCreateArgs = {
    /**
     * Select specific fields to fetch from the review
     * 
    **/
    select?: reviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: reviewInclude | null
    /**
     * The data needed to create a review.
     * 
    **/
    data: XOR<reviewCreateInput, reviewUncheckedCreateInput>
  }


  /**
   * review createMany
   */
  export type reviewCreateManyArgs = {
    /**
     * The data used to create many reviews.
     * 
    **/
    data: Enumerable<reviewCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * review update
   */
  export type reviewUpdateArgs = {
    /**
     * Select specific fields to fetch from the review
     * 
    **/
    select?: reviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: reviewInclude | null
    /**
     * The data needed to update a review.
     * 
    **/
    data: XOR<reviewUpdateInput, reviewUncheckedUpdateInput>
    /**
     * Choose, which review to update.
     * 
    **/
    where: reviewWhereUniqueInput
  }


  /**
   * review updateMany
   */
  export type reviewUpdateManyArgs = {
    /**
     * The data used to update reviews.
     * 
    **/
    data: XOR<reviewUpdateManyMutationInput, reviewUncheckedUpdateManyInput>
    /**
     * Filter which reviews to update
     * 
    **/
    where?: reviewWhereInput
  }


  /**
   * review upsert
   */
  export type reviewUpsertArgs = {
    /**
     * Select specific fields to fetch from the review
     * 
    **/
    select?: reviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: reviewInclude | null
    /**
     * The filter to search for the review to update in case it exists.
     * 
    **/
    where: reviewWhereUniqueInput
    /**
     * In case the review found by the `where` argument doesn't exist, create a new review with this data.
     * 
    **/
    create: XOR<reviewCreateInput, reviewUncheckedCreateInput>
    /**
     * In case the review was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<reviewUpdateInput, reviewUncheckedUpdateInput>
  }


  /**
   * review delete
   */
  export type reviewDeleteArgs = {
    /**
     * Select specific fields to fetch from the review
     * 
    **/
    select?: reviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: reviewInclude | null
    /**
     * Filter which review to delete.
     * 
    **/
    where: reviewWhereUniqueInput
  }


  /**
   * review deleteMany
   */
  export type reviewDeleteManyArgs = {
    /**
     * Filter which reviews to delete
     * 
    **/
    where?: reviewWhereInput
  }


  /**
   * review: findUniqueOrThrow
   */
  export type reviewFindUniqueOrThrowArgs = reviewFindUniqueArgsBase
      

  /**
   * review: findFirstOrThrow
   */
  export type reviewFindFirstOrThrowArgs = reviewFindFirstArgsBase
      

  /**
   * review without action
   */
  export type reviewArgs = {
    /**
     * Select specific fields to fetch from the review
     * 
    **/
    select?: reviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: reviewInclude | null
  }



  /**
   * Model question
   */


  export type AggregateQuestion = {
    _count: QuestionCountAggregateOutputType | null
    _avg: QuestionAvgAggregateOutputType | null
    _sum: QuestionSumAggregateOutputType | null
    _min: QuestionMinAggregateOutputType | null
    _max: QuestionMaxAggregateOutputType | null
  }

  export type QuestionAvgAggregateOutputType = {
    id: number | null
    questionFormatId: number | null
    reviewId: number | null
    usersId: number | null
  }

  export type QuestionSumAggregateOutputType = {
    id: number | null
    questionFormatId: number | null
    reviewId: number | null
    usersId: number | null
  }

  export type QuestionMinAggregateOutputType = {
    id: number | null
    question: string | null
    published: boolean | null
    answerDetails: string | null
    questionFormatId: number | null
    reviewId: number | null
    usersId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuestionMaxAggregateOutputType = {
    id: number | null
    question: string | null
    published: boolean | null
    answerDetails: string | null
    questionFormatId: number | null
    reviewId: number | null
    usersId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuestionCountAggregateOutputType = {
    id: number
    question: number
    published: number
    answerDetails: number
    questionFormatId: number
    reviewId: number
    usersId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QuestionAvgAggregateInputType = {
    id?: true
    questionFormatId?: true
    reviewId?: true
    usersId?: true
  }

  export type QuestionSumAggregateInputType = {
    id?: true
    questionFormatId?: true
    reviewId?: true
    usersId?: true
  }

  export type QuestionMinAggregateInputType = {
    id?: true
    question?: true
    published?: true
    answerDetails?: true
    questionFormatId?: true
    reviewId?: true
    usersId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuestionMaxAggregateInputType = {
    id?: true
    question?: true
    published?: true
    answerDetails?: true
    questionFormatId?: true
    reviewId?: true
    usersId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuestionCountAggregateInputType = {
    id?: true
    question?: true
    published?: true
    answerDetails?: true
    questionFormatId?: true
    reviewId?: true
    usersId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QuestionAggregateArgs = {
    /**
     * Filter which question to aggregate.
     * 
    **/
    where?: questionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questions to fetch.
     * 
    **/
    orderBy?: Enumerable<questionOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: questionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned questions
    **/
    _count?: true | QuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuestionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuestionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestionMaxAggregateInputType
  }

  export type GetQuestionAggregateType<T extends QuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestion[P]>
      : GetScalarType<T[P], AggregateQuestion[P]>
  }




  export type QuestionGroupByArgs = {
    where?: questionWhereInput
    orderBy?: Enumerable<questionOrderByWithAggregationInput>
    by: Array<QuestionScalarFieldEnum>
    having?: questionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestionCountAggregateInputType | true
    _avg?: QuestionAvgAggregateInputType
    _sum?: QuestionSumAggregateInputType
    _min?: QuestionMinAggregateInputType
    _max?: QuestionMaxAggregateInputType
  }


  export type QuestionGroupByOutputType = {
    id: number
    question: string
    published: boolean
    answerDetails: string
    questionFormatId: number
    reviewId: number
    usersId: number
    createdAt: Date
    updatedAt: Date
    _count: QuestionCountAggregateOutputType | null
    _avg: QuestionAvgAggregateOutputType | null
    _sum: QuestionSumAggregateOutputType | null
    _min: QuestionMinAggregateOutputType | null
    _max: QuestionMaxAggregateOutputType | null
  }

  type GetQuestionGroupByPayload<T extends QuestionGroupByArgs> = PrismaPromise<
    Array<
      PickArray<QuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionGroupByOutputType[P]>
        }
      >
    >


  export type questionSelect = {
    id?: boolean
    question?: boolean
    published?: boolean
    answerDetails?: boolean
    questionFormatId?: boolean
    reviewId?: boolean
    usersId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    questionFormat?: boolean | questionFormatArgs
    review?: boolean | reviewArgs
    users?: boolean | usersArgs
    answer?: boolean | answerFindManyArgs
    _count?: boolean | QuestionCountOutputTypeArgs
  }

  export type questionInclude = {
    questionFormat?: boolean | questionFormatArgs
    review?: boolean | reviewArgs
    users?: boolean | usersArgs
    answer?: boolean | answerFindManyArgs
    _count?: boolean | QuestionCountOutputTypeArgs
  }

  export type questionGetPayload<
    S extends boolean | null | undefined | questionArgs,
    U = keyof S
      > = S extends true
        ? question
    : S extends undefined
    ? never
    : S extends questionArgs | questionFindManyArgs
    ?'include' extends U
    ? question  & {
    [P in TrueKeys<S['include']>]:
        P extends 'questionFormat' ? questionFormatGetPayload<S['include'][P]> :
        P extends 'review' ? reviewGetPayload<S['include'][P]> :
        P extends 'users' ? usersGetPayload<S['include'][P]> :
        P extends 'answer' ? Array < answerGetPayload<S['include'][P]>>  :
        P extends '_count' ? QuestionCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'questionFormat' ? questionFormatGetPayload<S['select'][P]> :
        P extends 'review' ? reviewGetPayload<S['select'][P]> :
        P extends 'users' ? usersGetPayload<S['select'][P]> :
        P extends 'answer' ? Array < answerGetPayload<S['select'][P]>>  :
        P extends '_count' ? QuestionCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof question ? question[P] : never
  } 
    : question
  : question


  type questionCountArgs = Merge<
    Omit<questionFindManyArgs, 'select' | 'include'> & {
      select?: QuestionCountAggregateInputType | true
    }
  >

  export interface questionDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Question that matches the filter.
     * @param {questionFindUniqueArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends questionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, questionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'question'> extends True ? CheckSelect<T, Prisma__questionClient<question>, Prisma__questionClient<questionGetPayload<T>>> : CheckSelect<T, Prisma__questionClient<question | null >, Prisma__questionClient<questionGetPayload<T> | null >>

    /**
     * Find the first Question that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionFindFirstArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends questionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, questionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'question'> extends True ? CheckSelect<T, Prisma__questionClient<question>, Prisma__questionClient<questionGetPayload<T>>> : CheckSelect<T, Prisma__questionClient<question | null >, Prisma__questionClient<questionGetPayload<T> | null >>

    /**
     * Find zero or more Questions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Questions
     * const questions = await prisma.question.findMany()
     * 
     * // Get first 10 Questions
     * const questions = await prisma.question.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questionWithIdOnly = await prisma.question.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends questionFindManyArgs>(
      args?: SelectSubset<T, questionFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<question>>, PrismaPromise<Array<questionGetPayload<T>>>>

    /**
     * Create a Question.
     * @param {questionCreateArgs} args - Arguments to create a Question.
     * @example
     * // Create one Question
     * const Question = await prisma.question.create({
     *   data: {
     *     // ... data to create a Question
     *   }
     * })
     * 
    **/
    create<T extends questionCreateArgs>(
      args: SelectSubset<T, questionCreateArgs>
    ): CheckSelect<T, Prisma__questionClient<question>, Prisma__questionClient<questionGetPayload<T>>>

    /**
     * Create many Questions.
     *     @param {questionCreateManyArgs} args - Arguments to create many Questions.
     *     @example
     *     // Create many Questions
     *     const question = await prisma.question.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends questionCreateManyArgs>(
      args?: SelectSubset<T, questionCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Question.
     * @param {questionDeleteArgs} args - Arguments to delete one Question.
     * @example
     * // Delete one Question
     * const Question = await prisma.question.delete({
     *   where: {
     *     // ... filter to delete one Question
     *   }
     * })
     * 
    **/
    delete<T extends questionDeleteArgs>(
      args: SelectSubset<T, questionDeleteArgs>
    ): CheckSelect<T, Prisma__questionClient<question>, Prisma__questionClient<questionGetPayload<T>>>

    /**
     * Update one Question.
     * @param {questionUpdateArgs} args - Arguments to update one Question.
     * @example
     * // Update one Question
     * const question = await prisma.question.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends questionUpdateArgs>(
      args: SelectSubset<T, questionUpdateArgs>
    ): CheckSelect<T, Prisma__questionClient<question>, Prisma__questionClient<questionGetPayload<T>>>

    /**
     * Delete zero or more Questions.
     * @param {questionDeleteManyArgs} args - Arguments to filter Questions to delete.
     * @example
     * // Delete a few Questions
     * const { count } = await prisma.question.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends questionDeleteManyArgs>(
      args?: SelectSubset<T, questionDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Questions
     * const question = await prisma.question.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends questionUpdateManyArgs>(
      args: SelectSubset<T, questionUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Question.
     * @param {questionUpsertArgs} args - Arguments to update or create a Question.
     * @example
     * // Update or create a Question
     * const question = await prisma.question.upsert({
     *   create: {
     *     // ... data to create a Question
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Question we want to update
     *   }
     * })
    **/
    upsert<T extends questionUpsertArgs>(
      args: SelectSubset<T, questionUpsertArgs>
    ): CheckSelect<T, Prisma__questionClient<question>, Prisma__questionClient<questionGetPayload<T>>>

    /**
     * Find one Question that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {questionFindUniqueOrThrowArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends questionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, questionFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__questionClient<question>, Prisma__questionClient<questionGetPayload<T>>>

    /**
     * Find the first Question that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionFindFirstOrThrowArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends questionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, questionFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__questionClient<question>, Prisma__questionClient<questionGetPayload<T>>>

    /**
     * Count the number of Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionCountArgs} args - Arguments to filter Questions to count.
     * @example
     * // Count the number of Questions
     * const count = await prisma.question.count({
     *   where: {
     *     // ... the filter for the Questions we want to count
     *   }
     * })
    **/
    count<T extends questionCountArgs>(
      args?: Subset<T, questionCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Question.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionAggregateArgs>(args: Subset<T, QuestionAggregateArgs>): PrismaPromise<GetQuestionAggregateType<T>>

    /**
     * Group by Question.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuestionGroupByArgs['orderBy'] }
        : { orderBy?: QuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for question.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__questionClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    questionFormat<T extends questionFormatArgs = {}>(args?: Subset<T, questionFormatArgs>): CheckSelect<T, Prisma__questionFormatClient<questionFormat | null >, Prisma__questionFormatClient<questionFormatGetPayload<T> | null >>;

    review<T extends reviewArgs = {}>(args?: Subset<T, reviewArgs>): CheckSelect<T, Prisma__reviewClient<review | null >, Prisma__reviewClient<reviewGetPayload<T> | null >>;

    users<T extends usersArgs = {}>(args?: Subset<T, usersArgs>): CheckSelect<T, Prisma__usersClient<users | null >, Prisma__usersClient<usersGetPayload<T> | null >>;

    answer<T extends answerFindManyArgs = {}>(args?: Subset<T, answerFindManyArgs>): CheckSelect<T, PrismaPromise<Array<answer>>, PrismaPromise<Array<answerGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * question base type for findUnique actions
   */
  export type questionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the question
     * 
    **/
    select?: questionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: questionInclude | null
    /**
     * Filter, which question to fetch.
     * 
    **/
    where: questionWhereUniqueInput
  }

  /**
   * question: findUnique
   */
  export interface questionFindUniqueArgs extends questionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * question base type for findFirst actions
   */
  export type questionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the question
     * 
    **/
    select?: questionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: questionInclude | null
    /**
     * Filter, which question to fetch.
     * 
    **/
    where?: questionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questions to fetch.
     * 
    **/
    orderBy?: Enumerable<questionOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for questions.
     * 
    **/
    cursor?: questionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of questions.
     * 
    **/
    distinct?: Enumerable<QuestionScalarFieldEnum>
  }

  /**
   * question: findFirst
   */
  export interface questionFindFirstArgs extends questionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * question findMany
   */
  export type questionFindManyArgs = {
    /**
     * Select specific fields to fetch from the question
     * 
    **/
    select?: questionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: questionInclude | null
    /**
     * Filter, which questions to fetch.
     * 
    **/
    where?: questionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questions to fetch.
     * 
    **/
    orderBy?: Enumerable<questionOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing questions.
     * 
    **/
    cursor?: questionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<QuestionScalarFieldEnum>
  }


  /**
   * question create
   */
  export type questionCreateArgs = {
    /**
     * Select specific fields to fetch from the question
     * 
    **/
    select?: questionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: questionInclude | null
    /**
     * The data needed to create a question.
     * 
    **/
    data: XOR<questionCreateInput, questionUncheckedCreateInput>
  }


  /**
   * question createMany
   */
  export type questionCreateManyArgs = {
    /**
     * The data used to create many questions.
     * 
    **/
    data: Enumerable<questionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * question update
   */
  export type questionUpdateArgs = {
    /**
     * Select specific fields to fetch from the question
     * 
    **/
    select?: questionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: questionInclude | null
    /**
     * The data needed to update a question.
     * 
    **/
    data: XOR<questionUpdateInput, questionUncheckedUpdateInput>
    /**
     * Choose, which question to update.
     * 
    **/
    where: questionWhereUniqueInput
  }


  /**
   * question updateMany
   */
  export type questionUpdateManyArgs = {
    /**
     * The data used to update questions.
     * 
    **/
    data: XOR<questionUpdateManyMutationInput, questionUncheckedUpdateManyInput>
    /**
     * Filter which questions to update
     * 
    **/
    where?: questionWhereInput
  }


  /**
   * question upsert
   */
  export type questionUpsertArgs = {
    /**
     * Select specific fields to fetch from the question
     * 
    **/
    select?: questionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: questionInclude | null
    /**
     * The filter to search for the question to update in case it exists.
     * 
    **/
    where: questionWhereUniqueInput
    /**
     * In case the question found by the `where` argument doesn't exist, create a new question with this data.
     * 
    **/
    create: XOR<questionCreateInput, questionUncheckedCreateInput>
    /**
     * In case the question was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<questionUpdateInput, questionUncheckedUpdateInput>
  }


  /**
   * question delete
   */
  export type questionDeleteArgs = {
    /**
     * Select specific fields to fetch from the question
     * 
    **/
    select?: questionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: questionInclude | null
    /**
     * Filter which question to delete.
     * 
    **/
    where: questionWhereUniqueInput
  }


  /**
   * question deleteMany
   */
  export type questionDeleteManyArgs = {
    /**
     * Filter which questions to delete
     * 
    **/
    where?: questionWhereInput
  }


  /**
   * question: findUniqueOrThrow
   */
  export type questionFindUniqueOrThrowArgs = questionFindUniqueArgsBase
      

  /**
   * question: findFirstOrThrow
   */
  export type questionFindFirstOrThrowArgs = questionFindFirstArgsBase
      

  /**
   * question without action
   */
  export type questionArgs = {
    /**
     * Select specific fields to fetch from the question
     * 
    **/
    select?: questionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: questionInclude | null
  }



  /**
   * Model questionFormat
   */


  export type AggregateQuestionFormat = {
    _count: QuestionFormatCountAggregateOutputType | null
    _avg: QuestionFormatAvgAggregateOutputType | null
    _sum: QuestionFormatSumAggregateOutputType | null
    _min: QuestionFormatMinAggregateOutputType | null
    _max: QuestionFormatMaxAggregateOutputType | null
  }

  export type QuestionFormatAvgAggregateOutputType = {
    id: number | null
  }

  export type QuestionFormatSumAggregateOutputType = {
    id: number | null
  }

  export type QuestionFormatMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuestionFormatMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuestionFormatCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QuestionFormatAvgAggregateInputType = {
    id?: true
  }

  export type QuestionFormatSumAggregateInputType = {
    id?: true
  }

  export type QuestionFormatMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuestionFormatMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuestionFormatCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QuestionFormatAggregateArgs = {
    /**
     * Filter which questionFormat to aggregate.
     * 
    **/
    where?: questionFormatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questionFormats to fetch.
     * 
    **/
    orderBy?: Enumerable<questionFormatOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: questionFormatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questionFormats from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questionFormats.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned questionFormats
    **/
    _count?: true | QuestionFormatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuestionFormatAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuestionFormatSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestionFormatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestionFormatMaxAggregateInputType
  }

  export type GetQuestionFormatAggregateType<T extends QuestionFormatAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestionFormat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestionFormat[P]>
      : GetScalarType<T[P], AggregateQuestionFormat[P]>
  }




  export type QuestionFormatGroupByArgs = {
    where?: questionFormatWhereInput
    orderBy?: Enumerable<questionFormatOrderByWithAggregationInput>
    by: Array<QuestionFormatScalarFieldEnum>
    having?: questionFormatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestionFormatCountAggregateInputType | true
    _avg?: QuestionFormatAvgAggregateInputType
    _sum?: QuestionFormatSumAggregateInputType
    _min?: QuestionFormatMinAggregateInputType
    _max?: QuestionFormatMaxAggregateInputType
  }


  export type QuestionFormatGroupByOutputType = {
    id: number
    name: string
    createdAt: Date
    updatedAt: Date
    _count: QuestionFormatCountAggregateOutputType | null
    _avg: QuestionFormatAvgAggregateOutputType | null
    _sum: QuestionFormatSumAggregateOutputType | null
    _min: QuestionFormatMinAggregateOutputType | null
    _max: QuestionFormatMaxAggregateOutputType | null
  }

  type GetQuestionFormatGroupByPayload<T extends QuestionFormatGroupByArgs> = PrismaPromise<
    Array<
      PickArray<QuestionFormatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestionFormatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionFormatGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionFormatGroupByOutputType[P]>
        }
      >
    >


  export type questionFormatSelect = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    question?: boolean | questionFindManyArgs
    _count?: boolean | QuestionFormatCountOutputTypeArgs
  }

  export type questionFormatInclude = {
    question?: boolean | questionFindManyArgs
    _count?: boolean | QuestionFormatCountOutputTypeArgs
  }

  export type questionFormatGetPayload<
    S extends boolean | null | undefined | questionFormatArgs,
    U = keyof S
      > = S extends true
        ? questionFormat
    : S extends undefined
    ? never
    : S extends questionFormatArgs | questionFormatFindManyArgs
    ?'include' extends U
    ? questionFormat  & {
    [P in TrueKeys<S['include']>]:
        P extends 'question' ? Array < questionGetPayload<S['include'][P]>>  :
        P extends '_count' ? QuestionFormatCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'question' ? Array < questionGetPayload<S['select'][P]>>  :
        P extends '_count' ? QuestionFormatCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof questionFormat ? questionFormat[P] : never
  } 
    : questionFormat
  : questionFormat


  type questionFormatCountArgs = Merge<
    Omit<questionFormatFindManyArgs, 'select' | 'include'> & {
      select?: QuestionFormatCountAggregateInputType | true
    }
  >

  export interface questionFormatDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one QuestionFormat that matches the filter.
     * @param {questionFormatFindUniqueArgs} args - Arguments to find a QuestionFormat
     * @example
     * // Get one QuestionFormat
     * const questionFormat = await prisma.questionFormat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends questionFormatFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, questionFormatFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'questionFormat'> extends True ? CheckSelect<T, Prisma__questionFormatClient<questionFormat>, Prisma__questionFormatClient<questionFormatGetPayload<T>>> : CheckSelect<T, Prisma__questionFormatClient<questionFormat | null >, Prisma__questionFormatClient<questionFormatGetPayload<T> | null >>

    /**
     * Find the first QuestionFormat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionFormatFindFirstArgs} args - Arguments to find a QuestionFormat
     * @example
     * // Get one QuestionFormat
     * const questionFormat = await prisma.questionFormat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends questionFormatFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, questionFormatFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'questionFormat'> extends True ? CheckSelect<T, Prisma__questionFormatClient<questionFormat>, Prisma__questionFormatClient<questionFormatGetPayload<T>>> : CheckSelect<T, Prisma__questionFormatClient<questionFormat | null >, Prisma__questionFormatClient<questionFormatGetPayload<T> | null >>

    /**
     * Find zero or more QuestionFormats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionFormatFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuestionFormats
     * const questionFormats = await prisma.questionFormat.findMany()
     * 
     * // Get first 10 QuestionFormats
     * const questionFormats = await prisma.questionFormat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questionFormatWithIdOnly = await prisma.questionFormat.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends questionFormatFindManyArgs>(
      args?: SelectSubset<T, questionFormatFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<questionFormat>>, PrismaPromise<Array<questionFormatGetPayload<T>>>>

    /**
     * Create a QuestionFormat.
     * @param {questionFormatCreateArgs} args - Arguments to create a QuestionFormat.
     * @example
     * // Create one QuestionFormat
     * const QuestionFormat = await prisma.questionFormat.create({
     *   data: {
     *     // ... data to create a QuestionFormat
     *   }
     * })
     * 
    **/
    create<T extends questionFormatCreateArgs>(
      args: SelectSubset<T, questionFormatCreateArgs>
    ): CheckSelect<T, Prisma__questionFormatClient<questionFormat>, Prisma__questionFormatClient<questionFormatGetPayload<T>>>

    /**
     * Create many QuestionFormats.
     *     @param {questionFormatCreateManyArgs} args - Arguments to create many QuestionFormats.
     *     @example
     *     // Create many QuestionFormats
     *     const questionFormat = await prisma.questionFormat.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends questionFormatCreateManyArgs>(
      args?: SelectSubset<T, questionFormatCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a QuestionFormat.
     * @param {questionFormatDeleteArgs} args - Arguments to delete one QuestionFormat.
     * @example
     * // Delete one QuestionFormat
     * const QuestionFormat = await prisma.questionFormat.delete({
     *   where: {
     *     // ... filter to delete one QuestionFormat
     *   }
     * })
     * 
    **/
    delete<T extends questionFormatDeleteArgs>(
      args: SelectSubset<T, questionFormatDeleteArgs>
    ): CheckSelect<T, Prisma__questionFormatClient<questionFormat>, Prisma__questionFormatClient<questionFormatGetPayload<T>>>

    /**
     * Update one QuestionFormat.
     * @param {questionFormatUpdateArgs} args - Arguments to update one QuestionFormat.
     * @example
     * // Update one QuestionFormat
     * const questionFormat = await prisma.questionFormat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends questionFormatUpdateArgs>(
      args: SelectSubset<T, questionFormatUpdateArgs>
    ): CheckSelect<T, Prisma__questionFormatClient<questionFormat>, Prisma__questionFormatClient<questionFormatGetPayload<T>>>

    /**
     * Delete zero or more QuestionFormats.
     * @param {questionFormatDeleteManyArgs} args - Arguments to filter QuestionFormats to delete.
     * @example
     * // Delete a few QuestionFormats
     * const { count } = await prisma.questionFormat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends questionFormatDeleteManyArgs>(
      args?: SelectSubset<T, questionFormatDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuestionFormats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionFormatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuestionFormats
     * const questionFormat = await prisma.questionFormat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends questionFormatUpdateManyArgs>(
      args: SelectSubset<T, questionFormatUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one QuestionFormat.
     * @param {questionFormatUpsertArgs} args - Arguments to update or create a QuestionFormat.
     * @example
     * // Update or create a QuestionFormat
     * const questionFormat = await prisma.questionFormat.upsert({
     *   create: {
     *     // ... data to create a QuestionFormat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuestionFormat we want to update
     *   }
     * })
    **/
    upsert<T extends questionFormatUpsertArgs>(
      args: SelectSubset<T, questionFormatUpsertArgs>
    ): CheckSelect<T, Prisma__questionFormatClient<questionFormat>, Prisma__questionFormatClient<questionFormatGetPayload<T>>>

    /**
     * Find one QuestionFormat that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {questionFormatFindUniqueOrThrowArgs} args - Arguments to find a QuestionFormat
     * @example
     * // Get one QuestionFormat
     * const questionFormat = await prisma.questionFormat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends questionFormatFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, questionFormatFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__questionFormatClient<questionFormat>, Prisma__questionFormatClient<questionFormatGetPayload<T>>>

    /**
     * Find the first QuestionFormat that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionFormatFindFirstOrThrowArgs} args - Arguments to find a QuestionFormat
     * @example
     * // Get one QuestionFormat
     * const questionFormat = await prisma.questionFormat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends questionFormatFindFirstOrThrowArgs>(
      args?: SelectSubset<T, questionFormatFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__questionFormatClient<questionFormat>, Prisma__questionFormatClient<questionFormatGetPayload<T>>>

    /**
     * Count the number of QuestionFormats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionFormatCountArgs} args - Arguments to filter QuestionFormats to count.
     * @example
     * // Count the number of QuestionFormats
     * const count = await prisma.questionFormat.count({
     *   where: {
     *     // ... the filter for the QuestionFormats we want to count
     *   }
     * })
    **/
    count<T extends questionFormatCountArgs>(
      args?: Subset<T, questionFormatCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionFormatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuestionFormat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionFormatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionFormatAggregateArgs>(args: Subset<T, QuestionFormatAggregateArgs>): PrismaPromise<GetQuestionFormatAggregateType<T>>

    /**
     * Group by QuestionFormat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionFormatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuestionFormatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuestionFormatGroupByArgs['orderBy'] }
        : { orderBy?: QuestionFormatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuestionFormatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionFormatGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for questionFormat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__questionFormatClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    question<T extends questionFindManyArgs = {}>(args?: Subset<T, questionFindManyArgs>): CheckSelect<T, PrismaPromise<Array<question>>, PrismaPromise<Array<questionGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * questionFormat base type for findUnique actions
   */
  export type questionFormatFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the questionFormat
     * 
    **/
    select?: questionFormatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: questionFormatInclude | null
    /**
     * Filter, which questionFormat to fetch.
     * 
    **/
    where: questionFormatWhereUniqueInput
  }

  /**
   * questionFormat: findUnique
   */
  export interface questionFormatFindUniqueArgs extends questionFormatFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * questionFormat base type for findFirst actions
   */
  export type questionFormatFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the questionFormat
     * 
    **/
    select?: questionFormatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: questionFormatInclude | null
    /**
     * Filter, which questionFormat to fetch.
     * 
    **/
    where?: questionFormatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questionFormats to fetch.
     * 
    **/
    orderBy?: Enumerable<questionFormatOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for questionFormats.
     * 
    **/
    cursor?: questionFormatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questionFormats from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questionFormats.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of questionFormats.
     * 
    **/
    distinct?: Enumerable<QuestionFormatScalarFieldEnum>
  }

  /**
   * questionFormat: findFirst
   */
  export interface questionFormatFindFirstArgs extends questionFormatFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * questionFormat findMany
   */
  export type questionFormatFindManyArgs = {
    /**
     * Select specific fields to fetch from the questionFormat
     * 
    **/
    select?: questionFormatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: questionFormatInclude | null
    /**
     * Filter, which questionFormats to fetch.
     * 
    **/
    where?: questionFormatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questionFormats to fetch.
     * 
    **/
    orderBy?: Enumerable<questionFormatOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing questionFormats.
     * 
    **/
    cursor?: questionFormatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questionFormats from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questionFormats.
     * 
    **/
    skip?: number
    distinct?: Enumerable<QuestionFormatScalarFieldEnum>
  }


  /**
   * questionFormat create
   */
  export type questionFormatCreateArgs = {
    /**
     * Select specific fields to fetch from the questionFormat
     * 
    **/
    select?: questionFormatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: questionFormatInclude | null
    /**
     * The data needed to create a questionFormat.
     * 
    **/
    data: XOR<questionFormatCreateInput, questionFormatUncheckedCreateInput>
  }


  /**
   * questionFormat createMany
   */
  export type questionFormatCreateManyArgs = {
    /**
     * The data used to create many questionFormats.
     * 
    **/
    data: Enumerable<questionFormatCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * questionFormat update
   */
  export type questionFormatUpdateArgs = {
    /**
     * Select specific fields to fetch from the questionFormat
     * 
    **/
    select?: questionFormatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: questionFormatInclude | null
    /**
     * The data needed to update a questionFormat.
     * 
    **/
    data: XOR<questionFormatUpdateInput, questionFormatUncheckedUpdateInput>
    /**
     * Choose, which questionFormat to update.
     * 
    **/
    where: questionFormatWhereUniqueInput
  }


  /**
   * questionFormat updateMany
   */
  export type questionFormatUpdateManyArgs = {
    /**
     * The data used to update questionFormats.
     * 
    **/
    data: XOR<questionFormatUpdateManyMutationInput, questionFormatUncheckedUpdateManyInput>
    /**
     * Filter which questionFormats to update
     * 
    **/
    where?: questionFormatWhereInput
  }


  /**
   * questionFormat upsert
   */
  export type questionFormatUpsertArgs = {
    /**
     * Select specific fields to fetch from the questionFormat
     * 
    **/
    select?: questionFormatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: questionFormatInclude | null
    /**
     * The filter to search for the questionFormat to update in case it exists.
     * 
    **/
    where: questionFormatWhereUniqueInput
    /**
     * In case the questionFormat found by the `where` argument doesn't exist, create a new questionFormat with this data.
     * 
    **/
    create: XOR<questionFormatCreateInput, questionFormatUncheckedCreateInput>
    /**
     * In case the questionFormat was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<questionFormatUpdateInput, questionFormatUncheckedUpdateInput>
  }


  /**
   * questionFormat delete
   */
  export type questionFormatDeleteArgs = {
    /**
     * Select specific fields to fetch from the questionFormat
     * 
    **/
    select?: questionFormatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: questionFormatInclude | null
    /**
     * Filter which questionFormat to delete.
     * 
    **/
    where: questionFormatWhereUniqueInput
  }


  /**
   * questionFormat deleteMany
   */
  export type questionFormatDeleteManyArgs = {
    /**
     * Filter which questionFormats to delete
     * 
    **/
    where?: questionFormatWhereInput
  }


  /**
   * questionFormat: findUniqueOrThrow
   */
  export type questionFormatFindUniqueOrThrowArgs = questionFormatFindUniqueArgsBase
      

  /**
   * questionFormat: findFirstOrThrow
   */
  export type questionFormatFindFirstOrThrowArgs = questionFormatFindFirstArgsBase
      

  /**
   * questionFormat without action
   */
  export type questionFormatArgs = {
    /**
     * Select specific fields to fetch from the questionFormat
     * 
    **/
    select?: questionFormatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: questionFormatInclude | null
  }



  /**
   * Model answer
   */


  export type AggregateAnswer = {
    _count: AnswerCountAggregateOutputType | null
    _avg: AnswerAvgAggregateOutputType | null
    _sum: AnswerSumAggregateOutputType | null
    _min: AnswerMinAggregateOutputType | null
    _max: AnswerMaxAggregateOutputType | null
  }

  export type AnswerAvgAggregateOutputType = {
    id: number | null
    questionId: number | null
  }

  export type AnswerSumAggregateOutputType = {
    id: number | null
    questionId: number | null
  }

  export type AnswerMinAggregateOutputType = {
    id: number | null
    answer: string | null
    valid: boolean | null
    questionId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AnswerMaxAggregateOutputType = {
    id: number | null
    answer: string | null
    valid: boolean | null
    questionId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AnswerCountAggregateOutputType = {
    id: number
    answer: number
    valid: number
    questionId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AnswerAvgAggregateInputType = {
    id?: true
    questionId?: true
  }

  export type AnswerSumAggregateInputType = {
    id?: true
    questionId?: true
  }

  export type AnswerMinAggregateInputType = {
    id?: true
    answer?: true
    valid?: true
    questionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AnswerMaxAggregateInputType = {
    id?: true
    answer?: true
    valid?: true
    questionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AnswerCountAggregateInputType = {
    id?: true
    answer?: true
    valid?: true
    questionId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AnswerAggregateArgs = {
    /**
     * Filter which answer to aggregate.
     * 
    **/
    where?: answerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of answers to fetch.
     * 
    **/
    orderBy?: Enumerable<answerOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: answerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` answers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` answers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned answers
    **/
    _count?: true | AnswerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AnswerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AnswerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnswerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnswerMaxAggregateInputType
  }

  export type GetAnswerAggregateType<T extends AnswerAggregateArgs> = {
        [P in keyof T & keyof AggregateAnswer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnswer[P]>
      : GetScalarType<T[P], AggregateAnswer[P]>
  }




  export type AnswerGroupByArgs = {
    where?: answerWhereInput
    orderBy?: Enumerable<answerOrderByWithAggregationInput>
    by: Array<AnswerScalarFieldEnum>
    having?: answerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnswerCountAggregateInputType | true
    _avg?: AnswerAvgAggregateInputType
    _sum?: AnswerSumAggregateInputType
    _min?: AnswerMinAggregateInputType
    _max?: AnswerMaxAggregateInputType
  }


  export type AnswerGroupByOutputType = {
    id: number
    answer: string
    valid: boolean
    questionId: number
    createdAt: Date
    updatedAt: Date
    _count: AnswerCountAggregateOutputType | null
    _avg: AnswerAvgAggregateOutputType | null
    _sum: AnswerSumAggregateOutputType | null
    _min: AnswerMinAggregateOutputType | null
    _max: AnswerMaxAggregateOutputType | null
  }

  type GetAnswerGroupByPayload<T extends AnswerGroupByArgs> = PrismaPromise<
    Array<
      PickArray<AnswerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnswerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnswerGroupByOutputType[P]>
            : GetScalarType<T[P], AnswerGroupByOutputType[P]>
        }
      >
    >


  export type answerSelect = {
    id?: boolean
    answer?: boolean
    valid?: boolean
    questionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    question?: boolean | questionArgs
  }

  export type answerInclude = {
    question?: boolean | questionArgs
  }

  export type answerGetPayload<
    S extends boolean | null | undefined | answerArgs,
    U = keyof S
      > = S extends true
        ? answer
    : S extends undefined
    ? never
    : S extends answerArgs | answerFindManyArgs
    ?'include' extends U
    ? answer  & {
    [P in TrueKeys<S['include']>]:
        P extends 'question' ? questionGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'question' ? questionGetPayload<S['select'][P]> :  P extends keyof answer ? answer[P] : never
  } 
    : answer
  : answer


  type answerCountArgs = Merge<
    Omit<answerFindManyArgs, 'select' | 'include'> & {
      select?: AnswerCountAggregateInputType | true
    }
  >

  export interface answerDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Answer that matches the filter.
     * @param {answerFindUniqueArgs} args - Arguments to find a Answer
     * @example
     * // Get one Answer
     * const answer = await prisma.answer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends answerFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, answerFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'answer'> extends True ? CheckSelect<T, Prisma__answerClient<answer>, Prisma__answerClient<answerGetPayload<T>>> : CheckSelect<T, Prisma__answerClient<answer | null >, Prisma__answerClient<answerGetPayload<T> | null >>

    /**
     * Find the first Answer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {answerFindFirstArgs} args - Arguments to find a Answer
     * @example
     * // Get one Answer
     * const answer = await prisma.answer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends answerFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, answerFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'answer'> extends True ? CheckSelect<T, Prisma__answerClient<answer>, Prisma__answerClient<answerGetPayload<T>>> : CheckSelect<T, Prisma__answerClient<answer | null >, Prisma__answerClient<answerGetPayload<T> | null >>

    /**
     * Find zero or more Answers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {answerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Answers
     * const answers = await prisma.answer.findMany()
     * 
     * // Get first 10 Answers
     * const answers = await prisma.answer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const answerWithIdOnly = await prisma.answer.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends answerFindManyArgs>(
      args?: SelectSubset<T, answerFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<answer>>, PrismaPromise<Array<answerGetPayload<T>>>>

    /**
     * Create a Answer.
     * @param {answerCreateArgs} args - Arguments to create a Answer.
     * @example
     * // Create one Answer
     * const Answer = await prisma.answer.create({
     *   data: {
     *     // ... data to create a Answer
     *   }
     * })
     * 
    **/
    create<T extends answerCreateArgs>(
      args: SelectSubset<T, answerCreateArgs>
    ): CheckSelect<T, Prisma__answerClient<answer>, Prisma__answerClient<answerGetPayload<T>>>

    /**
     * Create many Answers.
     *     @param {answerCreateManyArgs} args - Arguments to create many Answers.
     *     @example
     *     // Create many Answers
     *     const answer = await prisma.answer.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends answerCreateManyArgs>(
      args?: SelectSubset<T, answerCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Answer.
     * @param {answerDeleteArgs} args - Arguments to delete one Answer.
     * @example
     * // Delete one Answer
     * const Answer = await prisma.answer.delete({
     *   where: {
     *     // ... filter to delete one Answer
     *   }
     * })
     * 
    **/
    delete<T extends answerDeleteArgs>(
      args: SelectSubset<T, answerDeleteArgs>
    ): CheckSelect<T, Prisma__answerClient<answer>, Prisma__answerClient<answerGetPayload<T>>>

    /**
     * Update one Answer.
     * @param {answerUpdateArgs} args - Arguments to update one Answer.
     * @example
     * // Update one Answer
     * const answer = await prisma.answer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends answerUpdateArgs>(
      args: SelectSubset<T, answerUpdateArgs>
    ): CheckSelect<T, Prisma__answerClient<answer>, Prisma__answerClient<answerGetPayload<T>>>

    /**
     * Delete zero or more Answers.
     * @param {answerDeleteManyArgs} args - Arguments to filter Answers to delete.
     * @example
     * // Delete a few Answers
     * const { count } = await prisma.answer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends answerDeleteManyArgs>(
      args?: SelectSubset<T, answerDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Answers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {answerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Answers
     * const answer = await prisma.answer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends answerUpdateManyArgs>(
      args: SelectSubset<T, answerUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Answer.
     * @param {answerUpsertArgs} args - Arguments to update or create a Answer.
     * @example
     * // Update or create a Answer
     * const answer = await prisma.answer.upsert({
     *   create: {
     *     // ... data to create a Answer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Answer we want to update
     *   }
     * })
    **/
    upsert<T extends answerUpsertArgs>(
      args: SelectSubset<T, answerUpsertArgs>
    ): CheckSelect<T, Prisma__answerClient<answer>, Prisma__answerClient<answerGetPayload<T>>>

    /**
     * Find one Answer that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {answerFindUniqueOrThrowArgs} args - Arguments to find a Answer
     * @example
     * // Get one Answer
     * const answer = await prisma.answer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends answerFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, answerFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__answerClient<answer>, Prisma__answerClient<answerGetPayload<T>>>

    /**
     * Find the first Answer that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {answerFindFirstOrThrowArgs} args - Arguments to find a Answer
     * @example
     * // Get one Answer
     * const answer = await prisma.answer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends answerFindFirstOrThrowArgs>(
      args?: SelectSubset<T, answerFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__answerClient<answer>, Prisma__answerClient<answerGetPayload<T>>>

    /**
     * Count the number of Answers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {answerCountArgs} args - Arguments to filter Answers to count.
     * @example
     * // Count the number of Answers
     * const count = await prisma.answer.count({
     *   where: {
     *     // ... the filter for the Answers we want to count
     *   }
     * })
    **/
    count<T extends answerCountArgs>(
      args?: Subset<T, answerCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnswerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Answer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnswerAggregateArgs>(args: Subset<T, AnswerAggregateArgs>): PrismaPromise<GetAnswerAggregateType<T>>

    /**
     * Group by Answer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnswerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnswerGroupByArgs['orderBy'] }
        : { orderBy?: AnswerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnswerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnswerGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for answer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__answerClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    question<T extends questionArgs = {}>(args?: Subset<T, questionArgs>): CheckSelect<T, Prisma__questionClient<question | null >, Prisma__questionClient<questionGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * answer base type for findUnique actions
   */
  export type answerFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the answer
     * 
    **/
    select?: answerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: answerInclude | null
    /**
     * Filter, which answer to fetch.
     * 
    **/
    where: answerWhereUniqueInput
  }

  /**
   * answer: findUnique
   */
  export interface answerFindUniqueArgs extends answerFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * answer base type for findFirst actions
   */
  export type answerFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the answer
     * 
    **/
    select?: answerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: answerInclude | null
    /**
     * Filter, which answer to fetch.
     * 
    **/
    where?: answerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of answers to fetch.
     * 
    **/
    orderBy?: Enumerable<answerOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for answers.
     * 
    **/
    cursor?: answerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` answers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` answers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of answers.
     * 
    **/
    distinct?: Enumerable<AnswerScalarFieldEnum>
  }

  /**
   * answer: findFirst
   */
  export interface answerFindFirstArgs extends answerFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * answer findMany
   */
  export type answerFindManyArgs = {
    /**
     * Select specific fields to fetch from the answer
     * 
    **/
    select?: answerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: answerInclude | null
    /**
     * Filter, which answers to fetch.
     * 
    **/
    where?: answerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of answers to fetch.
     * 
    **/
    orderBy?: Enumerable<answerOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing answers.
     * 
    **/
    cursor?: answerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` answers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` answers.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AnswerScalarFieldEnum>
  }


  /**
   * answer create
   */
  export type answerCreateArgs = {
    /**
     * Select specific fields to fetch from the answer
     * 
    **/
    select?: answerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: answerInclude | null
    /**
     * The data needed to create a answer.
     * 
    **/
    data: XOR<answerCreateInput, answerUncheckedCreateInput>
  }


  /**
   * answer createMany
   */
  export type answerCreateManyArgs = {
    /**
     * The data used to create many answers.
     * 
    **/
    data: Enumerable<answerCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * answer update
   */
  export type answerUpdateArgs = {
    /**
     * Select specific fields to fetch from the answer
     * 
    **/
    select?: answerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: answerInclude | null
    /**
     * The data needed to update a answer.
     * 
    **/
    data: XOR<answerUpdateInput, answerUncheckedUpdateInput>
    /**
     * Choose, which answer to update.
     * 
    **/
    where: answerWhereUniqueInput
  }


  /**
   * answer updateMany
   */
  export type answerUpdateManyArgs = {
    /**
     * The data used to update answers.
     * 
    **/
    data: XOR<answerUpdateManyMutationInput, answerUncheckedUpdateManyInput>
    /**
     * Filter which answers to update
     * 
    **/
    where?: answerWhereInput
  }


  /**
   * answer upsert
   */
  export type answerUpsertArgs = {
    /**
     * Select specific fields to fetch from the answer
     * 
    **/
    select?: answerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: answerInclude | null
    /**
     * The filter to search for the answer to update in case it exists.
     * 
    **/
    where: answerWhereUniqueInput
    /**
     * In case the answer found by the `where` argument doesn't exist, create a new answer with this data.
     * 
    **/
    create: XOR<answerCreateInput, answerUncheckedCreateInput>
    /**
     * In case the answer was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<answerUpdateInput, answerUncheckedUpdateInput>
  }


  /**
   * answer delete
   */
  export type answerDeleteArgs = {
    /**
     * Select specific fields to fetch from the answer
     * 
    **/
    select?: answerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: answerInclude | null
    /**
     * Filter which answer to delete.
     * 
    **/
    where: answerWhereUniqueInput
  }


  /**
   * answer deleteMany
   */
  export type answerDeleteManyArgs = {
    /**
     * Filter which answers to delete
     * 
    **/
    where?: answerWhereInput
  }


  /**
   * answer: findUniqueOrThrow
   */
  export type answerFindUniqueOrThrowArgs = answerFindUniqueArgsBase
      

  /**
   * answer: findFirstOrThrow
   */
  export type answerFindFirstOrThrowArgs = answerFindFirstArgsBase
      

  /**
   * answer without action
   */
  export type answerArgs = {
    /**
     * Select specific fields to fetch from the answer
     * 
    **/
    select?: answerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: answerInclude | null
  }



  /**
   * Model subjectExams
   */


  export type AggregateSubjectExams = {
    _count: SubjectExamsCountAggregateOutputType | null
    _avg: SubjectExamsAvgAggregateOutputType | null
    _sum: SubjectExamsSumAggregateOutputType | null
    _min: SubjectExamsMinAggregateOutputType | null
    _max: SubjectExamsMaxAggregateOutputType | null
  }

  export type SubjectExamsAvgAggregateOutputType = {
    id: number | null
    usersId: number | null
  }

  export type SubjectExamsSumAggregateOutputType = {
    id: number | null
    usersId: number | null
  }

  export type SubjectExamsMinAggregateOutputType = {
    id: number | null
    subjectName: string | null
    subjectDefinition: string | null
    imageLocation: string | null
    published: boolean | null
    usersId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubjectExamsMaxAggregateOutputType = {
    id: number | null
    subjectName: string | null
    subjectDefinition: string | null
    imageLocation: string | null
    published: boolean | null
    usersId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubjectExamsCountAggregateOutputType = {
    id: number
    subjectName: number
    subjectDefinition: number
    imageLocation: number
    published: number
    usersId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubjectExamsAvgAggregateInputType = {
    id?: true
    usersId?: true
  }

  export type SubjectExamsSumAggregateInputType = {
    id?: true
    usersId?: true
  }

  export type SubjectExamsMinAggregateInputType = {
    id?: true
    subjectName?: true
    subjectDefinition?: true
    imageLocation?: true
    published?: true
    usersId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubjectExamsMaxAggregateInputType = {
    id?: true
    subjectName?: true
    subjectDefinition?: true
    imageLocation?: true
    published?: true
    usersId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubjectExamsCountAggregateInputType = {
    id?: true
    subjectName?: true
    subjectDefinition?: true
    imageLocation?: true
    published?: true
    usersId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubjectExamsAggregateArgs = {
    /**
     * Filter which subjectExams to aggregate.
     * 
    **/
    where?: subjectExamsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subjectExams to fetch.
     * 
    **/
    orderBy?: Enumerable<subjectExamsOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: subjectExamsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subjectExams from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subjectExams.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned subjectExams
    **/
    _count?: true | SubjectExamsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubjectExamsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubjectExamsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubjectExamsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubjectExamsMaxAggregateInputType
  }

  export type GetSubjectExamsAggregateType<T extends SubjectExamsAggregateArgs> = {
        [P in keyof T & keyof AggregateSubjectExams]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubjectExams[P]>
      : GetScalarType<T[P], AggregateSubjectExams[P]>
  }




  export type SubjectExamsGroupByArgs = {
    where?: subjectExamsWhereInput
    orderBy?: Enumerable<subjectExamsOrderByWithAggregationInput>
    by: Array<SubjectExamsScalarFieldEnum>
    having?: subjectExamsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubjectExamsCountAggregateInputType | true
    _avg?: SubjectExamsAvgAggregateInputType
    _sum?: SubjectExamsSumAggregateInputType
    _min?: SubjectExamsMinAggregateInputType
    _max?: SubjectExamsMaxAggregateInputType
  }


  export type SubjectExamsGroupByOutputType = {
    id: number
    subjectName: string
    subjectDefinition: string
    imageLocation: string | null
    published: boolean
    usersId: number
    createdAt: Date
    updatedAt: Date
    _count: SubjectExamsCountAggregateOutputType | null
    _avg: SubjectExamsAvgAggregateOutputType | null
    _sum: SubjectExamsSumAggregateOutputType | null
    _min: SubjectExamsMinAggregateOutputType | null
    _max: SubjectExamsMaxAggregateOutputType | null
  }

  type GetSubjectExamsGroupByPayload<T extends SubjectExamsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SubjectExamsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubjectExamsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubjectExamsGroupByOutputType[P]>
            : GetScalarType<T[P], SubjectExamsGroupByOutputType[P]>
        }
      >
    >


  export type subjectExamsSelect = {
    id?: boolean
    subjectName?: boolean
    subjectDefinition?: boolean
    imageLocation?: boolean
    published?: boolean
    usersId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | usersArgs
    examType?: boolean | examTypeFindManyArgs
    forms?: boolean | formExamsFindManyArgs
    _count?: boolean | SubjectExamsCountOutputTypeArgs
  }

  export type subjectExamsInclude = {
    users?: boolean | usersArgs
    examType?: boolean | examTypeFindManyArgs
    forms?: boolean | formExamsFindManyArgs
    _count?: boolean | SubjectExamsCountOutputTypeArgs
  }

  export type subjectExamsGetPayload<
    S extends boolean | null | undefined | subjectExamsArgs,
    U = keyof S
      > = S extends true
        ? subjectExams
    : S extends undefined
    ? never
    : S extends subjectExamsArgs | subjectExamsFindManyArgs
    ?'include' extends U
    ? subjectExams  & {
    [P in TrueKeys<S['include']>]:
        P extends 'users' ? usersGetPayload<S['include'][P]> :
        P extends 'examType' ? Array < examTypeGetPayload<S['include'][P]>>  :
        P extends 'forms' ? Array < formExamsGetPayload<S['include'][P]>>  :
        P extends '_count' ? SubjectExamsCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'users' ? usersGetPayload<S['select'][P]> :
        P extends 'examType' ? Array < examTypeGetPayload<S['select'][P]>>  :
        P extends 'forms' ? Array < formExamsGetPayload<S['select'][P]>>  :
        P extends '_count' ? SubjectExamsCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof subjectExams ? subjectExams[P] : never
  } 
    : subjectExams
  : subjectExams


  type subjectExamsCountArgs = Merge<
    Omit<subjectExamsFindManyArgs, 'select' | 'include'> & {
      select?: SubjectExamsCountAggregateInputType | true
    }
  >

  export interface subjectExamsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one SubjectExams that matches the filter.
     * @param {subjectExamsFindUniqueArgs} args - Arguments to find a SubjectExams
     * @example
     * // Get one SubjectExams
     * const subjectExams = await prisma.subjectExams.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends subjectExamsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, subjectExamsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'subjectExams'> extends True ? CheckSelect<T, Prisma__subjectExamsClient<subjectExams>, Prisma__subjectExamsClient<subjectExamsGetPayload<T>>> : CheckSelect<T, Prisma__subjectExamsClient<subjectExams | null >, Prisma__subjectExamsClient<subjectExamsGetPayload<T> | null >>

    /**
     * Find the first SubjectExams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subjectExamsFindFirstArgs} args - Arguments to find a SubjectExams
     * @example
     * // Get one SubjectExams
     * const subjectExams = await prisma.subjectExams.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends subjectExamsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, subjectExamsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'subjectExams'> extends True ? CheckSelect<T, Prisma__subjectExamsClient<subjectExams>, Prisma__subjectExamsClient<subjectExamsGetPayload<T>>> : CheckSelect<T, Prisma__subjectExamsClient<subjectExams | null >, Prisma__subjectExamsClient<subjectExamsGetPayload<T> | null >>

    /**
     * Find zero or more SubjectExams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subjectExamsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubjectExams
     * const subjectExams = await prisma.subjectExams.findMany()
     * 
     * // Get first 10 SubjectExams
     * const subjectExams = await prisma.subjectExams.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subjectExamsWithIdOnly = await prisma.subjectExams.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends subjectExamsFindManyArgs>(
      args?: SelectSubset<T, subjectExamsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<subjectExams>>, PrismaPromise<Array<subjectExamsGetPayload<T>>>>

    /**
     * Create a SubjectExams.
     * @param {subjectExamsCreateArgs} args - Arguments to create a SubjectExams.
     * @example
     * // Create one SubjectExams
     * const SubjectExams = await prisma.subjectExams.create({
     *   data: {
     *     // ... data to create a SubjectExams
     *   }
     * })
     * 
    **/
    create<T extends subjectExamsCreateArgs>(
      args: SelectSubset<T, subjectExamsCreateArgs>
    ): CheckSelect<T, Prisma__subjectExamsClient<subjectExams>, Prisma__subjectExamsClient<subjectExamsGetPayload<T>>>

    /**
     * Create many SubjectExams.
     *     @param {subjectExamsCreateManyArgs} args - Arguments to create many SubjectExams.
     *     @example
     *     // Create many SubjectExams
     *     const subjectExams = await prisma.subjectExams.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends subjectExamsCreateManyArgs>(
      args?: SelectSubset<T, subjectExamsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a SubjectExams.
     * @param {subjectExamsDeleteArgs} args - Arguments to delete one SubjectExams.
     * @example
     * // Delete one SubjectExams
     * const SubjectExams = await prisma.subjectExams.delete({
     *   where: {
     *     // ... filter to delete one SubjectExams
     *   }
     * })
     * 
    **/
    delete<T extends subjectExamsDeleteArgs>(
      args: SelectSubset<T, subjectExamsDeleteArgs>
    ): CheckSelect<T, Prisma__subjectExamsClient<subjectExams>, Prisma__subjectExamsClient<subjectExamsGetPayload<T>>>

    /**
     * Update one SubjectExams.
     * @param {subjectExamsUpdateArgs} args - Arguments to update one SubjectExams.
     * @example
     * // Update one SubjectExams
     * const subjectExams = await prisma.subjectExams.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends subjectExamsUpdateArgs>(
      args: SelectSubset<T, subjectExamsUpdateArgs>
    ): CheckSelect<T, Prisma__subjectExamsClient<subjectExams>, Prisma__subjectExamsClient<subjectExamsGetPayload<T>>>

    /**
     * Delete zero or more SubjectExams.
     * @param {subjectExamsDeleteManyArgs} args - Arguments to filter SubjectExams to delete.
     * @example
     * // Delete a few SubjectExams
     * const { count } = await prisma.subjectExams.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends subjectExamsDeleteManyArgs>(
      args?: SelectSubset<T, subjectExamsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubjectExams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subjectExamsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubjectExams
     * const subjectExams = await prisma.subjectExams.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends subjectExamsUpdateManyArgs>(
      args: SelectSubset<T, subjectExamsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one SubjectExams.
     * @param {subjectExamsUpsertArgs} args - Arguments to update or create a SubjectExams.
     * @example
     * // Update or create a SubjectExams
     * const subjectExams = await prisma.subjectExams.upsert({
     *   create: {
     *     // ... data to create a SubjectExams
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubjectExams we want to update
     *   }
     * })
    **/
    upsert<T extends subjectExamsUpsertArgs>(
      args: SelectSubset<T, subjectExamsUpsertArgs>
    ): CheckSelect<T, Prisma__subjectExamsClient<subjectExams>, Prisma__subjectExamsClient<subjectExamsGetPayload<T>>>

    /**
     * Find one SubjectExams that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {subjectExamsFindUniqueOrThrowArgs} args - Arguments to find a SubjectExams
     * @example
     * // Get one SubjectExams
     * const subjectExams = await prisma.subjectExams.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends subjectExamsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, subjectExamsFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__subjectExamsClient<subjectExams>, Prisma__subjectExamsClient<subjectExamsGetPayload<T>>>

    /**
     * Find the first SubjectExams that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subjectExamsFindFirstOrThrowArgs} args - Arguments to find a SubjectExams
     * @example
     * // Get one SubjectExams
     * const subjectExams = await prisma.subjectExams.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends subjectExamsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, subjectExamsFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__subjectExamsClient<subjectExams>, Prisma__subjectExamsClient<subjectExamsGetPayload<T>>>

    /**
     * Count the number of SubjectExams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subjectExamsCountArgs} args - Arguments to filter SubjectExams to count.
     * @example
     * // Count the number of SubjectExams
     * const count = await prisma.subjectExams.count({
     *   where: {
     *     // ... the filter for the SubjectExams we want to count
     *   }
     * })
    **/
    count<T extends subjectExamsCountArgs>(
      args?: Subset<T, subjectExamsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubjectExamsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubjectExams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectExamsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubjectExamsAggregateArgs>(args: Subset<T, SubjectExamsAggregateArgs>): PrismaPromise<GetSubjectExamsAggregateType<T>>

    /**
     * Group by SubjectExams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectExamsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubjectExamsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubjectExamsGroupByArgs['orderBy'] }
        : { orderBy?: SubjectExamsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubjectExamsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubjectExamsGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for subjectExams.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__subjectExamsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    users<T extends usersArgs = {}>(args?: Subset<T, usersArgs>): CheckSelect<T, Prisma__usersClient<users | null >, Prisma__usersClient<usersGetPayload<T> | null >>;

    examType<T extends examTypeFindManyArgs = {}>(args?: Subset<T, examTypeFindManyArgs>): CheckSelect<T, PrismaPromise<Array<examType>>, PrismaPromise<Array<examTypeGetPayload<T>>>>;

    forms<T extends formExamsFindManyArgs = {}>(args?: Subset<T, formExamsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<formExams>>, PrismaPromise<Array<formExamsGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * subjectExams base type for findUnique actions
   */
  export type subjectExamsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the subjectExams
     * 
    **/
    select?: subjectExamsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: subjectExamsInclude | null
    /**
     * Filter, which subjectExams to fetch.
     * 
    **/
    where: subjectExamsWhereUniqueInput
  }

  /**
   * subjectExams: findUnique
   */
  export interface subjectExamsFindUniqueArgs extends subjectExamsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * subjectExams base type for findFirst actions
   */
  export type subjectExamsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the subjectExams
     * 
    **/
    select?: subjectExamsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: subjectExamsInclude | null
    /**
     * Filter, which subjectExams to fetch.
     * 
    **/
    where?: subjectExamsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subjectExams to fetch.
     * 
    **/
    orderBy?: Enumerable<subjectExamsOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for subjectExams.
     * 
    **/
    cursor?: subjectExamsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subjectExams from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subjectExams.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of subjectExams.
     * 
    **/
    distinct?: Enumerable<SubjectExamsScalarFieldEnum>
  }

  /**
   * subjectExams: findFirst
   */
  export interface subjectExamsFindFirstArgs extends subjectExamsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * subjectExams findMany
   */
  export type subjectExamsFindManyArgs = {
    /**
     * Select specific fields to fetch from the subjectExams
     * 
    **/
    select?: subjectExamsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: subjectExamsInclude | null
    /**
     * Filter, which subjectExams to fetch.
     * 
    **/
    where?: subjectExamsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subjectExams to fetch.
     * 
    **/
    orderBy?: Enumerable<subjectExamsOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing subjectExams.
     * 
    **/
    cursor?: subjectExamsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subjectExams from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subjectExams.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SubjectExamsScalarFieldEnum>
  }


  /**
   * subjectExams create
   */
  export type subjectExamsCreateArgs = {
    /**
     * Select specific fields to fetch from the subjectExams
     * 
    **/
    select?: subjectExamsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: subjectExamsInclude | null
    /**
     * The data needed to create a subjectExams.
     * 
    **/
    data: XOR<subjectExamsCreateInput, subjectExamsUncheckedCreateInput>
  }


  /**
   * subjectExams createMany
   */
  export type subjectExamsCreateManyArgs = {
    /**
     * The data used to create many subjectExams.
     * 
    **/
    data: Enumerable<subjectExamsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * subjectExams update
   */
  export type subjectExamsUpdateArgs = {
    /**
     * Select specific fields to fetch from the subjectExams
     * 
    **/
    select?: subjectExamsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: subjectExamsInclude | null
    /**
     * The data needed to update a subjectExams.
     * 
    **/
    data: XOR<subjectExamsUpdateInput, subjectExamsUncheckedUpdateInput>
    /**
     * Choose, which subjectExams to update.
     * 
    **/
    where: subjectExamsWhereUniqueInput
  }


  /**
   * subjectExams updateMany
   */
  export type subjectExamsUpdateManyArgs = {
    /**
     * The data used to update subjectExams.
     * 
    **/
    data: XOR<subjectExamsUpdateManyMutationInput, subjectExamsUncheckedUpdateManyInput>
    /**
     * Filter which subjectExams to update
     * 
    **/
    where?: subjectExamsWhereInput
  }


  /**
   * subjectExams upsert
   */
  export type subjectExamsUpsertArgs = {
    /**
     * Select specific fields to fetch from the subjectExams
     * 
    **/
    select?: subjectExamsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: subjectExamsInclude | null
    /**
     * The filter to search for the subjectExams to update in case it exists.
     * 
    **/
    where: subjectExamsWhereUniqueInput
    /**
     * In case the subjectExams found by the `where` argument doesn't exist, create a new subjectExams with this data.
     * 
    **/
    create: XOR<subjectExamsCreateInput, subjectExamsUncheckedCreateInput>
    /**
     * In case the subjectExams was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<subjectExamsUpdateInput, subjectExamsUncheckedUpdateInput>
  }


  /**
   * subjectExams delete
   */
  export type subjectExamsDeleteArgs = {
    /**
     * Select specific fields to fetch from the subjectExams
     * 
    **/
    select?: subjectExamsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: subjectExamsInclude | null
    /**
     * Filter which subjectExams to delete.
     * 
    **/
    where: subjectExamsWhereUniqueInput
  }


  /**
   * subjectExams deleteMany
   */
  export type subjectExamsDeleteManyArgs = {
    /**
     * Filter which subjectExams to delete
     * 
    **/
    where?: subjectExamsWhereInput
  }


  /**
   * subjectExams: findUniqueOrThrow
   */
  export type subjectExamsFindUniqueOrThrowArgs = subjectExamsFindUniqueArgsBase
      

  /**
   * subjectExams: findFirstOrThrow
   */
  export type subjectExamsFindFirstOrThrowArgs = subjectExamsFindFirstArgsBase
      

  /**
   * subjectExams without action
   */
  export type subjectExamsArgs = {
    /**
     * Select specific fields to fetch from the subjectExams
     * 
    **/
    select?: subjectExamsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: subjectExamsInclude | null
  }



  /**
   * Model formExams
   */


  export type AggregateFormExams = {
    _count: FormExamsCountAggregateOutputType | null
    _avg: FormExamsAvgAggregateOutputType | null
    _sum: FormExamsSumAggregateOutputType | null
    _min: FormExamsMinAggregateOutputType | null
    _max: FormExamsMaxAggregateOutputType | null
  }

  export type FormExamsAvgAggregateOutputType = {
    id: number | null
    usersId: number | null
  }

  export type FormExamsSumAggregateOutputType = {
    id: number | null
    usersId: number | null
  }

  export type FormExamsMinAggregateOutputType = {
    id: number | null
    formName: string | null
    usersId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FormExamsMaxAggregateOutputType = {
    id: number | null
    formName: string | null
    usersId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FormExamsCountAggregateOutputType = {
    id: number
    formName: number
    usersId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FormExamsAvgAggregateInputType = {
    id?: true
    usersId?: true
  }

  export type FormExamsSumAggregateInputType = {
    id?: true
    usersId?: true
  }

  export type FormExamsMinAggregateInputType = {
    id?: true
    formName?: true
    usersId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FormExamsMaxAggregateInputType = {
    id?: true
    formName?: true
    usersId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FormExamsCountAggregateInputType = {
    id?: true
    formName?: true
    usersId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FormExamsAggregateArgs = {
    /**
     * Filter which formExams to aggregate.
     * 
    **/
    where?: formExamsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of formExams to fetch.
     * 
    **/
    orderBy?: Enumerable<formExamsOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: formExamsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` formExams from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` formExams.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned formExams
    **/
    _count?: true | FormExamsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FormExamsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FormExamsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FormExamsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FormExamsMaxAggregateInputType
  }

  export type GetFormExamsAggregateType<T extends FormExamsAggregateArgs> = {
        [P in keyof T & keyof AggregateFormExams]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFormExams[P]>
      : GetScalarType<T[P], AggregateFormExams[P]>
  }




  export type FormExamsGroupByArgs = {
    where?: formExamsWhereInput
    orderBy?: Enumerable<formExamsOrderByWithAggregationInput>
    by: Array<FormExamsScalarFieldEnum>
    having?: formExamsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FormExamsCountAggregateInputType | true
    _avg?: FormExamsAvgAggregateInputType
    _sum?: FormExamsSumAggregateInputType
    _min?: FormExamsMinAggregateInputType
    _max?: FormExamsMaxAggregateInputType
  }


  export type FormExamsGroupByOutputType = {
    id: number
    formName: string
    usersId: number
    createdAt: Date
    updatedAt: Date
    _count: FormExamsCountAggregateOutputType | null
    _avg: FormExamsAvgAggregateOutputType | null
    _sum: FormExamsSumAggregateOutputType | null
    _min: FormExamsMinAggregateOutputType | null
    _max: FormExamsMaxAggregateOutputType | null
  }

  type GetFormExamsGroupByPayload<T extends FormExamsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<FormExamsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FormExamsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FormExamsGroupByOutputType[P]>
            : GetScalarType<T[P], FormExamsGroupByOutputType[P]>
        }
      >
    >


  export type formExamsSelect = {
    id?: boolean
    formName?: boolean
    usersId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | usersArgs
    examType?: boolean | examTypeFindManyArgs
    subjects?: boolean | subjectExamsFindManyArgs
    _count?: boolean | FormExamsCountOutputTypeArgs
  }

  export type formExamsInclude = {
    users?: boolean | usersArgs
    examType?: boolean | examTypeFindManyArgs
    subjects?: boolean | subjectExamsFindManyArgs
    _count?: boolean | FormExamsCountOutputTypeArgs
  }

  export type formExamsGetPayload<
    S extends boolean | null | undefined | formExamsArgs,
    U = keyof S
      > = S extends true
        ? formExams
    : S extends undefined
    ? never
    : S extends formExamsArgs | formExamsFindManyArgs
    ?'include' extends U
    ? formExams  & {
    [P in TrueKeys<S['include']>]:
        P extends 'users' ? usersGetPayload<S['include'][P]> :
        P extends 'examType' ? Array < examTypeGetPayload<S['include'][P]>>  :
        P extends 'subjects' ? Array < subjectExamsGetPayload<S['include'][P]>>  :
        P extends '_count' ? FormExamsCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'users' ? usersGetPayload<S['select'][P]> :
        P extends 'examType' ? Array < examTypeGetPayload<S['select'][P]>>  :
        P extends 'subjects' ? Array < subjectExamsGetPayload<S['select'][P]>>  :
        P extends '_count' ? FormExamsCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof formExams ? formExams[P] : never
  } 
    : formExams
  : formExams


  type formExamsCountArgs = Merge<
    Omit<formExamsFindManyArgs, 'select' | 'include'> & {
      select?: FormExamsCountAggregateInputType | true
    }
  >

  export interface formExamsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one FormExams that matches the filter.
     * @param {formExamsFindUniqueArgs} args - Arguments to find a FormExams
     * @example
     * // Get one FormExams
     * const formExams = await prisma.formExams.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends formExamsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, formExamsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'formExams'> extends True ? CheckSelect<T, Prisma__formExamsClient<formExams>, Prisma__formExamsClient<formExamsGetPayload<T>>> : CheckSelect<T, Prisma__formExamsClient<formExams | null >, Prisma__formExamsClient<formExamsGetPayload<T> | null >>

    /**
     * Find the first FormExams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formExamsFindFirstArgs} args - Arguments to find a FormExams
     * @example
     * // Get one FormExams
     * const formExams = await prisma.formExams.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends formExamsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, formExamsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'formExams'> extends True ? CheckSelect<T, Prisma__formExamsClient<formExams>, Prisma__formExamsClient<formExamsGetPayload<T>>> : CheckSelect<T, Prisma__formExamsClient<formExams | null >, Prisma__formExamsClient<formExamsGetPayload<T> | null >>

    /**
     * Find zero or more FormExams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formExamsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FormExams
     * const formExams = await prisma.formExams.findMany()
     * 
     * // Get first 10 FormExams
     * const formExams = await prisma.formExams.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const formExamsWithIdOnly = await prisma.formExams.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends formExamsFindManyArgs>(
      args?: SelectSubset<T, formExamsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<formExams>>, PrismaPromise<Array<formExamsGetPayload<T>>>>

    /**
     * Create a FormExams.
     * @param {formExamsCreateArgs} args - Arguments to create a FormExams.
     * @example
     * // Create one FormExams
     * const FormExams = await prisma.formExams.create({
     *   data: {
     *     // ... data to create a FormExams
     *   }
     * })
     * 
    **/
    create<T extends formExamsCreateArgs>(
      args: SelectSubset<T, formExamsCreateArgs>
    ): CheckSelect<T, Prisma__formExamsClient<formExams>, Prisma__formExamsClient<formExamsGetPayload<T>>>

    /**
     * Create many FormExams.
     *     @param {formExamsCreateManyArgs} args - Arguments to create many FormExams.
     *     @example
     *     // Create many FormExams
     *     const formExams = await prisma.formExams.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends formExamsCreateManyArgs>(
      args?: SelectSubset<T, formExamsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a FormExams.
     * @param {formExamsDeleteArgs} args - Arguments to delete one FormExams.
     * @example
     * // Delete one FormExams
     * const FormExams = await prisma.formExams.delete({
     *   where: {
     *     // ... filter to delete one FormExams
     *   }
     * })
     * 
    **/
    delete<T extends formExamsDeleteArgs>(
      args: SelectSubset<T, formExamsDeleteArgs>
    ): CheckSelect<T, Prisma__formExamsClient<formExams>, Prisma__formExamsClient<formExamsGetPayload<T>>>

    /**
     * Update one FormExams.
     * @param {formExamsUpdateArgs} args - Arguments to update one FormExams.
     * @example
     * // Update one FormExams
     * const formExams = await prisma.formExams.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends formExamsUpdateArgs>(
      args: SelectSubset<T, formExamsUpdateArgs>
    ): CheckSelect<T, Prisma__formExamsClient<formExams>, Prisma__formExamsClient<formExamsGetPayload<T>>>

    /**
     * Delete zero or more FormExams.
     * @param {formExamsDeleteManyArgs} args - Arguments to filter FormExams to delete.
     * @example
     * // Delete a few FormExams
     * const { count } = await prisma.formExams.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends formExamsDeleteManyArgs>(
      args?: SelectSubset<T, formExamsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more FormExams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formExamsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FormExams
     * const formExams = await prisma.formExams.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends formExamsUpdateManyArgs>(
      args: SelectSubset<T, formExamsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one FormExams.
     * @param {formExamsUpsertArgs} args - Arguments to update or create a FormExams.
     * @example
     * // Update or create a FormExams
     * const formExams = await prisma.formExams.upsert({
     *   create: {
     *     // ... data to create a FormExams
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FormExams we want to update
     *   }
     * })
    **/
    upsert<T extends formExamsUpsertArgs>(
      args: SelectSubset<T, formExamsUpsertArgs>
    ): CheckSelect<T, Prisma__formExamsClient<formExams>, Prisma__formExamsClient<formExamsGetPayload<T>>>

    /**
     * Find one FormExams that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {formExamsFindUniqueOrThrowArgs} args - Arguments to find a FormExams
     * @example
     * // Get one FormExams
     * const formExams = await prisma.formExams.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends formExamsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, formExamsFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__formExamsClient<formExams>, Prisma__formExamsClient<formExamsGetPayload<T>>>

    /**
     * Find the first FormExams that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formExamsFindFirstOrThrowArgs} args - Arguments to find a FormExams
     * @example
     * // Get one FormExams
     * const formExams = await prisma.formExams.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends formExamsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, formExamsFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__formExamsClient<formExams>, Prisma__formExamsClient<formExamsGetPayload<T>>>

    /**
     * Count the number of FormExams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formExamsCountArgs} args - Arguments to filter FormExams to count.
     * @example
     * // Count the number of FormExams
     * const count = await prisma.formExams.count({
     *   where: {
     *     // ... the filter for the FormExams we want to count
     *   }
     * })
    **/
    count<T extends formExamsCountArgs>(
      args?: Subset<T, formExamsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FormExamsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FormExams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormExamsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FormExamsAggregateArgs>(args: Subset<T, FormExamsAggregateArgs>): PrismaPromise<GetFormExamsAggregateType<T>>

    /**
     * Group by FormExams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormExamsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FormExamsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FormExamsGroupByArgs['orderBy'] }
        : { orderBy?: FormExamsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FormExamsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFormExamsGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for formExams.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__formExamsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    users<T extends usersArgs = {}>(args?: Subset<T, usersArgs>): CheckSelect<T, Prisma__usersClient<users | null >, Prisma__usersClient<usersGetPayload<T> | null >>;

    examType<T extends examTypeFindManyArgs = {}>(args?: Subset<T, examTypeFindManyArgs>): CheckSelect<T, PrismaPromise<Array<examType>>, PrismaPromise<Array<examTypeGetPayload<T>>>>;

    subjects<T extends subjectExamsFindManyArgs = {}>(args?: Subset<T, subjectExamsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<subjectExams>>, PrismaPromise<Array<subjectExamsGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * formExams base type for findUnique actions
   */
  export type formExamsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the formExams
     * 
    **/
    select?: formExamsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: formExamsInclude | null
    /**
     * Filter, which formExams to fetch.
     * 
    **/
    where: formExamsWhereUniqueInput
  }

  /**
   * formExams: findUnique
   */
  export interface formExamsFindUniqueArgs extends formExamsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * formExams base type for findFirst actions
   */
  export type formExamsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the formExams
     * 
    **/
    select?: formExamsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: formExamsInclude | null
    /**
     * Filter, which formExams to fetch.
     * 
    **/
    where?: formExamsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of formExams to fetch.
     * 
    **/
    orderBy?: Enumerable<formExamsOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for formExams.
     * 
    **/
    cursor?: formExamsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` formExams from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` formExams.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of formExams.
     * 
    **/
    distinct?: Enumerable<FormExamsScalarFieldEnum>
  }

  /**
   * formExams: findFirst
   */
  export interface formExamsFindFirstArgs extends formExamsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * formExams findMany
   */
  export type formExamsFindManyArgs = {
    /**
     * Select specific fields to fetch from the formExams
     * 
    **/
    select?: formExamsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: formExamsInclude | null
    /**
     * Filter, which formExams to fetch.
     * 
    **/
    where?: formExamsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of formExams to fetch.
     * 
    **/
    orderBy?: Enumerable<formExamsOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing formExams.
     * 
    **/
    cursor?: formExamsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` formExams from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` formExams.
     * 
    **/
    skip?: number
    distinct?: Enumerable<FormExamsScalarFieldEnum>
  }


  /**
   * formExams create
   */
  export type formExamsCreateArgs = {
    /**
     * Select specific fields to fetch from the formExams
     * 
    **/
    select?: formExamsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: formExamsInclude | null
    /**
     * The data needed to create a formExams.
     * 
    **/
    data: XOR<formExamsCreateInput, formExamsUncheckedCreateInput>
  }


  /**
   * formExams createMany
   */
  export type formExamsCreateManyArgs = {
    /**
     * The data used to create many formExams.
     * 
    **/
    data: Enumerable<formExamsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * formExams update
   */
  export type formExamsUpdateArgs = {
    /**
     * Select specific fields to fetch from the formExams
     * 
    **/
    select?: formExamsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: formExamsInclude | null
    /**
     * The data needed to update a formExams.
     * 
    **/
    data: XOR<formExamsUpdateInput, formExamsUncheckedUpdateInput>
    /**
     * Choose, which formExams to update.
     * 
    **/
    where: formExamsWhereUniqueInput
  }


  /**
   * formExams updateMany
   */
  export type formExamsUpdateManyArgs = {
    /**
     * The data used to update formExams.
     * 
    **/
    data: XOR<formExamsUpdateManyMutationInput, formExamsUncheckedUpdateManyInput>
    /**
     * Filter which formExams to update
     * 
    **/
    where?: formExamsWhereInput
  }


  /**
   * formExams upsert
   */
  export type formExamsUpsertArgs = {
    /**
     * Select specific fields to fetch from the formExams
     * 
    **/
    select?: formExamsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: formExamsInclude | null
    /**
     * The filter to search for the formExams to update in case it exists.
     * 
    **/
    where: formExamsWhereUniqueInput
    /**
     * In case the formExams found by the `where` argument doesn't exist, create a new formExams with this data.
     * 
    **/
    create: XOR<formExamsCreateInput, formExamsUncheckedCreateInput>
    /**
     * In case the formExams was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<formExamsUpdateInput, formExamsUncheckedUpdateInput>
  }


  /**
   * formExams delete
   */
  export type formExamsDeleteArgs = {
    /**
     * Select specific fields to fetch from the formExams
     * 
    **/
    select?: formExamsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: formExamsInclude | null
    /**
     * Filter which formExams to delete.
     * 
    **/
    where: formExamsWhereUniqueInput
  }


  /**
   * formExams deleteMany
   */
  export type formExamsDeleteManyArgs = {
    /**
     * Filter which formExams to delete
     * 
    **/
    where?: formExamsWhereInput
  }


  /**
   * formExams: findUniqueOrThrow
   */
  export type formExamsFindUniqueOrThrowArgs = formExamsFindUniqueArgsBase
      

  /**
   * formExams: findFirstOrThrow
   */
  export type formExamsFindFirstOrThrowArgs = formExamsFindFirstArgsBase
      

  /**
   * formExams without action
   */
  export type formExamsArgs = {
    /**
     * Select specific fields to fetch from the formExams
     * 
    **/
    select?: formExamsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: formExamsInclude | null
  }



  /**
   * Model examType
   */


  export type AggregateExamType = {
    _count: ExamTypeCountAggregateOutputType | null
    _avg: ExamTypeAvgAggregateOutputType | null
    _sum: ExamTypeSumAggregateOutputType | null
    _min: ExamTypeMinAggregateOutputType | null
    _max: ExamTypeMaxAggregateOutputType | null
  }

  export type ExamTypeAvgAggregateOutputType = {
    id: number | null
    subjectId: number | null
    formId: number | null
  }

  export type ExamTypeSumAggregateOutputType = {
    id: number | null
    subjectId: number | null
    formId: number | null
  }

  export type ExamTypeMinAggregateOutputType = {
    id: number | null
    name: string | null
    definition: string | null
    published: boolean | null
    subjectId: number | null
    formId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExamTypeMaxAggregateOutputType = {
    id: number | null
    name: string | null
    definition: string | null
    published: boolean | null
    subjectId: number | null
    formId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExamTypeCountAggregateOutputType = {
    id: number
    name: number
    definition: number
    published: number
    subjectId: number
    formId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExamTypeAvgAggregateInputType = {
    id?: true
    subjectId?: true
    formId?: true
  }

  export type ExamTypeSumAggregateInputType = {
    id?: true
    subjectId?: true
    formId?: true
  }

  export type ExamTypeMinAggregateInputType = {
    id?: true
    name?: true
    definition?: true
    published?: true
    subjectId?: true
    formId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExamTypeMaxAggregateInputType = {
    id?: true
    name?: true
    definition?: true
    published?: true
    subjectId?: true
    formId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExamTypeCountAggregateInputType = {
    id?: true
    name?: true
    definition?: true
    published?: true
    subjectId?: true
    formId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExamTypeAggregateArgs = {
    /**
     * Filter which examType to aggregate.
     * 
    **/
    where?: examTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of examTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<examTypeOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: examTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` examTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` examTypes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned examTypes
    **/
    _count?: true | ExamTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExamTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExamTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExamTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExamTypeMaxAggregateInputType
  }

  export type GetExamTypeAggregateType<T extends ExamTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateExamType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExamType[P]>
      : GetScalarType<T[P], AggregateExamType[P]>
  }




  export type ExamTypeGroupByArgs = {
    where?: examTypeWhereInput
    orderBy?: Enumerable<examTypeOrderByWithAggregationInput>
    by: Array<ExamTypeScalarFieldEnum>
    having?: examTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExamTypeCountAggregateInputType | true
    _avg?: ExamTypeAvgAggregateInputType
    _sum?: ExamTypeSumAggregateInputType
    _min?: ExamTypeMinAggregateInputType
    _max?: ExamTypeMaxAggregateInputType
  }


  export type ExamTypeGroupByOutputType = {
    id: number
    name: string
    definition: string
    published: boolean
    subjectId: number
    formId: number
    createdAt: Date
    updatedAt: Date
    _count: ExamTypeCountAggregateOutputType | null
    _avg: ExamTypeAvgAggregateOutputType | null
    _sum: ExamTypeSumAggregateOutputType | null
    _min: ExamTypeMinAggregateOutputType | null
    _max: ExamTypeMaxAggregateOutputType | null
  }

  type GetExamTypeGroupByPayload<T extends ExamTypeGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ExamTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExamTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExamTypeGroupByOutputType[P]>
            : GetScalarType<T[P], ExamTypeGroupByOutputType[P]>
        }
      >
    >


  export type examTypeSelect = {
    id?: boolean
    name?: boolean
    definition?: boolean
    published?: boolean
    subjectId?: boolean
    formId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    formExams?: boolean | formExamsArgs
    subjectExams?: boolean | subjectExamsArgs
    exam?: boolean | examFindManyArgs
    _count?: boolean | ExamTypeCountOutputTypeArgs
  }

  export type examTypeInclude = {
    formExams?: boolean | formExamsArgs
    subjectExams?: boolean | subjectExamsArgs
    exam?: boolean | examFindManyArgs
    _count?: boolean | ExamTypeCountOutputTypeArgs
  }

  export type examTypeGetPayload<
    S extends boolean | null | undefined | examTypeArgs,
    U = keyof S
      > = S extends true
        ? examType
    : S extends undefined
    ? never
    : S extends examTypeArgs | examTypeFindManyArgs
    ?'include' extends U
    ? examType  & {
    [P in TrueKeys<S['include']>]:
        P extends 'formExams' ? formExamsGetPayload<S['include'][P]> :
        P extends 'subjectExams' ? subjectExamsGetPayload<S['include'][P]> :
        P extends 'exam' ? Array < examGetPayload<S['include'][P]>>  :
        P extends '_count' ? ExamTypeCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'formExams' ? formExamsGetPayload<S['select'][P]> :
        P extends 'subjectExams' ? subjectExamsGetPayload<S['select'][P]> :
        P extends 'exam' ? Array < examGetPayload<S['select'][P]>>  :
        P extends '_count' ? ExamTypeCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof examType ? examType[P] : never
  } 
    : examType
  : examType


  type examTypeCountArgs = Merge<
    Omit<examTypeFindManyArgs, 'select' | 'include'> & {
      select?: ExamTypeCountAggregateInputType | true
    }
  >

  export interface examTypeDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ExamType that matches the filter.
     * @param {examTypeFindUniqueArgs} args - Arguments to find a ExamType
     * @example
     * // Get one ExamType
     * const examType = await prisma.examType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends examTypeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, examTypeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'examType'> extends True ? CheckSelect<T, Prisma__examTypeClient<examType>, Prisma__examTypeClient<examTypeGetPayload<T>>> : CheckSelect<T, Prisma__examTypeClient<examType | null >, Prisma__examTypeClient<examTypeGetPayload<T> | null >>

    /**
     * Find the first ExamType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {examTypeFindFirstArgs} args - Arguments to find a ExamType
     * @example
     * // Get one ExamType
     * const examType = await prisma.examType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends examTypeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, examTypeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'examType'> extends True ? CheckSelect<T, Prisma__examTypeClient<examType>, Prisma__examTypeClient<examTypeGetPayload<T>>> : CheckSelect<T, Prisma__examTypeClient<examType | null >, Prisma__examTypeClient<examTypeGetPayload<T> | null >>

    /**
     * Find zero or more ExamTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {examTypeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExamTypes
     * const examTypes = await prisma.examType.findMany()
     * 
     * // Get first 10 ExamTypes
     * const examTypes = await prisma.examType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const examTypeWithIdOnly = await prisma.examType.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends examTypeFindManyArgs>(
      args?: SelectSubset<T, examTypeFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<examType>>, PrismaPromise<Array<examTypeGetPayload<T>>>>

    /**
     * Create a ExamType.
     * @param {examTypeCreateArgs} args - Arguments to create a ExamType.
     * @example
     * // Create one ExamType
     * const ExamType = await prisma.examType.create({
     *   data: {
     *     // ... data to create a ExamType
     *   }
     * })
     * 
    **/
    create<T extends examTypeCreateArgs>(
      args: SelectSubset<T, examTypeCreateArgs>
    ): CheckSelect<T, Prisma__examTypeClient<examType>, Prisma__examTypeClient<examTypeGetPayload<T>>>

    /**
     * Create many ExamTypes.
     *     @param {examTypeCreateManyArgs} args - Arguments to create many ExamTypes.
     *     @example
     *     // Create many ExamTypes
     *     const examType = await prisma.examType.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends examTypeCreateManyArgs>(
      args?: SelectSubset<T, examTypeCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ExamType.
     * @param {examTypeDeleteArgs} args - Arguments to delete one ExamType.
     * @example
     * // Delete one ExamType
     * const ExamType = await prisma.examType.delete({
     *   where: {
     *     // ... filter to delete one ExamType
     *   }
     * })
     * 
    **/
    delete<T extends examTypeDeleteArgs>(
      args: SelectSubset<T, examTypeDeleteArgs>
    ): CheckSelect<T, Prisma__examTypeClient<examType>, Prisma__examTypeClient<examTypeGetPayload<T>>>

    /**
     * Update one ExamType.
     * @param {examTypeUpdateArgs} args - Arguments to update one ExamType.
     * @example
     * // Update one ExamType
     * const examType = await prisma.examType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends examTypeUpdateArgs>(
      args: SelectSubset<T, examTypeUpdateArgs>
    ): CheckSelect<T, Prisma__examTypeClient<examType>, Prisma__examTypeClient<examTypeGetPayload<T>>>

    /**
     * Delete zero or more ExamTypes.
     * @param {examTypeDeleteManyArgs} args - Arguments to filter ExamTypes to delete.
     * @example
     * // Delete a few ExamTypes
     * const { count } = await prisma.examType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends examTypeDeleteManyArgs>(
      args?: SelectSubset<T, examTypeDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExamTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {examTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExamTypes
     * const examType = await prisma.examType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends examTypeUpdateManyArgs>(
      args: SelectSubset<T, examTypeUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ExamType.
     * @param {examTypeUpsertArgs} args - Arguments to update or create a ExamType.
     * @example
     * // Update or create a ExamType
     * const examType = await prisma.examType.upsert({
     *   create: {
     *     // ... data to create a ExamType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExamType we want to update
     *   }
     * })
    **/
    upsert<T extends examTypeUpsertArgs>(
      args: SelectSubset<T, examTypeUpsertArgs>
    ): CheckSelect<T, Prisma__examTypeClient<examType>, Prisma__examTypeClient<examTypeGetPayload<T>>>

    /**
     * Find one ExamType that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {examTypeFindUniqueOrThrowArgs} args - Arguments to find a ExamType
     * @example
     * // Get one ExamType
     * const examType = await prisma.examType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends examTypeFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, examTypeFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__examTypeClient<examType>, Prisma__examTypeClient<examTypeGetPayload<T>>>

    /**
     * Find the first ExamType that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {examTypeFindFirstOrThrowArgs} args - Arguments to find a ExamType
     * @example
     * // Get one ExamType
     * const examType = await prisma.examType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends examTypeFindFirstOrThrowArgs>(
      args?: SelectSubset<T, examTypeFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__examTypeClient<examType>, Prisma__examTypeClient<examTypeGetPayload<T>>>

    /**
     * Count the number of ExamTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {examTypeCountArgs} args - Arguments to filter ExamTypes to count.
     * @example
     * // Count the number of ExamTypes
     * const count = await prisma.examType.count({
     *   where: {
     *     // ... the filter for the ExamTypes we want to count
     *   }
     * })
    **/
    count<T extends examTypeCountArgs>(
      args?: Subset<T, examTypeCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExamTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExamType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExamTypeAggregateArgs>(args: Subset<T, ExamTypeAggregateArgs>): PrismaPromise<GetExamTypeAggregateType<T>>

    /**
     * Group by ExamType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExamTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExamTypeGroupByArgs['orderBy'] }
        : { orderBy?: ExamTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExamTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExamTypeGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for examType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__examTypeClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    formExams<T extends formExamsArgs = {}>(args?: Subset<T, formExamsArgs>): CheckSelect<T, Prisma__formExamsClient<formExams | null >, Prisma__formExamsClient<formExamsGetPayload<T> | null >>;

    subjectExams<T extends subjectExamsArgs = {}>(args?: Subset<T, subjectExamsArgs>): CheckSelect<T, Prisma__subjectExamsClient<subjectExams | null >, Prisma__subjectExamsClient<subjectExamsGetPayload<T> | null >>;

    exam<T extends examFindManyArgs = {}>(args?: Subset<T, examFindManyArgs>): CheckSelect<T, PrismaPromise<Array<exam>>, PrismaPromise<Array<examGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * examType base type for findUnique actions
   */
  export type examTypeFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the examType
     * 
    **/
    select?: examTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: examTypeInclude | null
    /**
     * Filter, which examType to fetch.
     * 
    **/
    where: examTypeWhereUniqueInput
  }

  /**
   * examType: findUnique
   */
  export interface examTypeFindUniqueArgs extends examTypeFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * examType base type for findFirst actions
   */
  export type examTypeFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the examType
     * 
    **/
    select?: examTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: examTypeInclude | null
    /**
     * Filter, which examType to fetch.
     * 
    **/
    where?: examTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of examTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<examTypeOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for examTypes.
     * 
    **/
    cursor?: examTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` examTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` examTypes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of examTypes.
     * 
    **/
    distinct?: Enumerable<ExamTypeScalarFieldEnum>
  }

  /**
   * examType: findFirst
   */
  export interface examTypeFindFirstArgs extends examTypeFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * examType findMany
   */
  export type examTypeFindManyArgs = {
    /**
     * Select specific fields to fetch from the examType
     * 
    **/
    select?: examTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: examTypeInclude | null
    /**
     * Filter, which examTypes to fetch.
     * 
    **/
    where?: examTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of examTypes to fetch.
     * 
    **/
    orderBy?: Enumerable<examTypeOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing examTypes.
     * 
    **/
    cursor?: examTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` examTypes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` examTypes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ExamTypeScalarFieldEnum>
  }


  /**
   * examType create
   */
  export type examTypeCreateArgs = {
    /**
     * Select specific fields to fetch from the examType
     * 
    **/
    select?: examTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: examTypeInclude | null
    /**
     * The data needed to create a examType.
     * 
    **/
    data: XOR<examTypeCreateInput, examTypeUncheckedCreateInput>
  }


  /**
   * examType createMany
   */
  export type examTypeCreateManyArgs = {
    /**
     * The data used to create many examTypes.
     * 
    **/
    data: Enumerable<examTypeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * examType update
   */
  export type examTypeUpdateArgs = {
    /**
     * Select specific fields to fetch from the examType
     * 
    **/
    select?: examTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: examTypeInclude | null
    /**
     * The data needed to update a examType.
     * 
    **/
    data: XOR<examTypeUpdateInput, examTypeUncheckedUpdateInput>
    /**
     * Choose, which examType to update.
     * 
    **/
    where: examTypeWhereUniqueInput
  }


  /**
   * examType updateMany
   */
  export type examTypeUpdateManyArgs = {
    /**
     * The data used to update examTypes.
     * 
    **/
    data: XOR<examTypeUpdateManyMutationInput, examTypeUncheckedUpdateManyInput>
    /**
     * Filter which examTypes to update
     * 
    **/
    where?: examTypeWhereInput
  }


  /**
   * examType upsert
   */
  export type examTypeUpsertArgs = {
    /**
     * Select specific fields to fetch from the examType
     * 
    **/
    select?: examTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: examTypeInclude | null
    /**
     * The filter to search for the examType to update in case it exists.
     * 
    **/
    where: examTypeWhereUniqueInput
    /**
     * In case the examType found by the `where` argument doesn't exist, create a new examType with this data.
     * 
    **/
    create: XOR<examTypeCreateInput, examTypeUncheckedCreateInput>
    /**
     * In case the examType was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<examTypeUpdateInput, examTypeUncheckedUpdateInput>
  }


  /**
   * examType delete
   */
  export type examTypeDeleteArgs = {
    /**
     * Select specific fields to fetch from the examType
     * 
    **/
    select?: examTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: examTypeInclude | null
    /**
     * Filter which examType to delete.
     * 
    **/
    where: examTypeWhereUniqueInput
  }


  /**
   * examType deleteMany
   */
  export type examTypeDeleteManyArgs = {
    /**
     * Filter which examTypes to delete
     * 
    **/
    where?: examTypeWhereInput
  }


  /**
   * examType: findUniqueOrThrow
   */
  export type examTypeFindUniqueOrThrowArgs = examTypeFindUniqueArgsBase
      

  /**
   * examType: findFirstOrThrow
   */
  export type examTypeFindFirstOrThrowArgs = examTypeFindFirstArgsBase
      

  /**
   * examType without action
   */
  export type examTypeArgs = {
    /**
     * Select specific fields to fetch from the examType
     * 
    **/
    select?: examTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: examTypeInclude | null
  }



  /**
   * Model exam
   */


  export type AggregateExam = {
    _count: ExamCountAggregateOutputType | null
    _avg: ExamAvgAggregateOutputType | null
    _sum: ExamSumAggregateOutputType | null
    _min: ExamMinAggregateOutputType | null
    _max: ExamMaxAggregateOutputType | null
  }

  export type ExamAvgAggregateOutputType = {
    id: number | null
    year: number | null
    examTypeId: number | null
    usersId: number | null
  }

  export type ExamSumAggregateOutputType = {
    id: number | null
    year: number | null
    examTypeId: number | null
    usersId: number | null
  }

  export type ExamMinAggregateOutputType = {
    id: number | null
    description: string | null
    year: number | null
    hasAnswers: boolean | null
    published: boolean | null
    examTypeId: number | null
    exam: string | null
    usersId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExamMaxAggregateOutputType = {
    id: number | null
    description: string | null
    year: number | null
    hasAnswers: boolean | null
    published: boolean | null
    examTypeId: number | null
    exam: string | null
    usersId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExamCountAggregateOutputType = {
    id: number
    description: number
    year: number
    hasAnswers: number
    published: number
    examTypeId: number
    exam: number
    usersId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExamAvgAggregateInputType = {
    id?: true
    year?: true
    examTypeId?: true
    usersId?: true
  }

  export type ExamSumAggregateInputType = {
    id?: true
    year?: true
    examTypeId?: true
    usersId?: true
  }

  export type ExamMinAggregateInputType = {
    id?: true
    description?: true
    year?: true
    hasAnswers?: true
    published?: true
    examTypeId?: true
    exam?: true
    usersId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExamMaxAggregateInputType = {
    id?: true
    description?: true
    year?: true
    hasAnswers?: true
    published?: true
    examTypeId?: true
    exam?: true
    usersId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExamCountAggregateInputType = {
    id?: true
    description?: true
    year?: true
    hasAnswers?: true
    published?: true
    examTypeId?: true
    exam?: true
    usersId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExamAggregateArgs = {
    /**
     * Filter which exam to aggregate.
     * 
    **/
    where?: examWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of exams to fetch.
     * 
    **/
    orderBy?: Enumerable<examOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: examWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` exams from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` exams.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned exams
    **/
    _count?: true | ExamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExamAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExamSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExamMaxAggregateInputType
  }

  export type GetExamAggregateType<T extends ExamAggregateArgs> = {
        [P in keyof T & keyof AggregateExam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExam[P]>
      : GetScalarType<T[P], AggregateExam[P]>
  }




  export type ExamGroupByArgs = {
    where?: examWhereInput
    orderBy?: Enumerable<examOrderByWithAggregationInput>
    by: Array<ExamScalarFieldEnum>
    having?: examScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExamCountAggregateInputType | true
    _avg?: ExamAvgAggregateInputType
    _sum?: ExamSumAggregateInputType
    _min?: ExamMinAggregateInputType
    _max?: ExamMaxAggregateInputType
  }


  export type ExamGroupByOutputType = {
    id: number
    description: string
    year: number
    hasAnswers: boolean
    published: boolean
    examTypeId: number
    exam: string
    usersId: number
    createdAt: Date
    updatedAt: Date
    _count: ExamCountAggregateOutputType | null
    _avg: ExamAvgAggregateOutputType | null
    _sum: ExamSumAggregateOutputType | null
    _min: ExamMinAggregateOutputType | null
    _max: ExamMaxAggregateOutputType | null
  }

  type GetExamGroupByPayload<T extends ExamGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ExamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExamGroupByOutputType[P]>
            : GetScalarType<T[P], ExamGroupByOutputType[P]>
        }
      >
    >


  export type examSelect = {
    id?: boolean
    description?: boolean
    year?: boolean
    hasAnswers?: boolean
    published?: boolean
    examTypeId?: boolean
    exam?: boolean
    usersId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    examType?: boolean | examTypeArgs
    users?: boolean | usersArgs
    examDownloadable?: boolean | examDownloadableFindManyArgs
    _count?: boolean | ExamCountOutputTypeArgs
  }

  export type examInclude = {
    examType?: boolean | examTypeArgs
    users?: boolean | usersArgs
    examDownloadable?: boolean | examDownloadableFindManyArgs
    _count?: boolean | ExamCountOutputTypeArgs
  }

  export type examGetPayload<
    S extends boolean | null | undefined | examArgs,
    U = keyof S
      > = S extends true
        ? exam
    : S extends undefined
    ? never
    : S extends examArgs | examFindManyArgs
    ?'include' extends U
    ? exam  & {
    [P in TrueKeys<S['include']>]:
        P extends 'examType' ? examTypeGetPayload<S['include'][P]> :
        P extends 'users' ? usersGetPayload<S['include'][P]> :
        P extends 'examDownloadable' ? Array < examDownloadableGetPayload<S['include'][P]>>  :
        P extends '_count' ? ExamCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'examType' ? examTypeGetPayload<S['select'][P]> :
        P extends 'users' ? usersGetPayload<S['select'][P]> :
        P extends 'examDownloadable' ? Array < examDownloadableGetPayload<S['select'][P]>>  :
        P extends '_count' ? ExamCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof exam ? exam[P] : never
  } 
    : exam
  : exam


  type examCountArgs = Merge<
    Omit<examFindManyArgs, 'select' | 'include'> & {
      select?: ExamCountAggregateInputType | true
    }
  >

  export interface examDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Exam that matches the filter.
     * @param {examFindUniqueArgs} args - Arguments to find a Exam
     * @example
     * // Get one Exam
     * const exam = await prisma.exam.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends examFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, examFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'exam'> extends True ? CheckSelect<T, Prisma__examClient<exam>, Prisma__examClient<examGetPayload<T>>> : CheckSelect<T, Prisma__examClient<exam | null >, Prisma__examClient<examGetPayload<T> | null >>

    /**
     * Find the first Exam that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {examFindFirstArgs} args - Arguments to find a Exam
     * @example
     * // Get one Exam
     * const exam = await prisma.exam.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends examFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, examFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'exam'> extends True ? CheckSelect<T, Prisma__examClient<exam>, Prisma__examClient<examGetPayload<T>>> : CheckSelect<T, Prisma__examClient<exam | null >, Prisma__examClient<examGetPayload<T> | null >>

    /**
     * Find zero or more Exams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {examFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Exams
     * const exams = await prisma.exam.findMany()
     * 
     * // Get first 10 Exams
     * const exams = await prisma.exam.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const examWithIdOnly = await prisma.exam.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends examFindManyArgs>(
      args?: SelectSubset<T, examFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<exam>>, PrismaPromise<Array<examGetPayload<T>>>>

    /**
     * Create a Exam.
     * @param {examCreateArgs} args - Arguments to create a Exam.
     * @example
     * // Create one Exam
     * const Exam = await prisma.exam.create({
     *   data: {
     *     // ... data to create a Exam
     *   }
     * })
     * 
    **/
    create<T extends examCreateArgs>(
      args: SelectSubset<T, examCreateArgs>
    ): CheckSelect<T, Prisma__examClient<exam>, Prisma__examClient<examGetPayload<T>>>

    /**
     * Create many Exams.
     *     @param {examCreateManyArgs} args - Arguments to create many Exams.
     *     @example
     *     // Create many Exams
     *     const exam = await prisma.exam.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends examCreateManyArgs>(
      args?: SelectSubset<T, examCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Exam.
     * @param {examDeleteArgs} args - Arguments to delete one Exam.
     * @example
     * // Delete one Exam
     * const Exam = await prisma.exam.delete({
     *   where: {
     *     // ... filter to delete one Exam
     *   }
     * })
     * 
    **/
    delete<T extends examDeleteArgs>(
      args: SelectSubset<T, examDeleteArgs>
    ): CheckSelect<T, Prisma__examClient<exam>, Prisma__examClient<examGetPayload<T>>>

    /**
     * Update one Exam.
     * @param {examUpdateArgs} args - Arguments to update one Exam.
     * @example
     * // Update one Exam
     * const exam = await prisma.exam.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends examUpdateArgs>(
      args: SelectSubset<T, examUpdateArgs>
    ): CheckSelect<T, Prisma__examClient<exam>, Prisma__examClient<examGetPayload<T>>>

    /**
     * Delete zero or more Exams.
     * @param {examDeleteManyArgs} args - Arguments to filter Exams to delete.
     * @example
     * // Delete a few Exams
     * const { count } = await prisma.exam.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends examDeleteManyArgs>(
      args?: SelectSubset<T, examDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Exams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {examUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Exams
     * const exam = await prisma.exam.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends examUpdateManyArgs>(
      args: SelectSubset<T, examUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Exam.
     * @param {examUpsertArgs} args - Arguments to update or create a Exam.
     * @example
     * // Update or create a Exam
     * const exam = await prisma.exam.upsert({
     *   create: {
     *     // ... data to create a Exam
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Exam we want to update
     *   }
     * })
    **/
    upsert<T extends examUpsertArgs>(
      args: SelectSubset<T, examUpsertArgs>
    ): CheckSelect<T, Prisma__examClient<exam>, Prisma__examClient<examGetPayload<T>>>

    /**
     * Find one Exam that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {examFindUniqueOrThrowArgs} args - Arguments to find a Exam
     * @example
     * // Get one Exam
     * const exam = await prisma.exam.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends examFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, examFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__examClient<exam>, Prisma__examClient<examGetPayload<T>>>

    /**
     * Find the first Exam that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {examFindFirstOrThrowArgs} args - Arguments to find a Exam
     * @example
     * // Get one Exam
     * const exam = await prisma.exam.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends examFindFirstOrThrowArgs>(
      args?: SelectSubset<T, examFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__examClient<exam>, Prisma__examClient<examGetPayload<T>>>

    /**
     * Count the number of Exams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {examCountArgs} args - Arguments to filter Exams to count.
     * @example
     * // Count the number of Exams
     * const count = await prisma.exam.count({
     *   where: {
     *     // ... the filter for the Exams we want to count
     *   }
     * })
    **/
    count<T extends examCountArgs>(
      args?: Subset<T, examCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Exam.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExamAggregateArgs>(args: Subset<T, ExamAggregateArgs>): PrismaPromise<GetExamAggregateType<T>>

    /**
     * Group by Exam.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExamGroupByArgs['orderBy'] }
        : { orderBy?: ExamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExamGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for exam.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__examClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    examType<T extends examTypeArgs = {}>(args?: Subset<T, examTypeArgs>): CheckSelect<T, Prisma__examTypeClient<examType | null >, Prisma__examTypeClient<examTypeGetPayload<T> | null >>;

    users<T extends usersArgs = {}>(args?: Subset<T, usersArgs>): CheckSelect<T, Prisma__usersClient<users | null >, Prisma__usersClient<usersGetPayload<T> | null >>;

    examDownloadable<T extends examDownloadableFindManyArgs = {}>(args?: Subset<T, examDownloadableFindManyArgs>): CheckSelect<T, PrismaPromise<Array<examDownloadable>>, PrismaPromise<Array<examDownloadableGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * exam base type for findUnique actions
   */
  export type examFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the exam
     * 
    **/
    select?: examSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: examInclude | null
    /**
     * Filter, which exam to fetch.
     * 
    **/
    where: examWhereUniqueInput
  }

  /**
   * exam: findUnique
   */
  export interface examFindUniqueArgs extends examFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * exam base type for findFirst actions
   */
  export type examFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the exam
     * 
    **/
    select?: examSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: examInclude | null
    /**
     * Filter, which exam to fetch.
     * 
    **/
    where?: examWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of exams to fetch.
     * 
    **/
    orderBy?: Enumerable<examOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for exams.
     * 
    **/
    cursor?: examWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` exams from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` exams.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of exams.
     * 
    **/
    distinct?: Enumerable<ExamScalarFieldEnum>
  }

  /**
   * exam: findFirst
   */
  export interface examFindFirstArgs extends examFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * exam findMany
   */
  export type examFindManyArgs = {
    /**
     * Select specific fields to fetch from the exam
     * 
    **/
    select?: examSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: examInclude | null
    /**
     * Filter, which exams to fetch.
     * 
    **/
    where?: examWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of exams to fetch.
     * 
    **/
    orderBy?: Enumerable<examOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing exams.
     * 
    **/
    cursor?: examWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` exams from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` exams.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ExamScalarFieldEnum>
  }


  /**
   * exam create
   */
  export type examCreateArgs = {
    /**
     * Select specific fields to fetch from the exam
     * 
    **/
    select?: examSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: examInclude | null
    /**
     * The data needed to create a exam.
     * 
    **/
    data: XOR<examCreateInput, examUncheckedCreateInput>
  }


  /**
   * exam createMany
   */
  export type examCreateManyArgs = {
    /**
     * The data used to create many exams.
     * 
    **/
    data: Enumerable<examCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * exam update
   */
  export type examUpdateArgs = {
    /**
     * Select specific fields to fetch from the exam
     * 
    **/
    select?: examSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: examInclude | null
    /**
     * The data needed to update a exam.
     * 
    **/
    data: XOR<examUpdateInput, examUncheckedUpdateInput>
    /**
     * Choose, which exam to update.
     * 
    **/
    where: examWhereUniqueInput
  }


  /**
   * exam updateMany
   */
  export type examUpdateManyArgs = {
    /**
     * The data used to update exams.
     * 
    **/
    data: XOR<examUpdateManyMutationInput, examUncheckedUpdateManyInput>
    /**
     * Filter which exams to update
     * 
    **/
    where?: examWhereInput
  }


  /**
   * exam upsert
   */
  export type examUpsertArgs = {
    /**
     * Select specific fields to fetch from the exam
     * 
    **/
    select?: examSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: examInclude | null
    /**
     * The filter to search for the exam to update in case it exists.
     * 
    **/
    where: examWhereUniqueInput
    /**
     * In case the exam found by the `where` argument doesn't exist, create a new exam with this data.
     * 
    **/
    create: XOR<examCreateInput, examUncheckedCreateInput>
    /**
     * In case the exam was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<examUpdateInput, examUncheckedUpdateInput>
  }


  /**
   * exam delete
   */
  export type examDeleteArgs = {
    /**
     * Select specific fields to fetch from the exam
     * 
    **/
    select?: examSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: examInclude | null
    /**
     * Filter which exam to delete.
     * 
    **/
    where: examWhereUniqueInput
  }


  /**
   * exam deleteMany
   */
  export type examDeleteManyArgs = {
    /**
     * Filter which exams to delete
     * 
    **/
    where?: examWhereInput
  }


  /**
   * exam: findUniqueOrThrow
   */
  export type examFindUniqueOrThrowArgs = examFindUniqueArgsBase
      

  /**
   * exam: findFirstOrThrow
   */
  export type examFindFirstOrThrowArgs = examFindFirstArgsBase
      

  /**
   * exam without action
   */
  export type examArgs = {
    /**
     * Select specific fields to fetch from the exam
     * 
    **/
    select?: examSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: examInclude | null
  }



  /**
   * Model examDownloadable
   */


  export type AggregateExamDownloadable = {
    _count: ExamDownloadableCountAggregateOutputType | null
    _avg: ExamDownloadableAvgAggregateOutputType | null
    _sum: ExamDownloadableSumAggregateOutputType | null
    _min: ExamDownloadableMinAggregateOutputType | null
    _max: ExamDownloadableMaxAggregateOutputType | null
  }

  export type ExamDownloadableAvgAggregateOutputType = {
    id: number | null
    examId: number | null
    usersId: number | null
  }

  export type ExamDownloadableSumAggregateOutputType = {
    id: number | null
    examId: number | null
    usersId: number | null
  }

  export type ExamDownloadableMinAggregateOutputType = {
    id: number | null
    link: string | null
    fileExtension: string | null
    published: boolean | null
    examId: number | null
    usersId: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExamDownloadableMaxAggregateOutputType = {
    id: number | null
    link: string | null
    fileExtension: string | null
    published: boolean | null
    examId: number | null
    usersId: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExamDownloadableCountAggregateOutputType = {
    id: number
    link: number
    fileExtension: number
    published: number
    examId: number
    usersId: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExamDownloadableAvgAggregateInputType = {
    id?: true
    examId?: true
    usersId?: true
  }

  export type ExamDownloadableSumAggregateInputType = {
    id?: true
    examId?: true
    usersId?: true
  }

  export type ExamDownloadableMinAggregateInputType = {
    id?: true
    link?: true
    fileExtension?: true
    published?: true
    examId?: true
    usersId?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExamDownloadableMaxAggregateInputType = {
    id?: true
    link?: true
    fileExtension?: true
    published?: true
    examId?: true
    usersId?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExamDownloadableCountAggregateInputType = {
    id?: true
    link?: true
    fileExtension?: true
    published?: true
    examId?: true
    usersId?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExamDownloadableAggregateArgs = {
    /**
     * Filter which examDownloadable to aggregate.
     * 
    **/
    where?: examDownloadableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of examDownloadables to fetch.
     * 
    **/
    orderBy?: Enumerable<examDownloadableOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: examDownloadableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` examDownloadables from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` examDownloadables.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned examDownloadables
    **/
    _count?: true | ExamDownloadableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExamDownloadableAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExamDownloadableSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExamDownloadableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExamDownloadableMaxAggregateInputType
  }

  export type GetExamDownloadableAggregateType<T extends ExamDownloadableAggregateArgs> = {
        [P in keyof T & keyof AggregateExamDownloadable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExamDownloadable[P]>
      : GetScalarType<T[P], AggregateExamDownloadable[P]>
  }




  export type ExamDownloadableGroupByArgs = {
    where?: examDownloadableWhereInput
    orderBy?: Enumerable<examDownloadableOrderByWithAggregationInput>
    by: Array<ExamDownloadableScalarFieldEnum>
    having?: examDownloadableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExamDownloadableCountAggregateInputType | true
    _avg?: ExamDownloadableAvgAggregateInputType
    _sum?: ExamDownloadableSumAggregateInputType
    _min?: ExamDownloadableMinAggregateInputType
    _max?: ExamDownloadableMaxAggregateInputType
  }


  export type ExamDownloadableGroupByOutputType = {
    id: number
    link: string
    fileExtension: string
    published: boolean
    examId: number
    usersId: number
    name: string
    createdAt: Date
    updatedAt: Date
    _count: ExamDownloadableCountAggregateOutputType | null
    _avg: ExamDownloadableAvgAggregateOutputType | null
    _sum: ExamDownloadableSumAggregateOutputType | null
    _min: ExamDownloadableMinAggregateOutputType | null
    _max: ExamDownloadableMaxAggregateOutputType | null
  }

  type GetExamDownloadableGroupByPayload<T extends ExamDownloadableGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ExamDownloadableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExamDownloadableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExamDownloadableGroupByOutputType[P]>
            : GetScalarType<T[P], ExamDownloadableGroupByOutputType[P]>
        }
      >
    >


  export type examDownloadableSelect = {
    id?: boolean
    link?: boolean
    fileExtension?: boolean
    published?: boolean
    examId?: boolean
    usersId?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    exam?: boolean | examArgs
    users?: boolean | usersArgs
  }

  export type examDownloadableInclude = {
    exam?: boolean | examArgs
    users?: boolean | usersArgs
  }

  export type examDownloadableGetPayload<
    S extends boolean | null | undefined | examDownloadableArgs,
    U = keyof S
      > = S extends true
        ? examDownloadable
    : S extends undefined
    ? never
    : S extends examDownloadableArgs | examDownloadableFindManyArgs
    ?'include' extends U
    ? examDownloadable  & {
    [P in TrueKeys<S['include']>]:
        P extends 'exam' ? examGetPayload<S['include'][P]> :
        P extends 'users' ? usersGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'exam' ? examGetPayload<S['select'][P]> :
        P extends 'users' ? usersGetPayload<S['select'][P]> :  P extends keyof examDownloadable ? examDownloadable[P] : never
  } 
    : examDownloadable
  : examDownloadable


  type examDownloadableCountArgs = Merge<
    Omit<examDownloadableFindManyArgs, 'select' | 'include'> & {
      select?: ExamDownloadableCountAggregateInputType | true
    }
  >

  export interface examDownloadableDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ExamDownloadable that matches the filter.
     * @param {examDownloadableFindUniqueArgs} args - Arguments to find a ExamDownloadable
     * @example
     * // Get one ExamDownloadable
     * const examDownloadable = await prisma.examDownloadable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends examDownloadableFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, examDownloadableFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'examDownloadable'> extends True ? CheckSelect<T, Prisma__examDownloadableClient<examDownloadable>, Prisma__examDownloadableClient<examDownloadableGetPayload<T>>> : CheckSelect<T, Prisma__examDownloadableClient<examDownloadable | null >, Prisma__examDownloadableClient<examDownloadableGetPayload<T> | null >>

    /**
     * Find the first ExamDownloadable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {examDownloadableFindFirstArgs} args - Arguments to find a ExamDownloadable
     * @example
     * // Get one ExamDownloadable
     * const examDownloadable = await prisma.examDownloadable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends examDownloadableFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, examDownloadableFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'examDownloadable'> extends True ? CheckSelect<T, Prisma__examDownloadableClient<examDownloadable>, Prisma__examDownloadableClient<examDownloadableGetPayload<T>>> : CheckSelect<T, Prisma__examDownloadableClient<examDownloadable | null >, Prisma__examDownloadableClient<examDownloadableGetPayload<T> | null >>

    /**
     * Find zero or more ExamDownloadables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {examDownloadableFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExamDownloadables
     * const examDownloadables = await prisma.examDownloadable.findMany()
     * 
     * // Get first 10 ExamDownloadables
     * const examDownloadables = await prisma.examDownloadable.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const examDownloadableWithIdOnly = await prisma.examDownloadable.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends examDownloadableFindManyArgs>(
      args?: SelectSubset<T, examDownloadableFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<examDownloadable>>, PrismaPromise<Array<examDownloadableGetPayload<T>>>>

    /**
     * Create a ExamDownloadable.
     * @param {examDownloadableCreateArgs} args - Arguments to create a ExamDownloadable.
     * @example
     * // Create one ExamDownloadable
     * const ExamDownloadable = await prisma.examDownloadable.create({
     *   data: {
     *     // ... data to create a ExamDownloadable
     *   }
     * })
     * 
    **/
    create<T extends examDownloadableCreateArgs>(
      args: SelectSubset<T, examDownloadableCreateArgs>
    ): CheckSelect<T, Prisma__examDownloadableClient<examDownloadable>, Prisma__examDownloadableClient<examDownloadableGetPayload<T>>>

    /**
     * Create many ExamDownloadables.
     *     @param {examDownloadableCreateManyArgs} args - Arguments to create many ExamDownloadables.
     *     @example
     *     // Create many ExamDownloadables
     *     const examDownloadable = await prisma.examDownloadable.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends examDownloadableCreateManyArgs>(
      args?: SelectSubset<T, examDownloadableCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ExamDownloadable.
     * @param {examDownloadableDeleteArgs} args - Arguments to delete one ExamDownloadable.
     * @example
     * // Delete one ExamDownloadable
     * const ExamDownloadable = await prisma.examDownloadable.delete({
     *   where: {
     *     // ... filter to delete one ExamDownloadable
     *   }
     * })
     * 
    **/
    delete<T extends examDownloadableDeleteArgs>(
      args: SelectSubset<T, examDownloadableDeleteArgs>
    ): CheckSelect<T, Prisma__examDownloadableClient<examDownloadable>, Prisma__examDownloadableClient<examDownloadableGetPayload<T>>>

    /**
     * Update one ExamDownloadable.
     * @param {examDownloadableUpdateArgs} args - Arguments to update one ExamDownloadable.
     * @example
     * // Update one ExamDownloadable
     * const examDownloadable = await prisma.examDownloadable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends examDownloadableUpdateArgs>(
      args: SelectSubset<T, examDownloadableUpdateArgs>
    ): CheckSelect<T, Prisma__examDownloadableClient<examDownloadable>, Prisma__examDownloadableClient<examDownloadableGetPayload<T>>>

    /**
     * Delete zero or more ExamDownloadables.
     * @param {examDownloadableDeleteManyArgs} args - Arguments to filter ExamDownloadables to delete.
     * @example
     * // Delete a few ExamDownloadables
     * const { count } = await prisma.examDownloadable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends examDownloadableDeleteManyArgs>(
      args?: SelectSubset<T, examDownloadableDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExamDownloadables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {examDownloadableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExamDownloadables
     * const examDownloadable = await prisma.examDownloadable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends examDownloadableUpdateManyArgs>(
      args: SelectSubset<T, examDownloadableUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ExamDownloadable.
     * @param {examDownloadableUpsertArgs} args - Arguments to update or create a ExamDownloadable.
     * @example
     * // Update or create a ExamDownloadable
     * const examDownloadable = await prisma.examDownloadable.upsert({
     *   create: {
     *     // ... data to create a ExamDownloadable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExamDownloadable we want to update
     *   }
     * })
    **/
    upsert<T extends examDownloadableUpsertArgs>(
      args: SelectSubset<T, examDownloadableUpsertArgs>
    ): CheckSelect<T, Prisma__examDownloadableClient<examDownloadable>, Prisma__examDownloadableClient<examDownloadableGetPayload<T>>>

    /**
     * Find one ExamDownloadable that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {examDownloadableFindUniqueOrThrowArgs} args - Arguments to find a ExamDownloadable
     * @example
     * // Get one ExamDownloadable
     * const examDownloadable = await prisma.examDownloadable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends examDownloadableFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, examDownloadableFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__examDownloadableClient<examDownloadable>, Prisma__examDownloadableClient<examDownloadableGetPayload<T>>>

    /**
     * Find the first ExamDownloadable that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {examDownloadableFindFirstOrThrowArgs} args - Arguments to find a ExamDownloadable
     * @example
     * // Get one ExamDownloadable
     * const examDownloadable = await prisma.examDownloadable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends examDownloadableFindFirstOrThrowArgs>(
      args?: SelectSubset<T, examDownloadableFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__examDownloadableClient<examDownloadable>, Prisma__examDownloadableClient<examDownloadableGetPayload<T>>>

    /**
     * Count the number of ExamDownloadables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {examDownloadableCountArgs} args - Arguments to filter ExamDownloadables to count.
     * @example
     * // Count the number of ExamDownloadables
     * const count = await prisma.examDownloadable.count({
     *   where: {
     *     // ... the filter for the ExamDownloadables we want to count
     *   }
     * })
    **/
    count<T extends examDownloadableCountArgs>(
      args?: Subset<T, examDownloadableCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExamDownloadableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExamDownloadable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamDownloadableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExamDownloadableAggregateArgs>(args: Subset<T, ExamDownloadableAggregateArgs>): PrismaPromise<GetExamDownloadableAggregateType<T>>

    /**
     * Group by ExamDownloadable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamDownloadableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExamDownloadableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExamDownloadableGroupByArgs['orderBy'] }
        : { orderBy?: ExamDownloadableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExamDownloadableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExamDownloadableGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for examDownloadable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__examDownloadableClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    exam<T extends examArgs = {}>(args?: Subset<T, examArgs>): CheckSelect<T, Prisma__examClient<exam | null >, Prisma__examClient<examGetPayload<T> | null >>;

    users<T extends usersArgs = {}>(args?: Subset<T, usersArgs>): CheckSelect<T, Prisma__usersClient<users | null >, Prisma__usersClient<usersGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * examDownloadable base type for findUnique actions
   */
  export type examDownloadableFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the examDownloadable
     * 
    **/
    select?: examDownloadableSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: examDownloadableInclude | null
    /**
     * Filter, which examDownloadable to fetch.
     * 
    **/
    where: examDownloadableWhereUniqueInput
  }

  /**
   * examDownloadable: findUnique
   */
  export interface examDownloadableFindUniqueArgs extends examDownloadableFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * examDownloadable base type for findFirst actions
   */
  export type examDownloadableFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the examDownloadable
     * 
    **/
    select?: examDownloadableSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: examDownloadableInclude | null
    /**
     * Filter, which examDownloadable to fetch.
     * 
    **/
    where?: examDownloadableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of examDownloadables to fetch.
     * 
    **/
    orderBy?: Enumerable<examDownloadableOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for examDownloadables.
     * 
    **/
    cursor?: examDownloadableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` examDownloadables from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` examDownloadables.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of examDownloadables.
     * 
    **/
    distinct?: Enumerable<ExamDownloadableScalarFieldEnum>
  }

  /**
   * examDownloadable: findFirst
   */
  export interface examDownloadableFindFirstArgs extends examDownloadableFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * examDownloadable findMany
   */
  export type examDownloadableFindManyArgs = {
    /**
     * Select specific fields to fetch from the examDownloadable
     * 
    **/
    select?: examDownloadableSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: examDownloadableInclude | null
    /**
     * Filter, which examDownloadables to fetch.
     * 
    **/
    where?: examDownloadableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of examDownloadables to fetch.
     * 
    **/
    orderBy?: Enumerable<examDownloadableOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing examDownloadables.
     * 
    **/
    cursor?: examDownloadableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` examDownloadables from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` examDownloadables.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ExamDownloadableScalarFieldEnum>
  }


  /**
   * examDownloadable create
   */
  export type examDownloadableCreateArgs = {
    /**
     * Select specific fields to fetch from the examDownloadable
     * 
    **/
    select?: examDownloadableSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: examDownloadableInclude | null
    /**
     * The data needed to create a examDownloadable.
     * 
    **/
    data: XOR<examDownloadableCreateInput, examDownloadableUncheckedCreateInput>
  }


  /**
   * examDownloadable createMany
   */
  export type examDownloadableCreateManyArgs = {
    /**
     * The data used to create many examDownloadables.
     * 
    **/
    data: Enumerable<examDownloadableCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * examDownloadable update
   */
  export type examDownloadableUpdateArgs = {
    /**
     * Select specific fields to fetch from the examDownloadable
     * 
    **/
    select?: examDownloadableSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: examDownloadableInclude | null
    /**
     * The data needed to update a examDownloadable.
     * 
    **/
    data: XOR<examDownloadableUpdateInput, examDownloadableUncheckedUpdateInput>
    /**
     * Choose, which examDownloadable to update.
     * 
    **/
    where: examDownloadableWhereUniqueInput
  }


  /**
   * examDownloadable updateMany
   */
  export type examDownloadableUpdateManyArgs = {
    /**
     * The data used to update examDownloadables.
     * 
    **/
    data: XOR<examDownloadableUpdateManyMutationInput, examDownloadableUncheckedUpdateManyInput>
    /**
     * Filter which examDownloadables to update
     * 
    **/
    where?: examDownloadableWhereInput
  }


  /**
   * examDownloadable upsert
   */
  export type examDownloadableUpsertArgs = {
    /**
     * Select specific fields to fetch from the examDownloadable
     * 
    **/
    select?: examDownloadableSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: examDownloadableInclude | null
    /**
     * The filter to search for the examDownloadable to update in case it exists.
     * 
    **/
    where: examDownloadableWhereUniqueInput
    /**
     * In case the examDownloadable found by the `where` argument doesn't exist, create a new examDownloadable with this data.
     * 
    **/
    create: XOR<examDownloadableCreateInput, examDownloadableUncheckedCreateInput>
    /**
     * In case the examDownloadable was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<examDownloadableUpdateInput, examDownloadableUncheckedUpdateInput>
  }


  /**
   * examDownloadable delete
   */
  export type examDownloadableDeleteArgs = {
    /**
     * Select specific fields to fetch from the examDownloadable
     * 
    **/
    select?: examDownloadableSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: examDownloadableInclude | null
    /**
     * Filter which examDownloadable to delete.
     * 
    **/
    where: examDownloadableWhereUniqueInput
  }


  /**
   * examDownloadable deleteMany
   */
  export type examDownloadableDeleteManyArgs = {
    /**
     * Filter which examDownloadables to delete
     * 
    **/
    where?: examDownloadableWhereInput
  }


  /**
   * examDownloadable: findUniqueOrThrow
   */
  export type examDownloadableFindUniqueOrThrowArgs = examDownloadableFindUniqueArgsBase
      

  /**
   * examDownloadable: findFirstOrThrow
   */
  export type examDownloadableFindFirstOrThrowArgs = examDownloadableFindFirstArgsBase
      

  /**
   * examDownloadable without action
   */
  export type examDownloadableArgs = {
    /**
     * Select specific fields to fetch from the examDownloadable
     * 
    **/
    select?: examDownloadableSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: examDownloadableInclude | null
  }



  /**
   * Model subjectReference
   */


  export type AggregateSubjectReference = {
    _count: SubjectReferenceCountAggregateOutputType | null
    _avg: SubjectReferenceAvgAggregateOutputType | null
    _sum: SubjectReferenceSumAggregateOutputType | null
    _min: SubjectReferenceMinAggregateOutputType | null
    _max: SubjectReferenceMaxAggregateOutputType | null
  }

  export type SubjectReferenceAvgAggregateOutputType = {
    id: number | null
    usersId: number | null
  }

  export type SubjectReferenceSumAggregateOutputType = {
    id: number | null
    usersId: number | null
  }

  export type SubjectReferenceMinAggregateOutputType = {
    id: number | null
    subjectName: string | null
    subjectDefinition: string | null
    imageLocation: string | null
    published: boolean | null
    usersId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubjectReferenceMaxAggregateOutputType = {
    id: number | null
    subjectName: string | null
    subjectDefinition: string | null
    imageLocation: string | null
    published: boolean | null
    usersId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubjectReferenceCountAggregateOutputType = {
    id: number
    subjectName: number
    subjectDefinition: number
    imageLocation: number
    published: number
    usersId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubjectReferenceAvgAggregateInputType = {
    id?: true
    usersId?: true
  }

  export type SubjectReferenceSumAggregateInputType = {
    id?: true
    usersId?: true
  }

  export type SubjectReferenceMinAggregateInputType = {
    id?: true
    subjectName?: true
    subjectDefinition?: true
    imageLocation?: true
    published?: true
    usersId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubjectReferenceMaxAggregateInputType = {
    id?: true
    subjectName?: true
    subjectDefinition?: true
    imageLocation?: true
    published?: true
    usersId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubjectReferenceCountAggregateInputType = {
    id?: true
    subjectName?: true
    subjectDefinition?: true
    imageLocation?: true
    published?: true
    usersId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubjectReferenceAggregateArgs = {
    /**
     * Filter which subjectReference to aggregate.
     * 
    **/
    where?: subjectReferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subjectReferences to fetch.
     * 
    **/
    orderBy?: Enumerable<subjectReferenceOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: subjectReferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subjectReferences from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subjectReferences.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned subjectReferences
    **/
    _count?: true | SubjectReferenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubjectReferenceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubjectReferenceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubjectReferenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubjectReferenceMaxAggregateInputType
  }

  export type GetSubjectReferenceAggregateType<T extends SubjectReferenceAggregateArgs> = {
        [P in keyof T & keyof AggregateSubjectReference]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubjectReference[P]>
      : GetScalarType<T[P], AggregateSubjectReference[P]>
  }




  export type SubjectReferenceGroupByArgs = {
    where?: subjectReferenceWhereInput
    orderBy?: Enumerable<subjectReferenceOrderByWithAggregationInput>
    by: Array<SubjectReferenceScalarFieldEnum>
    having?: subjectReferenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubjectReferenceCountAggregateInputType | true
    _avg?: SubjectReferenceAvgAggregateInputType
    _sum?: SubjectReferenceSumAggregateInputType
    _min?: SubjectReferenceMinAggregateInputType
    _max?: SubjectReferenceMaxAggregateInputType
  }


  export type SubjectReferenceGroupByOutputType = {
    id: number
    subjectName: string
    subjectDefinition: string
    imageLocation: string | null
    published: boolean
    usersId: number
    createdAt: Date
    updatedAt: Date
    _count: SubjectReferenceCountAggregateOutputType | null
    _avg: SubjectReferenceAvgAggregateOutputType | null
    _sum: SubjectReferenceSumAggregateOutputType | null
    _min: SubjectReferenceMinAggregateOutputType | null
    _max: SubjectReferenceMaxAggregateOutputType | null
  }

  type GetSubjectReferenceGroupByPayload<T extends SubjectReferenceGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SubjectReferenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubjectReferenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubjectReferenceGroupByOutputType[P]>
            : GetScalarType<T[P], SubjectReferenceGroupByOutputType[P]>
        }
      >
    >


  export type subjectReferenceSelect = {
    id?: boolean
    subjectName?: boolean
    subjectDefinition?: boolean
    imageLocation?: boolean
    published?: boolean
    usersId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | usersArgs
    reference?: boolean | referenceFindManyArgs
    forms?: boolean | formReferenceFindManyArgs
    _count?: boolean | SubjectReferenceCountOutputTypeArgs
  }

  export type subjectReferenceInclude = {
    users?: boolean | usersArgs
    reference?: boolean | referenceFindManyArgs
    forms?: boolean | formReferenceFindManyArgs
    _count?: boolean | SubjectReferenceCountOutputTypeArgs
  }

  export type subjectReferenceGetPayload<
    S extends boolean | null | undefined | subjectReferenceArgs,
    U = keyof S
      > = S extends true
        ? subjectReference
    : S extends undefined
    ? never
    : S extends subjectReferenceArgs | subjectReferenceFindManyArgs
    ?'include' extends U
    ? subjectReference  & {
    [P in TrueKeys<S['include']>]:
        P extends 'users' ? usersGetPayload<S['include'][P]> :
        P extends 'reference' ? Array < referenceGetPayload<S['include'][P]>>  :
        P extends 'forms' ? Array < formReferenceGetPayload<S['include'][P]>>  :
        P extends '_count' ? SubjectReferenceCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'users' ? usersGetPayload<S['select'][P]> :
        P extends 'reference' ? Array < referenceGetPayload<S['select'][P]>>  :
        P extends 'forms' ? Array < formReferenceGetPayload<S['select'][P]>>  :
        P extends '_count' ? SubjectReferenceCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof subjectReference ? subjectReference[P] : never
  } 
    : subjectReference
  : subjectReference


  type subjectReferenceCountArgs = Merge<
    Omit<subjectReferenceFindManyArgs, 'select' | 'include'> & {
      select?: SubjectReferenceCountAggregateInputType | true
    }
  >

  export interface subjectReferenceDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one SubjectReference that matches the filter.
     * @param {subjectReferenceFindUniqueArgs} args - Arguments to find a SubjectReference
     * @example
     * // Get one SubjectReference
     * const subjectReference = await prisma.subjectReference.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends subjectReferenceFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, subjectReferenceFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'subjectReference'> extends True ? CheckSelect<T, Prisma__subjectReferenceClient<subjectReference>, Prisma__subjectReferenceClient<subjectReferenceGetPayload<T>>> : CheckSelect<T, Prisma__subjectReferenceClient<subjectReference | null >, Prisma__subjectReferenceClient<subjectReferenceGetPayload<T> | null >>

    /**
     * Find the first SubjectReference that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subjectReferenceFindFirstArgs} args - Arguments to find a SubjectReference
     * @example
     * // Get one SubjectReference
     * const subjectReference = await prisma.subjectReference.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends subjectReferenceFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, subjectReferenceFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'subjectReference'> extends True ? CheckSelect<T, Prisma__subjectReferenceClient<subjectReference>, Prisma__subjectReferenceClient<subjectReferenceGetPayload<T>>> : CheckSelect<T, Prisma__subjectReferenceClient<subjectReference | null >, Prisma__subjectReferenceClient<subjectReferenceGetPayload<T> | null >>

    /**
     * Find zero or more SubjectReferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subjectReferenceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubjectReferences
     * const subjectReferences = await prisma.subjectReference.findMany()
     * 
     * // Get first 10 SubjectReferences
     * const subjectReferences = await prisma.subjectReference.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subjectReferenceWithIdOnly = await prisma.subjectReference.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends subjectReferenceFindManyArgs>(
      args?: SelectSubset<T, subjectReferenceFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<subjectReference>>, PrismaPromise<Array<subjectReferenceGetPayload<T>>>>

    /**
     * Create a SubjectReference.
     * @param {subjectReferenceCreateArgs} args - Arguments to create a SubjectReference.
     * @example
     * // Create one SubjectReference
     * const SubjectReference = await prisma.subjectReference.create({
     *   data: {
     *     // ... data to create a SubjectReference
     *   }
     * })
     * 
    **/
    create<T extends subjectReferenceCreateArgs>(
      args: SelectSubset<T, subjectReferenceCreateArgs>
    ): CheckSelect<T, Prisma__subjectReferenceClient<subjectReference>, Prisma__subjectReferenceClient<subjectReferenceGetPayload<T>>>

    /**
     * Create many SubjectReferences.
     *     @param {subjectReferenceCreateManyArgs} args - Arguments to create many SubjectReferences.
     *     @example
     *     // Create many SubjectReferences
     *     const subjectReference = await prisma.subjectReference.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends subjectReferenceCreateManyArgs>(
      args?: SelectSubset<T, subjectReferenceCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a SubjectReference.
     * @param {subjectReferenceDeleteArgs} args - Arguments to delete one SubjectReference.
     * @example
     * // Delete one SubjectReference
     * const SubjectReference = await prisma.subjectReference.delete({
     *   where: {
     *     // ... filter to delete one SubjectReference
     *   }
     * })
     * 
    **/
    delete<T extends subjectReferenceDeleteArgs>(
      args: SelectSubset<T, subjectReferenceDeleteArgs>
    ): CheckSelect<T, Prisma__subjectReferenceClient<subjectReference>, Prisma__subjectReferenceClient<subjectReferenceGetPayload<T>>>

    /**
     * Update one SubjectReference.
     * @param {subjectReferenceUpdateArgs} args - Arguments to update one SubjectReference.
     * @example
     * // Update one SubjectReference
     * const subjectReference = await prisma.subjectReference.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends subjectReferenceUpdateArgs>(
      args: SelectSubset<T, subjectReferenceUpdateArgs>
    ): CheckSelect<T, Prisma__subjectReferenceClient<subjectReference>, Prisma__subjectReferenceClient<subjectReferenceGetPayload<T>>>

    /**
     * Delete zero or more SubjectReferences.
     * @param {subjectReferenceDeleteManyArgs} args - Arguments to filter SubjectReferences to delete.
     * @example
     * // Delete a few SubjectReferences
     * const { count } = await prisma.subjectReference.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends subjectReferenceDeleteManyArgs>(
      args?: SelectSubset<T, subjectReferenceDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubjectReferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subjectReferenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubjectReferences
     * const subjectReference = await prisma.subjectReference.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends subjectReferenceUpdateManyArgs>(
      args: SelectSubset<T, subjectReferenceUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one SubjectReference.
     * @param {subjectReferenceUpsertArgs} args - Arguments to update or create a SubjectReference.
     * @example
     * // Update or create a SubjectReference
     * const subjectReference = await prisma.subjectReference.upsert({
     *   create: {
     *     // ... data to create a SubjectReference
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubjectReference we want to update
     *   }
     * })
    **/
    upsert<T extends subjectReferenceUpsertArgs>(
      args: SelectSubset<T, subjectReferenceUpsertArgs>
    ): CheckSelect<T, Prisma__subjectReferenceClient<subjectReference>, Prisma__subjectReferenceClient<subjectReferenceGetPayload<T>>>

    /**
     * Find one SubjectReference that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {subjectReferenceFindUniqueOrThrowArgs} args - Arguments to find a SubjectReference
     * @example
     * // Get one SubjectReference
     * const subjectReference = await prisma.subjectReference.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends subjectReferenceFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, subjectReferenceFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__subjectReferenceClient<subjectReference>, Prisma__subjectReferenceClient<subjectReferenceGetPayload<T>>>

    /**
     * Find the first SubjectReference that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subjectReferenceFindFirstOrThrowArgs} args - Arguments to find a SubjectReference
     * @example
     * // Get one SubjectReference
     * const subjectReference = await prisma.subjectReference.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends subjectReferenceFindFirstOrThrowArgs>(
      args?: SelectSubset<T, subjectReferenceFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__subjectReferenceClient<subjectReference>, Prisma__subjectReferenceClient<subjectReferenceGetPayload<T>>>

    /**
     * Count the number of SubjectReferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subjectReferenceCountArgs} args - Arguments to filter SubjectReferences to count.
     * @example
     * // Count the number of SubjectReferences
     * const count = await prisma.subjectReference.count({
     *   where: {
     *     // ... the filter for the SubjectReferences we want to count
     *   }
     * })
    **/
    count<T extends subjectReferenceCountArgs>(
      args?: Subset<T, subjectReferenceCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubjectReferenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubjectReference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectReferenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubjectReferenceAggregateArgs>(args: Subset<T, SubjectReferenceAggregateArgs>): PrismaPromise<GetSubjectReferenceAggregateType<T>>

    /**
     * Group by SubjectReference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectReferenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubjectReferenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubjectReferenceGroupByArgs['orderBy'] }
        : { orderBy?: SubjectReferenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubjectReferenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubjectReferenceGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for subjectReference.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__subjectReferenceClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    users<T extends usersArgs = {}>(args?: Subset<T, usersArgs>): CheckSelect<T, Prisma__usersClient<users | null >, Prisma__usersClient<usersGetPayload<T> | null >>;

    reference<T extends referenceFindManyArgs = {}>(args?: Subset<T, referenceFindManyArgs>): CheckSelect<T, PrismaPromise<Array<reference>>, PrismaPromise<Array<referenceGetPayload<T>>>>;

    forms<T extends formReferenceFindManyArgs = {}>(args?: Subset<T, formReferenceFindManyArgs>): CheckSelect<T, PrismaPromise<Array<formReference>>, PrismaPromise<Array<formReferenceGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * subjectReference base type for findUnique actions
   */
  export type subjectReferenceFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the subjectReference
     * 
    **/
    select?: subjectReferenceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: subjectReferenceInclude | null
    /**
     * Filter, which subjectReference to fetch.
     * 
    **/
    where: subjectReferenceWhereUniqueInput
  }

  /**
   * subjectReference: findUnique
   */
  export interface subjectReferenceFindUniqueArgs extends subjectReferenceFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * subjectReference base type for findFirst actions
   */
  export type subjectReferenceFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the subjectReference
     * 
    **/
    select?: subjectReferenceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: subjectReferenceInclude | null
    /**
     * Filter, which subjectReference to fetch.
     * 
    **/
    where?: subjectReferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subjectReferences to fetch.
     * 
    **/
    orderBy?: Enumerable<subjectReferenceOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for subjectReferences.
     * 
    **/
    cursor?: subjectReferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subjectReferences from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subjectReferences.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of subjectReferences.
     * 
    **/
    distinct?: Enumerable<SubjectReferenceScalarFieldEnum>
  }

  /**
   * subjectReference: findFirst
   */
  export interface subjectReferenceFindFirstArgs extends subjectReferenceFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * subjectReference findMany
   */
  export type subjectReferenceFindManyArgs = {
    /**
     * Select specific fields to fetch from the subjectReference
     * 
    **/
    select?: subjectReferenceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: subjectReferenceInclude | null
    /**
     * Filter, which subjectReferences to fetch.
     * 
    **/
    where?: subjectReferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subjectReferences to fetch.
     * 
    **/
    orderBy?: Enumerable<subjectReferenceOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing subjectReferences.
     * 
    **/
    cursor?: subjectReferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subjectReferences from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subjectReferences.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SubjectReferenceScalarFieldEnum>
  }


  /**
   * subjectReference create
   */
  export type subjectReferenceCreateArgs = {
    /**
     * Select specific fields to fetch from the subjectReference
     * 
    **/
    select?: subjectReferenceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: subjectReferenceInclude | null
    /**
     * The data needed to create a subjectReference.
     * 
    **/
    data: XOR<subjectReferenceCreateInput, subjectReferenceUncheckedCreateInput>
  }


  /**
   * subjectReference createMany
   */
  export type subjectReferenceCreateManyArgs = {
    /**
     * The data used to create many subjectReferences.
     * 
    **/
    data: Enumerable<subjectReferenceCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * subjectReference update
   */
  export type subjectReferenceUpdateArgs = {
    /**
     * Select specific fields to fetch from the subjectReference
     * 
    **/
    select?: subjectReferenceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: subjectReferenceInclude | null
    /**
     * The data needed to update a subjectReference.
     * 
    **/
    data: XOR<subjectReferenceUpdateInput, subjectReferenceUncheckedUpdateInput>
    /**
     * Choose, which subjectReference to update.
     * 
    **/
    where: subjectReferenceWhereUniqueInput
  }


  /**
   * subjectReference updateMany
   */
  export type subjectReferenceUpdateManyArgs = {
    /**
     * The data used to update subjectReferences.
     * 
    **/
    data: XOR<subjectReferenceUpdateManyMutationInput, subjectReferenceUncheckedUpdateManyInput>
    /**
     * Filter which subjectReferences to update
     * 
    **/
    where?: subjectReferenceWhereInput
  }


  /**
   * subjectReference upsert
   */
  export type subjectReferenceUpsertArgs = {
    /**
     * Select specific fields to fetch from the subjectReference
     * 
    **/
    select?: subjectReferenceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: subjectReferenceInclude | null
    /**
     * The filter to search for the subjectReference to update in case it exists.
     * 
    **/
    where: subjectReferenceWhereUniqueInput
    /**
     * In case the subjectReference found by the `where` argument doesn't exist, create a new subjectReference with this data.
     * 
    **/
    create: XOR<subjectReferenceCreateInput, subjectReferenceUncheckedCreateInput>
    /**
     * In case the subjectReference was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<subjectReferenceUpdateInput, subjectReferenceUncheckedUpdateInput>
  }


  /**
   * subjectReference delete
   */
  export type subjectReferenceDeleteArgs = {
    /**
     * Select specific fields to fetch from the subjectReference
     * 
    **/
    select?: subjectReferenceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: subjectReferenceInclude | null
    /**
     * Filter which subjectReference to delete.
     * 
    **/
    where: subjectReferenceWhereUniqueInput
  }


  /**
   * subjectReference deleteMany
   */
  export type subjectReferenceDeleteManyArgs = {
    /**
     * Filter which subjectReferences to delete
     * 
    **/
    where?: subjectReferenceWhereInput
  }


  /**
   * subjectReference: findUniqueOrThrow
   */
  export type subjectReferenceFindUniqueOrThrowArgs = subjectReferenceFindUniqueArgsBase
      

  /**
   * subjectReference: findFirstOrThrow
   */
  export type subjectReferenceFindFirstOrThrowArgs = subjectReferenceFindFirstArgsBase
      

  /**
   * subjectReference without action
   */
  export type subjectReferenceArgs = {
    /**
     * Select specific fields to fetch from the subjectReference
     * 
    **/
    select?: subjectReferenceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: subjectReferenceInclude | null
  }



  /**
   * Model formReference
   */


  export type AggregateFormReference = {
    _count: FormReferenceCountAggregateOutputType | null
    _avg: FormReferenceAvgAggregateOutputType | null
    _sum: FormReferenceSumAggregateOutputType | null
    _min: FormReferenceMinAggregateOutputType | null
    _max: FormReferenceMaxAggregateOutputType | null
  }

  export type FormReferenceAvgAggregateOutputType = {
    id: number | null
    usersId: number | null
  }

  export type FormReferenceSumAggregateOutputType = {
    id: number | null
    usersId: number | null
  }

  export type FormReferenceMinAggregateOutputType = {
    id: number | null
    formName: string | null
    usersId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FormReferenceMaxAggregateOutputType = {
    id: number | null
    formName: string | null
    usersId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FormReferenceCountAggregateOutputType = {
    id: number
    formName: number
    usersId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FormReferenceAvgAggregateInputType = {
    id?: true
    usersId?: true
  }

  export type FormReferenceSumAggregateInputType = {
    id?: true
    usersId?: true
  }

  export type FormReferenceMinAggregateInputType = {
    id?: true
    formName?: true
    usersId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FormReferenceMaxAggregateInputType = {
    id?: true
    formName?: true
    usersId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FormReferenceCountAggregateInputType = {
    id?: true
    formName?: true
    usersId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FormReferenceAggregateArgs = {
    /**
     * Filter which formReference to aggregate.
     * 
    **/
    where?: formReferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of formReferences to fetch.
     * 
    **/
    orderBy?: Enumerable<formReferenceOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: formReferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` formReferences from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` formReferences.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned formReferences
    **/
    _count?: true | FormReferenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FormReferenceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FormReferenceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FormReferenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FormReferenceMaxAggregateInputType
  }

  export type GetFormReferenceAggregateType<T extends FormReferenceAggregateArgs> = {
        [P in keyof T & keyof AggregateFormReference]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFormReference[P]>
      : GetScalarType<T[P], AggregateFormReference[P]>
  }




  export type FormReferenceGroupByArgs = {
    where?: formReferenceWhereInput
    orderBy?: Enumerable<formReferenceOrderByWithAggregationInput>
    by: Array<FormReferenceScalarFieldEnum>
    having?: formReferenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FormReferenceCountAggregateInputType | true
    _avg?: FormReferenceAvgAggregateInputType
    _sum?: FormReferenceSumAggregateInputType
    _min?: FormReferenceMinAggregateInputType
    _max?: FormReferenceMaxAggregateInputType
  }


  export type FormReferenceGroupByOutputType = {
    id: number
    formName: string
    usersId: number
    createdAt: Date
    updatedAt: Date
    _count: FormReferenceCountAggregateOutputType | null
    _avg: FormReferenceAvgAggregateOutputType | null
    _sum: FormReferenceSumAggregateOutputType | null
    _min: FormReferenceMinAggregateOutputType | null
    _max: FormReferenceMaxAggregateOutputType | null
  }

  type GetFormReferenceGroupByPayload<T extends FormReferenceGroupByArgs> = PrismaPromise<
    Array<
      PickArray<FormReferenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FormReferenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FormReferenceGroupByOutputType[P]>
            : GetScalarType<T[P], FormReferenceGroupByOutputType[P]>
        }
      >
    >


  export type formReferenceSelect = {
    id?: boolean
    formName?: boolean
    usersId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | usersArgs
    reference?: boolean | referenceFindManyArgs
    subjects?: boolean | subjectReferenceFindManyArgs
    _count?: boolean | FormReferenceCountOutputTypeArgs
  }

  export type formReferenceInclude = {
    users?: boolean | usersArgs
    reference?: boolean | referenceFindManyArgs
    subjects?: boolean | subjectReferenceFindManyArgs
    _count?: boolean | FormReferenceCountOutputTypeArgs
  }

  export type formReferenceGetPayload<
    S extends boolean | null | undefined | formReferenceArgs,
    U = keyof S
      > = S extends true
        ? formReference
    : S extends undefined
    ? never
    : S extends formReferenceArgs | formReferenceFindManyArgs
    ?'include' extends U
    ? formReference  & {
    [P in TrueKeys<S['include']>]:
        P extends 'users' ? usersGetPayload<S['include'][P]> :
        P extends 'reference' ? Array < referenceGetPayload<S['include'][P]>>  :
        P extends 'subjects' ? Array < subjectReferenceGetPayload<S['include'][P]>>  :
        P extends '_count' ? FormReferenceCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'users' ? usersGetPayload<S['select'][P]> :
        P extends 'reference' ? Array < referenceGetPayload<S['select'][P]>>  :
        P extends 'subjects' ? Array < subjectReferenceGetPayload<S['select'][P]>>  :
        P extends '_count' ? FormReferenceCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof formReference ? formReference[P] : never
  } 
    : formReference
  : formReference


  type formReferenceCountArgs = Merge<
    Omit<formReferenceFindManyArgs, 'select' | 'include'> & {
      select?: FormReferenceCountAggregateInputType | true
    }
  >

  export interface formReferenceDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one FormReference that matches the filter.
     * @param {formReferenceFindUniqueArgs} args - Arguments to find a FormReference
     * @example
     * // Get one FormReference
     * const formReference = await prisma.formReference.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends formReferenceFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, formReferenceFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'formReference'> extends True ? CheckSelect<T, Prisma__formReferenceClient<formReference>, Prisma__formReferenceClient<formReferenceGetPayload<T>>> : CheckSelect<T, Prisma__formReferenceClient<formReference | null >, Prisma__formReferenceClient<formReferenceGetPayload<T> | null >>

    /**
     * Find the first FormReference that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formReferenceFindFirstArgs} args - Arguments to find a FormReference
     * @example
     * // Get one FormReference
     * const formReference = await prisma.formReference.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends formReferenceFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, formReferenceFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'formReference'> extends True ? CheckSelect<T, Prisma__formReferenceClient<formReference>, Prisma__formReferenceClient<formReferenceGetPayload<T>>> : CheckSelect<T, Prisma__formReferenceClient<formReference | null >, Prisma__formReferenceClient<formReferenceGetPayload<T> | null >>

    /**
     * Find zero or more FormReferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formReferenceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FormReferences
     * const formReferences = await prisma.formReference.findMany()
     * 
     * // Get first 10 FormReferences
     * const formReferences = await prisma.formReference.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const formReferenceWithIdOnly = await prisma.formReference.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends formReferenceFindManyArgs>(
      args?: SelectSubset<T, formReferenceFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<formReference>>, PrismaPromise<Array<formReferenceGetPayload<T>>>>

    /**
     * Create a FormReference.
     * @param {formReferenceCreateArgs} args - Arguments to create a FormReference.
     * @example
     * // Create one FormReference
     * const FormReference = await prisma.formReference.create({
     *   data: {
     *     // ... data to create a FormReference
     *   }
     * })
     * 
    **/
    create<T extends formReferenceCreateArgs>(
      args: SelectSubset<T, formReferenceCreateArgs>
    ): CheckSelect<T, Prisma__formReferenceClient<formReference>, Prisma__formReferenceClient<formReferenceGetPayload<T>>>

    /**
     * Create many FormReferences.
     *     @param {formReferenceCreateManyArgs} args - Arguments to create many FormReferences.
     *     @example
     *     // Create many FormReferences
     *     const formReference = await prisma.formReference.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends formReferenceCreateManyArgs>(
      args?: SelectSubset<T, formReferenceCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a FormReference.
     * @param {formReferenceDeleteArgs} args - Arguments to delete one FormReference.
     * @example
     * // Delete one FormReference
     * const FormReference = await prisma.formReference.delete({
     *   where: {
     *     // ... filter to delete one FormReference
     *   }
     * })
     * 
    **/
    delete<T extends formReferenceDeleteArgs>(
      args: SelectSubset<T, formReferenceDeleteArgs>
    ): CheckSelect<T, Prisma__formReferenceClient<formReference>, Prisma__formReferenceClient<formReferenceGetPayload<T>>>

    /**
     * Update one FormReference.
     * @param {formReferenceUpdateArgs} args - Arguments to update one FormReference.
     * @example
     * // Update one FormReference
     * const formReference = await prisma.formReference.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends formReferenceUpdateArgs>(
      args: SelectSubset<T, formReferenceUpdateArgs>
    ): CheckSelect<T, Prisma__formReferenceClient<formReference>, Prisma__formReferenceClient<formReferenceGetPayload<T>>>

    /**
     * Delete zero or more FormReferences.
     * @param {formReferenceDeleteManyArgs} args - Arguments to filter FormReferences to delete.
     * @example
     * // Delete a few FormReferences
     * const { count } = await prisma.formReference.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends formReferenceDeleteManyArgs>(
      args?: SelectSubset<T, formReferenceDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more FormReferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formReferenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FormReferences
     * const formReference = await prisma.formReference.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends formReferenceUpdateManyArgs>(
      args: SelectSubset<T, formReferenceUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one FormReference.
     * @param {formReferenceUpsertArgs} args - Arguments to update or create a FormReference.
     * @example
     * // Update or create a FormReference
     * const formReference = await prisma.formReference.upsert({
     *   create: {
     *     // ... data to create a FormReference
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FormReference we want to update
     *   }
     * })
    **/
    upsert<T extends formReferenceUpsertArgs>(
      args: SelectSubset<T, formReferenceUpsertArgs>
    ): CheckSelect<T, Prisma__formReferenceClient<formReference>, Prisma__formReferenceClient<formReferenceGetPayload<T>>>

    /**
     * Find one FormReference that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {formReferenceFindUniqueOrThrowArgs} args - Arguments to find a FormReference
     * @example
     * // Get one FormReference
     * const formReference = await prisma.formReference.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends formReferenceFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, formReferenceFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__formReferenceClient<formReference>, Prisma__formReferenceClient<formReferenceGetPayload<T>>>

    /**
     * Find the first FormReference that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formReferenceFindFirstOrThrowArgs} args - Arguments to find a FormReference
     * @example
     * // Get one FormReference
     * const formReference = await prisma.formReference.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends formReferenceFindFirstOrThrowArgs>(
      args?: SelectSubset<T, formReferenceFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__formReferenceClient<formReference>, Prisma__formReferenceClient<formReferenceGetPayload<T>>>

    /**
     * Count the number of FormReferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formReferenceCountArgs} args - Arguments to filter FormReferences to count.
     * @example
     * // Count the number of FormReferences
     * const count = await prisma.formReference.count({
     *   where: {
     *     // ... the filter for the FormReferences we want to count
     *   }
     * })
    **/
    count<T extends formReferenceCountArgs>(
      args?: Subset<T, formReferenceCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FormReferenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FormReference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormReferenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FormReferenceAggregateArgs>(args: Subset<T, FormReferenceAggregateArgs>): PrismaPromise<GetFormReferenceAggregateType<T>>

    /**
     * Group by FormReference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormReferenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FormReferenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FormReferenceGroupByArgs['orderBy'] }
        : { orderBy?: FormReferenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FormReferenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFormReferenceGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for formReference.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__formReferenceClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    users<T extends usersArgs = {}>(args?: Subset<T, usersArgs>): CheckSelect<T, Prisma__usersClient<users | null >, Prisma__usersClient<usersGetPayload<T> | null >>;

    reference<T extends referenceFindManyArgs = {}>(args?: Subset<T, referenceFindManyArgs>): CheckSelect<T, PrismaPromise<Array<reference>>, PrismaPromise<Array<referenceGetPayload<T>>>>;

    subjects<T extends subjectReferenceFindManyArgs = {}>(args?: Subset<T, subjectReferenceFindManyArgs>): CheckSelect<T, PrismaPromise<Array<subjectReference>>, PrismaPromise<Array<subjectReferenceGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * formReference base type for findUnique actions
   */
  export type formReferenceFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the formReference
     * 
    **/
    select?: formReferenceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: formReferenceInclude | null
    /**
     * Filter, which formReference to fetch.
     * 
    **/
    where: formReferenceWhereUniqueInput
  }

  /**
   * formReference: findUnique
   */
  export interface formReferenceFindUniqueArgs extends formReferenceFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * formReference base type for findFirst actions
   */
  export type formReferenceFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the formReference
     * 
    **/
    select?: formReferenceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: formReferenceInclude | null
    /**
     * Filter, which formReference to fetch.
     * 
    **/
    where?: formReferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of formReferences to fetch.
     * 
    **/
    orderBy?: Enumerable<formReferenceOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for formReferences.
     * 
    **/
    cursor?: formReferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` formReferences from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` formReferences.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of formReferences.
     * 
    **/
    distinct?: Enumerable<FormReferenceScalarFieldEnum>
  }

  /**
   * formReference: findFirst
   */
  export interface formReferenceFindFirstArgs extends formReferenceFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * formReference findMany
   */
  export type formReferenceFindManyArgs = {
    /**
     * Select specific fields to fetch from the formReference
     * 
    **/
    select?: formReferenceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: formReferenceInclude | null
    /**
     * Filter, which formReferences to fetch.
     * 
    **/
    where?: formReferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of formReferences to fetch.
     * 
    **/
    orderBy?: Enumerable<formReferenceOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing formReferences.
     * 
    **/
    cursor?: formReferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` formReferences from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` formReferences.
     * 
    **/
    skip?: number
    distinct?: Enumerable<FormReferenceScalarFieldEnum>
  }


  /**
   * formReference create
   */
  export type formReferenceCreateArgs = {
    /**
     * Select specific fields to fetch from the formReference
     * 
    **/
    select?: formReferenceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: formReferenceInclude | null
    /**
     * The data needed to create a formReference.
     * 
    **/
    data: XOR<formReferenceCreateInput, formReferenceUncheckedCreateInput>
  }


  /**
   * formReference createMany
   */
  export type formReferenceCreateManyArgs = {
    /**
     * The data used to create many formReferences.
     * 
    **/
    data: Enumerable<formReferenceCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * formReference update
   */
  export type formReferenceUpdateArgs = {
    /**
     * Select specific fields to fetch from the formReference
     * 
    **/
    select?: formReferenceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: formReferenceInclude | null
    /**
     * The data needed to update a formReference.
     * 
    **/
    data: XOR<formReferenceUpdateInput, formReferenceUncheckedUpdateInput>
    /**
     * Choose, which formReference to update.
     * 
    **/
    where: formReferenceWhereUniqueInput
  }


  /**
   * formReference updateMany
   */
  export type formReferenceUpdateManyArgs = {
    /**
     * The data used to update formReferences.
     * 
    **/
    data: XOR<formReferenceUpdateManyMutationInput, formReferenceUncheckedUpdateManyInput>
    /**
     * Filter which formReferences to update
     * 
    **/
    where?: formReferenceWhereInput
  }


  /**
   * formReference upsert
   */
  export type formReferenceUpsertArgs = {
    /**
     * Select specific fields to fetch from the formReference
     * 
    **/
    select?: formReferenceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: formReferenceInclude | null
    /**
     * The filter to search for the formReference to update in case it exists.
     * 
    **/
    where: formReferenceWhereUniqueInput
    /**
     * In case the formReference found by the `where` argument doesn't exist, create a new formReference with this data.
     * 
    **/
    create: XOR<formReferenceCreateInput, formReferenceUncheckedCreateInput>
    /**
     * In case the formReference was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<formReferenceUpdateInput, formReferenceUncheckedUpdateInput>
  }


  /**
   * formReference delete
   */
  export type formReferenceDeleteArgs = {
    /**
     * Select specific fields to fetch from the formReference
     * 
    **/
    select?: formReferenceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: formReferenceInclude | null
    /**
     * Filter which formReference to delete.
     * 
    **/
    where: formReferenceWhereUniqueInput
  }


  /**
   * formReference deleteMany
   */
  export type formReferenceDeleteManyArgs = {
    /**
     * Filter which formReferences to delete
     * 
    **/
    where?: formReferenceWhereInput
  }


  /**
   * formReference: findUniqueOrThrow
   */
  export type formReferenceFindUniqueOrThrowArgs = formReferenceFindUniqueArgsBase
      

  /**
   * formReference: findFirstOrThrow
   */
  export type formReferenceFindFirstOrThrowArgs = formReferenceFindFirstArgsBase
      

  /**
   * formReference without action
   */
  export type formReferenceArgs = {
    /**
     * Select specific fields to fetch from the formReference
     * 
    **/
    select?: formReferenceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: formReferenceInclude | null
  }



  /**
   * Model reference
   */


  export type AggregateReference = {
    _count: ReferenceCountAggregateOutputType | null
    _avg: ReferenceAvgAggregateOutputType | null
    _sum: ReferenceSumAggregateOutputType | null
    _min: ReferenceMinAggregateOutputType | null
    _max: ReferenceMaxAggregateOutputType | null
  }

  export type ReferenceAvgAggregateOutputType = {
    id: number | null
    subjectId: number | null
    usersId: number | null
  }

  export type ReferenceSumAggregateOutputType = {
    id: number | null
    subjectId: number | null
    usersId: number | null
  }

  export type ReferenceMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    data: string | null
    isPdf: boolean | null
    published: boolean | null
    subjectId: number | null
    usersId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReferenceMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    data: string | null
    isPdf: boolean | null
    published: boolean | null
    subjectId: number | null
    usersId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReferenceCountAggregateOutputType = {
    id: number
    name: number
    description: number
    data: number
    isPdf: number
    published: number
    subjectId: number
    usersId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReferenceAvgAggregateInputType = {
    id?: true
    subjectId?: true
    usersId?: true
  }

  export type ReferenceSumAggregateInputType = {
    id?: true
    subjectId?: true
    usersId?: true
  }

  export type ReferenceMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    data?: true
    isPdf?: true
    published?: true
    subjectId?: true
    usersId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReferenceMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    data?: true
    isPdf?: true
    published?: true
    subjectId?: true
    usersId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReferenceCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    data?: true
    isPdf?: true
    published?: true
    subjectId?: true
    usersId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReferenceAggregateArgs = {
    /**
     * Filter which reference to aggregate.
     * 
    **/
    where?: referenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of references to fetch.
     * 
    **/
    orderBy?: Enumerable<referenceOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: referenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` references from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` references.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned references
    **/
    _count?: true | ReferenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReferenceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReferenceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReferenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReferenceMaxAggregateInputType
  }

  export type GetReferenceAggregateType<T extends ReferenceAggregateArgs> = {
        [P in keyof T & keyof AggregateReference]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReference[P]>
      : GetScalarType<T[P], AggregateReference[P]>
  }




  export type ReferenceGroupByArgs = {
    where?: referenceWhereInput
    orderBy?: Enumerable<referenceOrderByWithAggregationInput>
    by: Array<ReferenceScalarFieldEnum>
    having?: referenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReferenceCountAggregateInputType | true
    _avg?: ReferenceAvgAggregateInputType
    _sum?: ReferenceSumAggregateInputType
    _min?: ReferenceMinAggregateInputType
    _max?: ReferenceMaxAggregateInputType
  }


  export type ReferenceGroupByOutputType = {
    id: number
    name: string
    description: string
    data: string
    isPdf: boolean
    published: boolean
    subjectId: number
    usersId: number
    createdAt: Date
    updatedAt: Date
    _count: ReferenceCountAggregateOutputType | null
    _avg: ReferenceAvgAggregateOutputType | null
    _sum: ReferenceSumAggregateOutputType | null
    _min: ReferenceMinAggregateOutputType | null
    _max: ReferenceMaxAggregateOutputType | null
  }

  type GetReferenceGroupByPayload<T extends ReferenceGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ReferenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReferenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReferenceGroupByOutputType[P]>
            : GetScalarType<T[P], ReferenceGroupByOutputType[P]>
        }
      >
    >


  export type referenceSelect = {
    id?: boolean
    name?: boolean
    description?: boolean
    data?: boolean
    isPdf?: boolean
    published?: boolean
    subjectId?: boolean
    usersId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subjectReference?: boolean | subjectReferenceArgs
    users?: boolean | usersArgs
    formReference?: boolean | formReferenceFindManyArgs
    _count?: boolean | ReferenceCountOutputTypeArgs
  }

  export type referenceInclude = {
    subjectReference?: boolean | subjectReferenceArgs
    users?: boolean | usersArgs
    formReference?: boolean | formReferenceFindManyArgs
    _count?: boolean | ReferenceCountOutputTypeArgs
  }

  export type referenceGetPayload<
    S extends boolean | null | undefined | referenceArgs,
    U = keyof S
      > = S extends true
        ? reference
    : S extends undefined
    ? never
    : S extends referenceArgs | referenceFindManyArgs
    ?'include' extends U
    ? reference  & {
    [P in TrueKeys<S['include']>]:
        P extends 'subjectReference' ? subjectReferenceGetPayload<S['include'][P]> :
        P extends 'users' ? usersGetPayload<S['include'][P]> :
        P extends 'formReference' ? Array < formReferenceGetPayload<S['include'][P]>>  :
        P extends '_count' ? ReferenceCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'subjectReference' ? subjectReferenceGetPayload<S['select'][P]> :
        P extends 'users' ? usersGetPayload<S['select'][P]> :
        P extends 'formReference' ? Array < formReferenceGetPayload<S['select'][P]>>  :
        P extends '_count' ? ReferenceCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof reference ? reference[P] : never
  } 
    : reference
  : reference


  type referenceCountArgs = Merge<
    Omit<referenceFindManyArgs, 'select' | 'include'> & {
      select?: ReferenceCountAggregateInputType | true
    }
  >

  export interface referenceDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Reference that matches the filter.
     * @param {referenceFindUniqueArgs} args - Arguments to find a Reference
     * @example
     * // Get one Reference
     * const reference = await prisma.reference.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends referenceFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, referenceFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'reference'> extends True ? CheckSelect<T, Prisma__referenceClient<reference>, Prisma__referenceClient<referenceGetPayload<T>>> : CheckSelect<T, Prisma__referenceClient<reference | null >, Prisma__referenceClient<referenceGetPayload<T> | null >>

    /**
     * Find the first Reference that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {referenceFindFirstArgs} args - Arguments to find a Reference
     * @example
     * // Get one Reference
     * const reference = await prisma.reference.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends referenceFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, referenceFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'reference'> extends True ? CheckSelect<T, Prisma__referenceClient<reference>, Prisma__referenceClient<referenceGetPayload<T>>> : CheckSelect<T, Prisma__referenceClient<reference | null >, Prisma__referenceClient<referenceGetPayload<T> | null >>

    /**
     * Find zero or more References that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {referenceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all References
     * const references = await prisma.reference.findMany()
     * 
     * // Get first 10 References
     * const references = await prisma.reference.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const referenceWithIdOnly = await prisma.reference.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends referenceFindManyArgs>(
      args?: SelectSubset<T, referenceFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<reference>>, PrismaPromise<Array<referenceGetPayload<T>>>>

    /**
     * Create a Reference.
     * @param {referenceCreateArgs} args - Arguments to create a Reference.
     * @example
     * // Create one Reference
     * const Reference = await prisma.reference.create({
     *   data: {
     *     // ... data to create a Reference
     *   }
     * })
     * 
    **/
    create<T extends referenceCreateArgs>(
      args: SelectSubset<T, referenceCreateArgs>
    ): CheckSelect<T, Prisma__referenceClient<reference>, Prisma__referenceClient<referenceGetPayload<T>>>

    /**
     * Create many References.
     *     @param {referenceCreateManyArgs} args - Arguments to create many References.
     *     @example
     *     // Create many References
     *     const reference = await prisma.reference.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends referenceCreateManyArgs>(
      args?: SelectSubset<T, referenceCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Reference.
     * @param {referenceDeleteArgs} args - Arguments to delete one Reference.
     * @example
     * // Delete one Reference
     * const Reference = await prisma.reference.delete({
     *   where: {
     *     // ... filter to delete one Reference
     *   }
     * })
     * 
    **/
    delete<T extends referenceDeleteArgs>(
      args: SelectSubset<T, referenceDeleteArgs>
    ): CheckSelect<T, Prisma__referenceClient<reference>, Prisma__referenceClient<referenceGetPayload<T>>>

    /**
     * Update one Reference.
     * @param {referenceUpdateArgs} args - Arguments to update one Reference.
     * @example
     * // Update one Reference
     * const reference = await prisma.reference.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends referenceUpdateArgs>(
      args: SelectSubset<T, referenceUpdateArgs>
    ): CheckSelect<T, Prisma__referenceClient<reference>, Prisma__referenceClient<referenceGetPayload<T>>>

    /**
     * Delete zero or more References.
     * @param {referenceDeleteManyArgs} args - Arguments to filter References to delete.
     * @example
     * // Delete a few References
     * const { count } = await prisma.reference.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends referenceDeleteManyArgs>(
      args?: SelectSubset<T, referenceDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more References.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {referenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many References
     * const reference = await prisma.reference.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends referenceUpdateManyArgs>(
      args: SelectSubset<T, referenceUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Reference.
     * @param {referenceUpsertArgs} args - Arguments to update or create a Reference.
     * @example
     * // Update or create a Reference
     * const reference = await prisma.reference.upsert({
     *   create: {
     *     // ... data to create a Reference
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reference we want to update
     *   }
     * })
    **/
    upsert<T extends referenceUpsertArgs>(
      args: SelectSubset<T, referenceUpsertArgs>
    ): CheckSelect<T, Prisma__referenceClient<reference>, Prisma__referenceClient<referenceGetPayload<T>>>

    /**
     * Find one Reference that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {referenceFindUniqueOrThrowArgs} args - Arguments to find a Reference
     * @example
     * // Get one Reference
     * const reference = await prisma.reference.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends referenceFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, referenceFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__referenceClient<reference>, Prisma__referenceClient<referenceGetPayload<T>>>

    /**
     * Find the first Reference that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {referenceFindFirstOrThrowArgs} args - Arguments to find a Reference
     * @example
     * // Get one Reference
     * const reference = await prisma.reference.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends referenceFindFirstOrThrowArgs>(
      args?: SelectSubset<T, referenceFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__referenceClient<reference>, Prisma__referenceClient<referenceGetPayload<T>>>

    /**
     * Count the number of References.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {referenceCountArgs} args - Arguments to filter References to count.
     * @example
     * // Count the number of References
     * const count = await prisma.reference.count({
     *   where: {
     *     // ... the filter for the References we want to count
     *   }
     * })
    **/
    count<T extends referenceCountArgs>(
      args?: Subset<T, referenceCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReferenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReferenceAggregateArgs>(args: Subset<T, ReferenceAggregateArgs>): PrismaPromise<GetReferenceAggregateType<T>>

    /**
     * Group by Reference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReferenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReferenceGroupByArgs['orderBy'] }
        : { orderBy?: ReferenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReferenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReferenceGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for reference.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__referenceClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    subjectReference<T extends subjectReferenceArgs = {}>(args?: Subset<T, subjectReferenceArgs>): CheckSelect<T, Prisma__subjectReferenceClient<subjectReference | null >, Prisma__subjectReferenceClient<subjectReferenceGetPayload<T> | null >>;

    users<T extends usersArgs = {}>(args?: Subset<T, usersArgs>): CheckSelect<T, Prisma__usersClient<users | null >, Prisma__usersClient<usersGetPayload<T> | null >>;

    formReference<T extends formReferenceFindManyArgs = {}>(args?: Subset<T, formReferenceFindManyArgs>): CheckSelect<T, PrismaPromise<Array<formReference>>, PrismaPromise<Array<formReferenceGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * reference base type for findUnique actions
   */
  export type referenceFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the reference
     * 
    **/
    select?: referenceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: referenceInclude | null
    /**
     * Filter, which reference to fetch.
     * 
    **/
    where: referenceWhereUniqueInput
  }

  /**
   * reference: findUnique
   */
  export interface referenceFindUniqueArgs extends referenceFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * reference base type for findFirst actions
   */
  export type referenceFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the reference
     * 
    **/
    select?: referenceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: referenceInclude | null
    /**
     * Filter, which reference to fetch.
     * 
    **/
    where?: referenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of references to fetch.
     * 
    **/
    orderBy?: Enumerable<referenceOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for references.
     * 
    **/
    cursor?: referenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` references from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` references.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of references.
     * 
    **/
    distinct?: Enumerable<ReferenceScalarFieldEnum>
  }

  /**
   * reference: findFirst
   */
  export interface referenceFindFirstArgs extends referenceFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * reference findMany
   */
  export type referenceFindManyArgs = {
    /**
     * Select specific fields to fetch from the reference
     * 
    **/
    select?: referenceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: referenceInclude | null
    /**
     * Filter, which references to fetch.
     * 
    **/
    where?: referenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of references to fetch.
     * 
    **/
    orderBy?: Enumerable<referenceOrderByWithRelationAndSearchRelevanceInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing references.
     * 
    **/
    cursor?: referenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` references from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` references.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ReferenceScalarFieldEnum>
  }


  /**
   * reference create
   */
  export type referenceCreateArgs = {
    /**
     * Select specific fields to fetch from the reference
     * 
    **/
    select?: referenceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: referenceInclude | null
    /**
     * The data needed to create a reference.
     * 
    **/
    data: XOR<referenceCreateInput, referenceUncheckedCreateInput>
  }


  /**
   * reference createMany
   */
  export type referenceCreateManyArgs = {
    /**
     * The data used to create many references.
     * 
    **/
    data: Enumerable<referenceCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * reference update
   */
  export type referenceUpdateArgs = {
    /**
     * Select specific fields to fetch from the reference
     * 
    **/
    select?: referenceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: referenceInclude | null
    /**
     * The data needed to update a reference.
     * 
    **/
    data: XOR<referenceUpdateInput, referenceUncheckedUpdateInput>
    /**
     * Choose, which reference to update.
     * 
    **/
    where: referenceWhereUniqueInput
  }


  /**
   * reference updateMany
   */
  export type referenceUpdateManyArgs = {
    /**
     * The data used to update references.
     * 
    **/
    data: XOR<referenceUpdateManyMutationInput, referenceUncheckedUpdateManyInput>
    /**
     * Filter which references to update
     * 
    **/
    where?: referenceWhereInput
  }


  /**
   * reference upsert
   */
  export type referenceUpsertArgs = {
    /**
     * Select specific fields to fetch from the reference
     * 
    **/
    select?: referenceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: referenceInclude | null
    /**
     * The filter to search for the reference to update in case it exists.
     * 
    **/
    where: referenceWhereUniqueInput
    /**
     * In case the reference found by the `where` argument doesn't exist, create a new reference with this data.
     * 
    **/
    create: XOR<referenceCreateInput, referenceUncheckedCreateInput>
    /**
     * In case the reference was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<referenceUpdateInput, referenceUncheckedUpdateInput>
  }


  /**
   * reference delete
   */
  export type referenceDeleteArgs = {
    /**
     * Select specific fields to fetch from the reference
     * 
    **/
    select?: referenceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: referenceInclude | null
    /**
     * Filter which reference to delete.
     * 
    **/
    where: referenceWhereUniqueInput
  }


  /**
   * reference deleteMany
   */
  export type referenceDeleteManyArgs = {
    /**
     * Filter which references to delete
     * 
    **/
    where?: referenceWhereInput
  }


  /**
   * reference: findUniqueOrThrow
   */
  export type referenceFindUniqueOrThrowArgs = referenceFindUniqueArgsBase
      

  /**
   * reference: findFirstOrThrow
   */
  export type referenceFindFirstOrThrowArgs = referenceFindFirstArgsBase
      

  /**
   * reference without action
   */
  export type referenceArgs = {
    /**
     * Select specific fields to fetch from the reference
     * 
    **/
    select?: referenceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: referenceInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const UsersScalarFieldEnum: {
    id: 'id',
    image: 'image',
    username: 'username',
    password: 'password',
    isAdmin: 'isAdmin',
    isSuperUser: 'isSuperUser',
    dateJoined: 'dateJoined',
    name: 'name',
    updatedAt: 'updatedAt',
    isOnline: 'isOnline'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const VifurushiScalarFieldEnum: {
    id: 'id',
    name: 'name',
    value: 'value',
    usersId: 'usersId'
  };

  export type VifurushiScalarFieldEnum = (typeof VifurushiScalarFieldEnum)[keyof typeof VifurushiScalarFieldEnum]


  export const VifurushiPriceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    price: 'price'
  };

  export type VifurushiPriceScalarFieldEnum = (typeof VifurushiPriceScalarFieldEnum)[keyof typeof VifurushiPriceScalarFieldEnum]


  export const VifurushiPackageScalarFieldEnum: {
    id: 'id',
    name: 'name',
    value: 'value'
  };

  export type VifurushiPackageScalarFieldEnum = (typeof VifurushiPackageScalarFieldEnum)[keyof typeof VifurushiPackageScalarFieldEnum]


  export const NotesDownloadScalarFieldEnum: {
    id: 'id',
    name: 'name',
    value: 'value',
    vifurushiPackageId: 'vifurushiPackageId'
  };

  export type NotesDownloadScalarFieldEnum = (typeof NotesDownloadScalarFieldEnum)[keyof typeof NotesDownloadScalarFieldEnum]


  export const QuizExcercisesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    value: 'value',
    vifurushiPackageId: 'vifurushiPackageId'
  };

  export type QuizExcercisesScalarFieldEnum = (typeof QuizExcercisesScalarFieldEnum)[keyof typeof QuizExcercisesScalarFieldEnum]


  export const ExamsUnsolvedDownloadScalarFieldEnum: {
    id: 'id',
    name: 'name',
    value: 'value',
    vifurushiPackageId: 'vifurushiPackageId'
  };

  export type ExamsUnsolvedDownloadScalarFieldEnum = (typeof ExamsUnsolvedDownloadScalarFieldEnum)[keyof typeof ExamsUnsolvedDownloadScalarFieldEnum]


  export const ExamsSolvedDownloadScalarFieldEnum: {
    id: 'id',
    name: 'name',
    value: 'value',
    vifurushiPackageId: 'vifurushiPackageId'
  };

  export type ExamsSolvedDownloadScalarFieldEnum = (typeof ExamsSolvedDownloadScalarFieldEnum)[keyof typeof ExamsSolvedDownloadScalarFieldEnum]


  export const ExamAccessScalarFieldEnum: {
    id: 'id',
    name: 'name',
    value: 'value',
    vifurushiPackageId: 'vifurushiPackageId'
  };

  export type ExamAccessScalarFieldEnum = (typeof ExamAccessScalarFieldEnum)[keyof typeof ExamAccessScalarFieldEnum]


  export const BooksDownloadScalarFieldEnum: {
    id: 'id',
    name: 'name',
    value: 'value',
    vifurushiPackageId: 'vifurushiPackageId'
  };

  export type BooksDownloadScalarFieldEnum = (typeof BooksDownloadScalarFieldEnum)[keyof typeof BooksDownloadScalarFieldEnum]


  export const PurchaseScalarFieldEnum: {
    id: 'id',
    name: 'name',
    value: 'value',
    usersId: 'usersId'
  };

  export type PurchaseScalarFieldEnum = (typeof PurchaseScalarFieldEnum)[keyof typeof PurchaseScalarFieldEnum]


  export const SubjectScalarFieldEnum: {
    id: 'id',
    subjectName: 'subjectName',
    subjectDefinition: 'subjectDefinition',
    imageLocation: 'imageLocation',
    published: 'published',
    usersId: 'usersId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubjectScalarFieldEnum = (typeof SubjectScalarFieldEnum)[keyof typeof SubjectScalarFieldEnum]


  export const FormScalarFieldEnum: {
    id: 'id',
    formName: 'formName',
    usersId: 'usersId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FormScalarFieldEnum = (typeof FormScalarFieldEnum)[keyof typeof FormScalarFieldEnum]


  export const TopicScalarFieldEnum: {
    id: 'id',
    topicName: 'topicName',
    topicDefinition: 'topicDefinition',
    published: 'published',
    subjectId: 'subjectId',
    formId: 'formId',
    usersId: 'usersId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TopicScalarFieldEnum = (typeof TopicScalarFieldEnum)[keyof typeof TopicScalarFieldEnum]


  export const NoteScalarFieldEnum: {
    id: 'id',
    content: 'content',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    published: 'published',
    subjectId: 'subjectId',
    formId: 'formId',
    usersId: 'usersId',
    topicId: 'topicId'
  };

  export type NoteScalarFieldEnum = (typeof NoteScalarFieldEnum)[keyof typeof NoteScalarFieldEnum]


  export const NotesDownloadableScalarFieldEnum: {
    id: 'id',
    link: 'link',
    fileExtension: 'fileExtension',
    published: 'published',
    formId: 'formId',
    subjectId: 'subjectId',
    usersId: 'usersId',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotesDownloadableScalarFieldEnum = (typeof NotesDownloadableScalarFieldEnum)[keyof typeof NotesDownloadableScalarFieldEnum]


  export const SubjectReviewScalarFieldEnum: {
    id: 'id',
    subjectName: 'subjectName',
    subjectDefinition: 'subjectDefinition',
    imageLocation: 'imageLocation',
    published: 'published',
    usersId: 'usersId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubjectReviewScalarFieldEnum = (typeof SubjectReviewScalarFieldEnum)[keyof typeof SubjectReviewScalarFieldEnum]


  export const FormReviewScalarFieldEnum: {
    id: 'id',
    formName: 'formName',
    usersId: 'usersId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FormReviewScalarFieldEnum = (typeof FormReviewScalarFieldEnum)[keyof typeof FormReviewScalarFieldEnum]


  export const TopicReviewScalarFieldEnum: {
    id: 'id',
    topicName: 'topicName',
    topicDefinition: 'topicDefinition',
    published: 'published',
    subjectId: 'subjectId',
    formId: 'formId',
    usersId: 'usersId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TopicReviewScalarFieldEnum = (typeof TopicReviewScalarFieldEnum)[keyof typeof TopicReviewScalarFieldEnum]


  export const ReviewScalarFieldEnum: {
    id: 'id',
    name: 'name',
    published: 'published',
    topicId: 'topicId',
    subjectId: 'subjectId',
    formId: 'formId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    usersId: 'usersId'
  };

  export type ReviewScalarFieldEnum = (typeof ReviewScalarFieldEnum)[keyof typeof ReviewScalarFieldEnum]


  export const QuestionScalarFieldEnum: {
    id: 'id',
    question: 'question',
    published: 'published',
    answerDetails: 'answerDetails',
    questionFormatId: 'questionFormatId',
    reviewId: 'reviewId',
    usersId: 'usersId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QuestionScalarFieldEnum = (typeof QuestionScalarFieldEnum)[keyof typeof QuestionScalarFieldEnum]


  export const QuestionFormatScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QuestionFormatScalarFieldEnum = (typeof QuestionFormatScalarFieldEnum)[keyof typeof QuestionFormatScalarFieldEnum]


  export const AnswerScalarFieldEnum: {
    id: 'id',
    answer: 'answer',
    valid: 'valid',
    questionId: 'questionId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AnswerScalarFieldEnum = (typeof AnswerScalarFieldEnum)[keyof typeof AnswerScalarFieldEnum]


  export const SubjectExamsScalarFieldEnum: {
    id: 'id',
    subjectName: 'subjectName',
    subjectDefinition: 'subjectDefinition',
    imageLocation: 'imageLocation',
    published: 'published',
    usersId: 'usersId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubjectExamsScalarFieldEnum = (typeof SubjectExamsScalarFieldEnum)[keyof typeof SubjectExamsScalarFieldEnum]


  export const FormExamsScalarFieldEnum: {
    id: 'id',
    formName: 'formName',
    usersId: 'usersId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FormExamsScalarFieldEnum = (typeof FormExamsScalarFieldEnum)[keyof typeof FormExamsScalarFieldEnum]


  export const ExamTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    definition: 'definition',
    published: 'published',
    subjectId: 'subjectId',
    formId: 'formId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExamTypeScalarFieldEnum = (typeof ExamTypeScalarFieldEnum)[keyof typeof ExamTypeScalarFieldEnum]


  export const ExamScalarFieldEnum: {
    id: 'id',
    description: 'description',
    year: 'year',
    hasAnswers: 'hasAnswers',
    published: 'published',
    examTypeId: 'examTypeId',
    exam: 'exam',
    usersId: 'usersId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExamScalarFieldEnum = (typeof ExamScalarFieldEnum)[keyof typeof ExamScalarFieldEnum]


  export const ExamDownloadableScalarFieldEnum: {
    id: 'id',
    link: 'link',
    fileExtension: 'fileExtension',
    published: 'published',
    examId: 'examId',
    usersId: 'usersId',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExamDownloadableScalarFieldEnum = (typeof ExamDownloadableScalarFieldEnum)[keyof typeof ExamDownloadableScalarFieldEnum]


  export const SubjectReferenceScalarFieldEnum: {
    id: 'id',
    subjectName: 'subjectName',
    subjectDefinition: 'subjectDefinition',
    imageLocation: 'imageLocation',
    published: 'published',
    usersId: 'usersId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubjectReferenceScalarFieldEnum = (typeof SubjectReferenceScalarFieldEnum)[keyof typeof SubjectReferenceScalarFieldEnum]


  export const FormReferenceScalarFieldEnum: {
    id: 'id',
    formName: 'formName',
    usersId: 'usersId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FormReferenceScalarFieldEnum = (typeof FormReferenceScalarFieldEnum)[keyof typeof FormReferenceScalarFieldEnum]


  export const ReferenceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    data: 'data',
    isPdf: 'isPdf',
    published: 'published',
    subjectId: 'subjectId',
    usersId: 'usersId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReferenceScalarFieldEnum = (typeof ReferenceScalarFieldEnum)[keyof typeof ReferenceScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const usersOrderByRelevanceFieldEnum: {
    image: 'image',
    username: 'username',
    password: 'password',
    name: 'name'
  };

  export type usersOrderByRelevanceFieldEnum = (typeof usersOrderByRelevanceFieldEnum)[keyof typeof usersOrderByRelevanceFieldEnum]


  export const vifurushiOrderByRelevanceFieldEnum: {
    name: 'name'
  };

  export type vifurushiOrderByRelevanceFieldEnum = (typeof vifurushiOrderByRelevanceFieldEnum)[keyof typeof vifurushiOrderByRelevanceFieldEnum]


  export const vifurushiPriceOrderByRelevanceFieldEnum: {
    name: 'name'
  };

  export type vifurushiPriceOrderByRelevanceFieldEnum = (typeof vifurushiPriceOrderByRelevanceFieldEnum)[keyof typeof vifurushiPriceOrderByRelevanceFieldEnum]


  export const vifurushiPackageOrderByRelevanceFieldEnum: {
    name: 'name'
  };

  export type vifurushiPackageOrderByRelevanceFieldEnum = (typeof vifurushiPackageOrderByRelevanceFieldEnum)[keyof typeof vifurushiPackageOrderByRelevanceFieldEnum]


  export const notesDownloadOrderByRelevanceFieldEnum: {
    name: 'name'
  };

  export type notesDownloadOrderByRelevanceFieldEnum = (typeof notesDownloadOrderByRelevanceFieldEnum)[keyof typeof notesDownloadOrderByRelevanceFieldEnum]


  export const quizExcercisesOrderByRelevanceFieldEnum: {
    name: 'name'
  };

  export type quizExcercisesOrderByRelevanceFieldEnum = (typeof quizExcercisesOrderByRelevanceFieldEnum)[keyof typeof quizExcercisesOrderByRelevanceFieldEnum]


  export const examsUnsolvedDownloadOrderByRelevanceFieldEnum: {
    name: 'name'
  };

  export type examsUnsolvedDownloadOrderByRelevanceFieldEnum = (typeof examsUnsolvedDownloadOrderByRelevanceFieldEnum)[keyof typeof examsUnsolvedDownloadOrderByRelevanceFieldEnum]


  export const examsSolvedDownloadOrderByRelevanceFieldEnum: {
    name: 'name'
  };

  export type examsSolvedDownloadOrderByRelevanceFieldEnum = (typeof examsSolvedDownloadOrderByRelevanceFieldEnum)[keyof typeof examsSolvedDownloadOrderByRelevanceFieldEnum]


  export const examAccessOrderByRelevanceFieldEnum: {
    name: 'name'
  };

  export type examAccessOrderByRelevanceFieldEnum = (typeof examAccessOrderByRelevanceFieldEnum)[keyof typeof examAccessOrderByRelevanceFieldEnum]


  export const booksDownloadOrderByRelevanceFieldEnum: {
    name: 'name'
  };

  export type booksDownloadOrderByRelevanceFieldEnum = (typeof booksDownloadOrderByRelevanceFieldEnum)[keyof typeof booksDownloadOrderByRelevanceFieldEnum]


  export const purchaseOrderByRelevanceFieldEnum: {
    name: 'name'
  };

  export type purchaseOrderByRelevanceFieldEnum = (typeof purchaseOrderByRelevanceFieldEnum)[keyof typeof purchaseOrderByRelevanceFieldEnum]


  export const subjectOrderByRelevanceFieldEnum: {
    subjectName: 'subjectName',
    subjectDefinition: 'subjectDefinition',
    imageLocation: 'imageLocation'
  };

  export type subjectOrderByRelevanceFieldEnum = (typeof subjectOrderByRelevanceFieldEnum)[keyof typeof subjectOrderByRelevanceFieldEnum]


  export const formOrderByRelevanceFieldEnum: {
    formName: 'formName'
  };

  export type formOrderByRelevanceFieldEnum = (typeof formOrderByRelevanceFieldEnum)[keyof typeof formOrderByRelevanceFieldEnum]


  export const topicOrderByRelevanceFieldEnum: {
    topicName: 'topicName',
    topicDefinition: 'topicDefinition'
  };

  export type topicOrderByRelevanceFieldEnum = (typeof topicOrderByRelevanceFieldEnum)[keyof typeof topicOrderByRelevanceFieldEnum]


  export const noteOrderByRelevanceFieldEnum: {
    content: 'content'
  };

  export type noteOrderByRelevanceFieldEnum = (typeof noteOrderByRelevanceFieldEnum)[keyof typeof noteOrderByRelevanceFieldEnum]


  export const notesDownloadableOrderByRelevanceFieldEnum: {
    link: 'link',
    fileExtension: 'fileExtension',
    name: 'name'
  };

  export type notesDownloadableOrderByRelevanceFieldEnum = (typeof notesDownloadableOrderByRelevanceFieldEnum)[keyof typeof notesDownloadableOrderByRelevanceFieldEnum]


  export const subjectReviewOrderByRelevanceFieldEnum: {
    subjectName: 'subjectName',
    subjectDefinition: 'subjectDefinition',
    imageLocation: 'imageLocation'
  };

  export type subjectReviewOrderByRelevanceFieldEnum = (typeof subjectReviewOrderByRelevanceFieldEnum)[keyof typeof subjectReviewOrderByRelevanceFieldEnum]


  export const formReviewOrderByRelevanceFieldEnum: {
    formName: 'formName'
  };

  export type formReviewOrderByRelevanceFieldEnum = (typeof formReviewOrderByRelevanceFieldEnum)[keyof typeof formReviewOrderByRelevanceFieldEnum]


  export const topicReviewOrderByRelevanceFieldEnum: {
    topicName: 'topicName',
    topicDefinition: 'topicDefinition'
  };

  export type topicReviewOrderByRelevanceFieldEnum = (typeof topicReviewOrderByRelevanceFieldEnum)[keyof typeof topicReviewOrderByRelevanceFieldEnum]


  export const reviewOrderByRelevanceFieldEnum: {
    name: 'name'
  };

  export type reviewOrderByRelevanceFieldEnum = (typeof reviewOrderByRelevanceFieldEnum)[keyof typeof reviewOrderByRelevanceFieldEnum]


  export const questionOrderByRelevanceFieldEnum: {
    question: 'question',
    answerDetails: 'answerDetails'
  };

  export type questionOrderByRelevanceFieldEnum = (typeof questionOrderByRelevanceFieldEnum)[keyof typeof questionOrderByRelevanceFieldEnum]


  export const questionFormatOrderByRelevanceFieldEnum: {
    name: 'name'
  };

  export type questionFormatOrderByRelevanceFieldEnum = (typeof questionFormatOrderByRelevanceFieldEnum)[keyof typeof questionFormatOrderByRelevanceFieldEnum]


  export const answerOrderByRelevanceFieldEnum: {
    answer: 'answer'
  };

  export type answerOrderByRelevanceFieldEnum = (typeof answerOrderByRelevanceFieldEnum)[keyof typeof answerOrderByRelevanceFieldEnum]


  export const subjectExamsOrderByRelevanceFieldEnum: {
    subjectName: 'subjectName',
    subjectDefinition: 'subjectDefinition',
    imageLocation: 'imageLocation'
  };

  export type subjectExamsOrderByRelevanceFieldEnum = (typeof subjectExamsOrderByRelevanceFieldEnum)[keyof typeof subjectExamsOrderByRelevanceFieldEnum]


  export const formExamsOrderByRelevanceFieldEnum: {
    formName: 'formName'
  };

  export type formExamsOrderByRelevanceFieldEnum = (typeof formExamsOrderByRelevanceFieldEnum)[keyof typeof formExamsOrderByRelevanceFieldEnum]


  export const examTypeOrderByRelevanceFieldEnum: {
    name: 'name',
    definition: 'definition'
  };

  export type examTypeOrderByRelevanceFieldEnum = (typeof examTypeOrderByRelevanceFieldEnum)[keyof typeof examTypeOrderByRelevanceFieldEnum]


  export const examOrderByRelevanceFieldEnum: {
    description: 'description',
    exam: 'exam'
  };

  export type examOrderByRelevanceFieldEnum = (typeof examOrderByRelevanceFieldEnum)[keyof typeof examOrderByRelevanceFieldEnum]


  export const examDownloadableOrderByRelevanceFieldEnum: {
    link: 'link',
    fileExtension: 'fileExtension',
    name: 'name'
  };

  export type examDownloadableOrderByRelevanceFieldEnum = (typeof examDownloadableOrderByRelevanceFieldEnum)[keyof typeof examDownloadableOrderByRelevanceFieldEnum]


  export const subjectReferenceOrderByRelevanceFieldEnum: {
    subjectName: 'subjectName',
    subjectDefinition: 'subjectDefinition',
    imageLocation: 'imageLocation'
  };

  export type subjectReferenceOrderByRelevanceFieldEnum = (typeof subjectReferenceOrderByRelevanceFieldEnum)[keyof typeof subjectReferenceOrderByRelevanceFieldEnum]


  export const formReferenceOrderByRelevanceFieldEnum: {
    formName: 'formName'
  };

  export type formReferenceOrderByRelevanceFieldEnum = (typeof formReferenceOrderByRelevanceFieldEnum)[keyof typeof formReferenceOrderByRelevanceFieldEnum]


  export const referenceOrderByRelevanceFieldEnum: {
    name: 'name',
    description: 'description',
    data: 'data'
  };

  export type referenceOrderByRelevanceFieldEnum = (typeof referenceOrderByRelevanceFieldEnum)[keyof typeof referenceOrderByRelevanceFieldEnum]


  /**
   * Deep Input Types
   */


  export type usersWhereInput = {
    AND?: Enumerable<usersWhereInput>
    OR?: Enumerable<usersWhereInput>
    NOT?: Enumerable<usersWhereInput>
    id?: IntFilter | number
    image?: StringNullableFilter | string | null
    username?: StringFilter | string
    password?: StringFilter | string
    isAdmin?: BoolFilter | boolean
    isSuperUser?: BoolFilter | boolean
    dateJoined?: DateTimeFilter | Date | string
    name?: StringFilter | string
    updatedAt?: DateTimeFilter | Date | string
    isOnline?: BoolFilter | boolean
    exam?: ExamListRelationFilter
    examDownloadable?: ExamDownloadableListRelationFilter
    form?: FormListRelationFilter
    formExams?: FormExamsListRelationFilter
    formReference?: FormReferenceListRelationFilter
    formReview?: FormReviewListRelationFilter
    note?: NoteListRelationFilter
    notesDownloadable?: NotesDownloadableListRelationFilter
    purchase?: PurchaseListRelationFilter
    question?: QuestionListRelationFilter
    reference?: ReferenceListRelationFilter
    review?: ReviewListRelationFilter
    subject?: SubjectListRelationFilter
    subjectExams?: SubjectExamsListRelationFilter
    subjectReference?: SubjectReferenceListRelationFilter
    subjectReview?: SubjectReviewListRelationFilter
    topic?: TopicListRelationFilter
    topicReview?: TopicReviewListRelationFilter
    vifurushi?: VifurushiListRelationFilter
  }

  export type usersOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    image?: SortOrder
    username?: SortOrder
    password?: SortOrder
    isAdmin?: SortOrder
    isSuperUser?: SortOrder
    dateJoined?: SortOrder
    name?: SortOrder
    updatedAt?: SortOrder
    isOnline?: SortOrder
    exam?: examOrderByRelationAggregateInput
    examDownloadable?: examDownloadableOrderByRelationAggregateInput
    form?: formOrderByRelationAggregateInput
    formExams?: formExamsOrderByRelationAggregateInput
    formReference?: formReferenceOrderByRelationAggregateInput
    formReview?: formReviewOrderByRelationAggregateInput
    note?: noteOrderByRelationAggregateInput
    notesDownloadable?: notesDownloadableOrderByRelationAggregateInput
    purchase?: purchaseOrderByRelationAggregateInput
    question?: questionOrderByRelationAggregateInput
    reference?: referenceOrderByRelationAggregateInput
    review?: reviewOrderByRelationAggregateInput
    subject?: subjectOrderByRelationAggregateInput
    subjectExams?: subjectExamsOrderByRelationAggregateInput
    subjectReference?: subjectReferenceOrderByRelationAggregateInput
    subjectReview?: subjectReviewOrderByRelationAggregateInput
    topic?: topicOrderByRelationAggregateInput
    topicReview?: topicReviewOrderByRelationAggregateInput
    vifurushi?: vifurushiOrderByRelationAggregateInput
    _relevance?: usersOrderByRelevanceInput
  }

  export type usersWhereUniqueInput = {
    id?: number
  }

  export type usersOrderByWithAggregationInput = {
    id?: SortOrder
    image?: SortOrder
    username?: SortOrder
    password?: SortOrder
    isAdmin?: SortOrder
    isSuperUser?: SortOrder
    dateJoined?: SortOrder
    name?: SortOrder
    updatedAt?: SortOrder
    isOnline?: SortOrder
    _count?: usersCountOrderByAggregateInput
    _avg?: usersAvgOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
    _sum?: usersSumOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: Enumerable<usersScalarWhereWithAggregatesInput>
    OR?: Enumerable<usersScalarWhereWithAggregatesInput>
    NOT?: Enumerable<usersScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    image?: StringNullableWithAggregatesFilter | string | null
    username?: StringWithAggregatesFilter | string
    password?: StringWithAggregatesFilter | string
    isAdmin?: BoolWithAggregatesFilter | boolean
    isSuperUser?: BoolWithAggregatesFilter | boolean
    dateJoined?: DateTimeWithAggregatesFilter | Date | string
    name?: StringWithAggregatesFilter | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    isOnline?: BoolWithAggregatesFilter | boolean
  }

  export type vifurushiWhereInput = {
    AND?: Enumerable<vifurushiWhereInput>
    OR?: Enumerable<vifurushiWhereInput>
    NOT?: Enumerable<vifurushiWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    value?: IntFilter | number
    usersId?: IntFilter | number
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type vifurushiOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    usersId?: SortOrder
    users?: usersOrderByWithRelationAndSearchRelevanceInput
    _relevance?: vifurushiOrderByRelevanceInput
  }

  export type vifurushiWhereUniqueInput = {
    id?: number
  }

  export type vifurushiOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    usersId?: SortOrder
    _count?: vifurushiCountOrderByAggregateInput
    _avg?: vifurushiAvgOrderByAggregateInput
    _max?: vifurushiMaxOrderByAggregateInput
    _min?: vifurushiMinOrderByAggregateInput
    _sum?: vifurushiSumOrderByAggregateInput
  }

  export type vifurushiScalarWhereWithAggregatesInput = {
    AND?: Enumerable<vifurushiScalarWhereWithAggregatesInput>
    OR?: Enumerable<vifurushiScalarWhereWithAggregatesInput>
    NOT?: Enumerable<vifurushiScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    value?: IntWithAggregatesFilter | number
    usersId?: IntWithAggregatesFilter | number
  }

  export type vifurushiPriceWhereInput = {
    AND?: Enumerable<vifurushiPriceWhereInput>
    OR?: Enumerable<vifurushiPriceWhereInput>
    NOT?: Enumerable<vifurushiPriceWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    price?: IntFilter | number
  }

  export type vifurushiPriceOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    _relevance?: vifurushiPriceOrderByRelevanceInput
  }

  export type vifurushiPriceWhereUniqueInput = {
    id?: number
  }

  export type vifurushiPriceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    _count?: vifurushiPriceCountOrderByAggregateInput
    _avg?: vifurushiPriceAvgOrderByAggregateInput
    _max?: vifurushiPriceMaxOrderByAggregateInput
    _min?: vifurushiPriceMinOrderByAggregateInput
    _sum?: vifurushiPriceSumOrderByAggregateInput
  }

  export type vifurushiPriceScalarWhereWithAggregatesInput = {
    AND?: Enumerable<vifurushiPriceScalarWhereWithAggregatesInput>
    OR?: Enumerable<vifurushiPriceScalarWhereWithAggregatesInput>
    NOT?: Enumerable<vifurushiPriceScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    price?: IntWithAggregatesFilter | number
  }

  export type vifurushiPackageWhereInput = {
    AND?: Enumerable<vifurushiPackageWhereInput>
    OR?: Enumerable<vifurushiPackageWhereInput>
    NOT?: Enumerable<vifurushiPackageWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    value?: IntFilter | number
    booksDownload?: XOR<BooksDownloadRelationFilter, booksDownloadWhereInput> | null
    examAccess?: XOR<ExamAccessRelationFilter, examAccessWhereInput> | null
    examsSolvedDownload?: XOR<ExamsSolvedDownloadRelationFilter, examsSolvedDownloadWhereInput> | null
    examsUnsolvedDownload?: XOR<ExamsUnsolvedDownloadRelationFilter, examsUnsolvedDownloadWhereInput> | null
    notesDownload?: XOR<NotesDownloadRelationFilter, notesDownloadWhereInput> | null
    quizExcercises?: XOR<QuizExcercisesRelationFilter, quizExcercisesWhereInput> | null
  }

  export type vifurushiPackageOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    booksDownload?: booksDownloadOrderByWithRelationAndSearchRelevanceInput
    examAccess?: examAccessOrderByWithRelationAndSearchRelevanceInput
    examsSolvedDownload?: examsSolvedDownloadOrderByWithRelationAndSearchRelevanceInput
    examsUnsolvedDownload?: examsUnsolvedDownloadOrderByWithRelationAndSearchRelevanceInput
    notesDownload?: notesDownloadOrderByWithRelationAndSearchRelevanceInput
    quizExcercises?: quizExcercisesOrderByWithRelationAndSearchRelevanceInput
    _relevance?: vifurushiPackageOrderByRelevanceInput
  }

  export type vifurushiPackageWhereUniqueInput = {
    id?: number
  }

  export type vifurushiPackageOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    _count?: vifurushiPackageCountOrderByAggregateInput
    _avg?: vifurushiPackageAvgOrderByAggregateInput
    _max?: vifurushiPackageMaxOrderByAggregateInput
    _min?: vifurushiPackageMinOrderByAggregateInput
    _sum?: vifurushiPackageSumOrderByAggregateInput
  }

  export type vifurushiPackageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<vifurushiPackageScalarWhereWithAggregatesInput>
    OR?: Enumerable<vifurushiPackageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<vifurushiPackageScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    value?: IntWithAggregatesFilter | number
  }

  export type notesDownloadWhereInput = {
    AND?: Enumerable<notesDownloadWhereInput>
    OR?: Enumerable<notesDownloadWhereInput>
    NOT?: Enumerable<notesDownloadWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    value?: IntFilter | number
    vifurushiPackageId?: IntFilter | number
    vifurushiPackage?: XOR<VifurushiPackageRelationFilter, vifurushiPackageWhereInput>
  }

  export type notesDownloadOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    vifurushiPackageId?: SortOrder
    vifurushiPackage?: vifurushiPackageOrderByWithRelationAndSearchRelevanceInput
    _relevance?: notesDownloadOrderByRelevanceInput
  }

  export type notesDownloadWhereUniqueInput = {
    id?: number
    vifurushiPackageId?: number
  }

  export type notesDownloadOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    vifurushiPackageId?: SortOrder
    _count?: notesDownloadCountOrderByAggregateInput
    _avg?: notesDownloadAvgOrderByAggregateInput
    _max?: notesDownloadMaxOrderByAggregateInput
    _min?: notesDownloadMinOrderByAggregateInput
    _sum?: notesDownloadSumOrderByAggregateInput
  }

  export type notesDownloadScalarWhereWithAggregatesInput = {
    AND?: Enumerable<notesDownloadScalarWhereWithAggregatesInput>
    OR?: Enumerable<notesDownloadScalarWhereWithAggregatesInput>
    NOT?: Enumerable<notesDownloadScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    value?: IntWithAggregatesFilter | number
    vifurushiPackageId?: IntWithAggregatesFilter | number
  }

  export type quizExcercisesWhereInput = {
    AND?: Enumerable<quizExcercisesWhereInput>
    OR?: Enumerable<quizExcercisesWhereInput>
    NOT?: Enumerable<quizExcercisesWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    value?: IntFilter | number
    vifurushiPackageId?: IntFilter | number
    vifurushiPackage?: XOR<VifurushiPackageRelationFilter, vifurushiPackageWhereInput>
  }

  export type quizExcercisesOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    vifurushiPackageId?: SortOrder
    vifurushiPackage?: vifurushiPackageOrderByWithRelationAndSearchRelevanceInput
    _relevance?: quizExcercisesOrderByRelevanceInput
  }

  export type quizExcercisesWhereUniqueInput = {
    id?: number
    vifurushiPackageId?: number
  }

  export type quizExcercisesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    vifurushiPackageId?: SortOrder
    _count?: quizExcercisesCountOrderByAggregateInput
    _avg?: quizExcercisesAvgOrderByAggregateInput
    _max?: quizExcercisesMaxOrderByAggregateInput
    _min?: quizExcercisesMinOrderByAggregateInput
    _sum?: quizExcercisesSumOrderByAggregateInput
  }

  export type quizExcercisesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<quizExcercisesScalarWhereWithAggregatesInput>
    OR?: Enumerable<quizExcercisesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<quizExcercisesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    value?: IntWithAggregatesFilter | number
    vifurushiPackageId?: IntWithAggregatesFilter | number
  }

  export type examsUnsolvedDownloadWhereInput = {
    AND?: Enumerable<examsUnsolvedDownloadWhereInput>
    OR?: Enumerable<examsUnsolvedDownloadWhereInput>
    NOT?: Enumerable<examsUnsolvedDownloadWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    value?: IntFilter | number
    vifurushiPackageId?: IntFilter | number
    vifurushiPackage?: XOR<VifurushiPackageRelationFilter, vifurushiPackageWhereInput>
  }

  export type examsUnsolvedDownloadOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    vifurushiPackageId?: SortOrder
    vifurushiPackage?: vifurushiPackageOrderByWithRelationAndSearchRelevanceInput
    _relevance?: examsUnsolvedDownloadOrderByRelevanceInput
  }

  export type examsUnsolvedDownloadWhereUniqueInput = {
    id?: number
    vifurushiPackageId?: number
  }

  export type examsUnsolvedDownloadOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    vifurushiPackageId?: SortOrder
    _count?: examsUnsolvedDownloadCountOrderByAggregateInput
    _avg?: examsUnsolvedDownloadAvgOrderByAggregateInput
    _max?: examsUnsolvedDownloadMaxOrderByAggregateInput
    _min?: examsUnsolvedDownloadMinOrderByAggregateInput
    _sum?: examsUnsolvedDownloadSumOrderByAggregateInput
  }

  export type examsUnsolvedDownloadScalarWhereWithAggregatesInput = {
    AND?: Enumerable<examsUnsolvedDownloadScalarWhereWithAggregatesInput>
    OR?: Enumerable<examsUnsolvedDownloadScalarWhereWithAggregatesInput>
    NOT?: Enumerable<examsUnsolvedDownloadScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    value?: IntWithAggregatesFilter | number
    vifurushiPackageId?: IntWithAggregatesFilter | number
  }

  export type examsSolvedDownloadWhereInput = {
    AND?: Enumerable<examsSolvedDownloadWhereInput>
    OR?: Enumerable<examsSolvedDownloadWhereInput>
    NOT?: Enumerable<examsSolvedDownloadWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    value?: IntFilter | number
    vifurushiPackageId?: IntFilter | number
    vifurushiPackage?: XOR<VifurushiPackageRelationFilter, vifurushiPackageWhereInput>
  }

  export type examsSolvedDownloadOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    vifurushiPackageId?: SortOrder
    vifurushiPackage?: vifurushiPackageOrderByWithRelationAndSearchRelevanceInput
    _relevance?: examsSolvedDownloadOrderByRelevanceInput
  }

  export type examsSolvedDownloadWhereUniqueInput = {
    id?: number
    vifurushiPackageId?: number
  }

  export type examsSolvedDownloadOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    vifurushiPackageId?: SortOrder
    _count?: examsSolvedDownloadCountOrderByAggregateInput
    _avg?: examsSolvedDownloadAvgOrderByAggregateInput
    _max?: examsSolvedDownloadMaxOrderByAggregateInput
    _min?: examsSolvedDownloadMinOrderByAggregateInput
    _sum?: examsSolvedDownloadSumOrderByAggregateInput
  }

  export type examsSolvedDownloadScalarWhereWithAggregatesInput = {
    AND?: Enumerable<examsSolvedDownloadScalarWhereWithAggregatesInput>
    OR?: Enumerable<examsSolvedDownloadScalarWhereWithAggregatesInput>
    NOT?: Enumerable<examsSolvedDownloadScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    value?: IntWithAggregatesFilter | number
    vifurushiPackageId?: IntWithAggregatesFilter | number
  }

  export type examAccessWhereInput = {
    AND?: Enumerable<examAccessWhereInput>
    OR?: Enumerable<examAccessWhereInput>
    NOT?: Enumerable<examAccessWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    value?: IntFilter | number
    vifurushiPackageId?: IntFilter | number
    vifurushiPackage?: XOR<VifurushiPackageRelationFilter, vifurushiPackageWhereInput>
  }

  export type examAccessOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    vifurushiPackageId?: SortOrder
    vifurushiPackage?: vifurushiPackageOrderByWithRelationAndSearchRelevanceInput
    _relevance?: examAccessOrderByRelevanceInput
  }

  export type examAccessWhereUniqueInput = {
    id?: number
    vifurushiPackageId?: number
  }

  export type examAccessOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    vifurushiPackageId?: SortOrder
    _count?: examAccessCountOrderByAggregateInput
    _avg?: examAccessAvgOrderByAggregateInput
    _max?: examAccessMaxOrderByAggregateInput
    _min?: examAccessMinOrderByAggregateInput
    _sum?: examAccessSumOrderByAggregateInput
  }

  export type examAccessScalarWhereWithAggregatesInput = {
    AND?: Enumerable<examAccessScalarWhereWithAggregatesInput>
    OR?: Enumerable<examAccessScalarWhereWithAggregatesInput>
    NOT?: Enumerable<examAccessScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    value?: IntWithAggregatesFilter | number
    vifurushiPackageId?: IntWithAggregatesFilter | number
  }

  export type booksDownloadWhereInput = {
    AND?: Enumerable<booksDownloadWhereInput>
    OR?: Enumerable<booksDownloadWhereInput>
    NOT?: Enumerable<booksDownloadWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    value?: IntFilter | number
    vifurushiPackageId?: IntFilter | number
    vifurushiPackage?: XOR<VifurushiPackageRelationFilter, vifurushiPackageWhereInput>
  }

  export type booksDownloadOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    vifurushiPackageId?: SortOrder
    vifurushiPackage?: vifurushiPackageOrderByWithRelationAndSearchRelevanceInput
    _relevance?: booksDownloadOrderByRelevanceInput
  }

  export type booksDownloadWhereUniqueInput = {
    id?: number
    vifurushiPackageId?: number
  }

  export type booksDownloadOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    vifurushiPackageId?: SortOrder
    _count?: booksDownloadCountOrderByAggregateInput
    _avg?: booksDownloadAvgOrderByAggregateInput
    _max?: booksDownloadMaxOrderByAggregateInput
    _min?: booksDownloadMinOrderByAggregateInput
    _sum?: booksDownloadSumOrderByAggregateInput
  }

  export type booksDownloadScalarWhereWithAggregatesInput = {
    AND?: Enumerable<booksDownloadScalarWhereWithAggregatesInput>
    OR?: Enumerable<booksDownloadScalarWhereWithAggregatesInput>
    NOT?: Enumerable<booksDownloadScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    value?: IntWithAggregatesFilter | number
    vifurushiPackageId?: IntWithAggregatesFilter | number
  }

  export type purchaseWhereInput = {
    AND?: Enumerable<purchaseWhereInput>
    OR?: Enumerable<purchaseWhereInput>
    NOT?: Enumerable<purchaseWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    value?: IntFilter | number
    usersId?: IntFilter | number
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type purchaseOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    usersId?: SortOrder
    users?: usersOrderByWithRelationAndSearchRelevanceInput
    _relevance?: purchaseOrderByRelevanceInput
  }

  export type purchaseWhereUniqueInput = {
    id?: number
  }

  export type purchaseOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    usersId?: SortOrder
    _count?: purchaseCountOrderByAggregateInput
    _avg?: purchaseAvgOrderByAggregateInput
    _max?: purchaseMaxOrderByAggregateInput
    _min?: purchaseMinOrderByAggregateInput
    _sum?: purchaseSumOrderByAggregateInput
  }

  export type purchaseScalarWhereWithAggregatesInput = {
    AND?: Enumerable<purchaseScalarWhereWithAggregatesInput>
    OR?: Enumerable<purchaseScalarWhereWithAggregatesInput>
    NOT?: Enumerable<purchaseScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    value?: IntWithAggregatesFilter | number
    usersId?: IntWithAggregatesFilter | number
  }

  export type subjectWhereInput = {
    AND?: Enumerable<subjectWhereInput>
    OR?: Enumerable<subjectWhereInput>
    NOT?: Enumerable<subjectWhereInput>
    id?: IntFilter | number
    subjectName?: StringFilter | string
    subjectDefinition?: StringFilter | string
    imageLocation?: StringNullableFilter | string | null
    published?: BoolFilter | boolean
    usersId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    users?: XOR<UsersRelationFilter, usersWhereInput>
    note?: NoteListRelationFilter
    notesDownloadable?: NotesDownloadableListRelationFilter
    topic?: TopicListRelationFilter
    forms?: FormListRelationFilter
  }

  export type subjectOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    subjectName?: SortOrder
    subjectDefinition?: SortOrder
    imageLocation?: SortOrder
    published?: SortOrder
    usersId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: usersOrderByWithRelationAndSearchRelevanceInput
    note?: noteOrderByRelationAggregateInput
    notesDownloadable?: notesDownloadableOrderByRelationAggregateInput
    topic?: topicOrderByRelationAggregateInput
    forms?: formOrderByRelationAggregateInput
    _relevance?: subjectOrderByRelevanceInput
  }

  export type subjectWhereUniqueInput = {
    id?: number
  }

  export type subjectOrderByWithAggregationInput = {
    id?: SortOrder
    subjectName?: SortOrder
    subjectDefinition?: SortOrder
    imageLocation?: SortOrder
    published?: SortOrder
    usersId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: subjectCountOrderByAggregateInput
    _avg?: subjectAvgOrderByAggregateInput
    _max?: subjectMaxOrderByAggregateInput
    _min?: subjectMinOrderByAggregateInput
    _sum?: subjectSumOrderByAggregateInput
  }

  export type subjectScalarWhereWithAggregatesInput = {
    AND?: Enumerable<subjectScalarWhereWithAggregatesInput>
    OR?: Enumerable<subjectScalarWhereWithAggregatesInput>
    NOT?: Enumerable<subjectScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    subjectName?: StringWithAggregatesFilter | string
    subjectDefinition?: StringWithAggregatesFilter | string
    imageLocation?: StringNullableWithAggregatesFilter | string | null
    published?: BoolWithAggregatesFilter | boolean
    usersId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type formWhereInput = {
    AND?: Enumerable<formWhereInput>
    OR?: Enumerable<formWhereInput>
    NOT?: Enumerable<formWhereInput>
    id?: IntFilter | number
    formName?: StringFilter | string
    usersId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    users?: XOR<UsersRelationFilter, usersWhereInput>
    note?: NoteListRelationFilter
    notesDownloadable?: NotesDownloadableListRelationFilter
    topic?: TopicListRelationFilter
    subjects?: SubjectListRelationFilter
  }

  export type formOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    formName?: SortOrder
    usersId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: usersOrderByWithRelationAndSearchRelevanceInput
    note?: noteOrderByRelationAggregateInput
    notesDownloadable?: notesDownloadableOrderByRelationAggregateInput
    topic?: topicOrderByRelationAggregateInput
    subjects?: subjectOrderByRelationAggregateInput
    _relevance?: formOrderByRelevanceInput
  }

  export type formWhereUniqueInput = {
    id?: number
  }

  export type formOrderByWithAggregationInput = {
    id?: SortOrder
    formName?: SortOrder
    usersId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: formCountOrderByAggregateInput
    _avg?: formAvgOrderByAggregateInput
    _max?: formMaxOrderByAggregateInput
    _min?: formMinOrderByAggregateInput
    _sum?: formSumOrderByAggregateInput
  }

  export type formScalarWhereWithAggregatesInput = {
    AND?: Enumerable<formScalarWhereWithAggregatesInput>
    OR?: Enumerable<formScalarWhereWithAggregatesInput>
    NOT?: Enumerable<formScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    formName?: StringWithAggregatesFilter | string
    usersId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type topicWhereInput = {
    AND?: Enumerable<topicWhereInput>
    OR?: Enumerable<topicWhereInput>
    NOT?: Enumerable<topicWhereInput>
    id?: IntFilter | number
    topicName?: StringFilter | string
    topicDefinition?: StringNullableFilter | string | null
    published?: BoolFilter | boolean
    subjectId?: IntFilter | number
    formId?: IntFilter | number
    usersId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    form?: XOR<FormRelationFilter, formWhereInput>
    subject?: XOR<SubjectRelationFilter, subjectWhereInput>
    users?: XOR<UsersRelationFilter, usersWhereInput>
    note?: XOR<NoteRelationFilter, noteWhereInput> | null
  }

  export type topicOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    topicName?: SortOrder
    topicDefinition?: SortOrder
    published?: SortOrder
    subjectId?: SortOrder
    formId?: SortOrder
    usersId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    form?: formOrderByWithRelationAndSearchRelevanceInput
    subject?: subjectOrderByWithRelationAndSearchRelevanceInput
    users?: usersOrderByWithRelationAndSearchRelevanceInput
    note?: noteOrderByWithRelationAndSearchRelevanceInput
    _relevance?: topicOrderByRelevanceInput
  }

  export type topicWhereUniqueInput = {
    id?: number
  }

  export type topicOrderByWithAggregationInput = {
    id?: SortOrder
    topicName?: SortOrder
    topicDefinition?: SortOrder
    published?: SortOrder
    subjectId?: SortOrder
    formId?: SortOrder
    usersId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: topicCountOrderByAggregateInput
    _avg?: topicAvgOrderByAggregateInput
    _max?: topicMaxOrderByAggregateInput
    _min?: topicMinOrderByAggregateInput
    _sum?: topicSumOrderByAggregateInput
  }

  export type topicScalarWhereWithAggregatesInput = {
    AND?: Enumerable<topicScalarWhereWithAggregatesInput>
    OR?: Enumerable<topicScalarWhereWithAggregatesInput>
    NOT?: Enumerable<topicScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    topicName?: StringWithAggregatesFilter | string
    topicDefinition?: StringNullableWithAggregatesFilter | string | null
    published?: BoolWithAggregatesFilter | boolean
    subjectId?: IntWithAggregatesFilter | number
    formId?: IntWithAggregatesFilter | number
    usersId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type noteWhereInput = {
    AND?: Enumerable<noteWhereInput>
    OR?: Enumerable<noteWhereInput>
    NOT?: Enumerable<noteWhereInput>
    id?: IntFilter | number
    content?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    published?: BoolFilter | boolean
    subjectId?: IntFilter | number
    formId?: IntFilter | number
    usersId?: IntFilter | number
    topicId?: IntFilter | number
    form?: XOR<FormRelationFilter, formWhereInput>
    subject?: XOR<SubjectRelationFilter, subjectWhereInput>
    topic?: XOR<TopicRelationFilter, topicWhereInput>
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type noteOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    published?: SortOrder
    subjectId?: SortOrder
    formId?: SortOrder
    usersId?: SortOrder
    topicId?: SortOrder
    form?: formOrderByWithRelationAndSearchRelevanceInput
    subject?: subjectOrderByWithRelationAndSearchRelevanceInput
    topic?: topicOrderByWithRelationAndSearchRelevanceInput
    users?: usersOrderByWithRelationAndSearchRelevanceInput
    _relevance?: noteOrderByRelevanceInput
  }

  export type noteWhereUniqueInput = {
    id?: number
    topicId?: number
  }

  export type noteOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    published?: SortOrder
    subjectId?: SortOrder
    formId?: SortOrder
    usersId?: SortOrder
    topicId?: SortOrder
    _count?: noteCountOrderByAggregateInput
    _avg?: noteAvgOrderByAggregateInput
    _max?: noteMaxOrderByAggregateInput
    _min?: noteMinOrderByAggregateInput
    _sum?: noteSumOrderByAggregateInput
  }

  export type noteScalarWhereWithAggregatesInput = {
    AND?: Enumerable<noteScalarWhereWithAggregatesInput>
    OR?: Enumerable<noteScalarWhereWithAggregatesInput>
    NOT?: Enumerable<noteScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    content?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    published?: BoolWithAggregatesFilter | boolean
    subjectId?: IntWithAggregatesFilter | number
    formId?: IntWithAggregatesFilter | number
    usersId?: IntWithAggregatesFilter | number
    topicId?: IntWithAggregatesFilter | number
  }

  export type notesDownloadableWhereInput = {
    AND?: Enumerable<notesDownloadableWhereInput>
    OR?: Enumerable<notesDownloadableWhereInput>
    NOT?: Enumerable<notesDownloadableWhereInput>
    id?: IntFilter | number
    link?: StringFilter | string
    fileExtension?: StringFilter | string
    published?: BoolFilter | boolean
    formId?: IntFilter | number
    subjectId?: IntFilter | number
    usersId?: IntFilter | number
    name?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    form?: XOR<FormRelationFilter, formWhereInput>
    subject?: XOR<SubjectRelationFilter, subjectWhereInput>
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type notesDownloadableOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    link?: SortOrder
    fileExtension?: SortOrder
    published?: SortOrder
    formId?: SortOrder
    subjectId?: SortOrder
    usersId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    form?: formOrderByWithRelationAndSearchRelevanceInput
    subject?: subjectOrderByWithRelationAndSearchRelevanceInput
    users?: usersOrderByWithRelationAndSearchRelevanceInput
    _relevance?: notesDownloadableOrderByRelevanceInput
  }

  export type notesDownloadableWhereUniqueInput = {
    id?: number
  }

  export type notesDownloadableOrderByWithAggregationInput = {
    id?: SortOrder
    link?: SortOrder
    fileExtension?: SortOrder
    published?: SortOrder
    formId?: SortOrder
    subjectId?: SortOrder
    usersId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: notesDownloadableCountOrderByAggregateInput
    _avg?: notesDownloadableAvgOrderByAggregateInput
    _max?: notesDownloadableMaxOrderByAggregateInput
    _min?: notesDownloadableMinOrderByAggregateInput
    _sum?: notesDownloadableSumOrderByAggregateInput
  }

  export type notesDownloadableScalarWhereWithAggregatesInput = {
    AND?: Enumerable<notesDownloadableScalarWhereWithAggregatesInput>
    OR?: Enumerable<notesDownloadableScalarWhereWithAggregatesInput>
    NOT?: Enumerable<notesDownloadableScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    link?: StringWithAggregatesFilter | string
    fileExtension?: StringWithAggregatesFilter | string
    published?: BoolWithAggregatesFilter | boolean
    formId?: IntWithAggregatesFilter | number
    subjectId?: IntWithAggregatesFilter | number
    usersId?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type subjectReviewWhereInput = {
    AND?: Enumerable<subjectReviewWhereInput>
    OR?: Enumerable<subjectReviewWhereInput>
    NOT?: Enumerable<subjectReviewWhereInput>
    id?: IntFilter | number
    subjectName?: StringFilter | string
    subjectDefinition?: StringFilter | string
    imageLocation?: StringNullableFilter | string | null
    published?: BoolFilter | boolean
    usersId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    users?: XOR<UsersRelationFilter, usersWhereInput>
    review?: ReviewListRelationFilter
    topic?: TopicReviewListRelationFilter
    forms?: FormReviewListRelationFilter
  }

  export type subjectReviewOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    subjectName?: SortOrder
    subjectDefinition?: SortOrder
    imageLocation?: SortOrder
    published?: SortOrder
    usersId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: usersOrderByWithRelationAndSearchRelevanceInput
    review?: reviewOrderByRelationAggregateInput
    topic?: topicReviewOrderByRelationAggregateInput
    forms?: formReviewOrderByRelationAggregateInput
    _relevance?: subjectReviewOrderByRelevanceInput
  }

  export type subjectReviewWhereUniqueInput = {
    id?: number
  }

  export type subjectReviewOrderByWithAggregationInput = {
    id?: SortOrder
    subjectName?: SortOrder
    subjectDefinition?: SortOrder
    imageLocation?: SortOrder
    published?: SortOrder
    usersId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: subjectReviewCountOrderByAggregateInput
    _avg?: subjectReviewAvgOrderByAggregateInput
    _max?: subjectReviewMaxOrderByAggregateInput
    _min?: subjectReviewMinOrderByAggregateInput
    _sum?: subjectReviewSumOrderByAggregateInput
  }

  export type subjectReviewScalarWhereWithAggregatesInput = {
    AND?: Enumerable<subjectReviewScalarWhereWithAggregatesInput>
    OR?: Enumerable<subjectReviewScalarWhereWithAggregatesInput>
    NOT?: Enumerable<subjectReviewScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    subjectName?: StringWithAggregatesFilter | string
    subjectDefinition?: StringWithAggregatesFilter | string
    imageLocation?: StringNullableWithAggregatesFilter | string | null
    published?: BoolWithAggregatesFilter | boolean
    usersId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type formReviewWhereInput = {
    AND?: Enumerable<formReviewWhereInput>
    OR?: Enumerable<formReviewWhereInput>
    NOT?: Enumerable<formReviewWhereInput>
    id?: IntFilter | number
    formName?: StringFilter | string
    usersId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    users?: XOR<UsersRelationFilter, usersWhereInput>
    review?: ReviewListRelationFilter
    topic?: TopicReviewListRelationFilter
    subjects?: SubjectReviewListRelationFilter
  }

  export type formReviewOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    formName?: SortOrder
    usersId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: usersOrderByWithRelationAndSearchRelevanceInput
    review?: reviewOrderByRelationAggregateInput
    topic?: topicReviewOrderByRelationAggregateInput
    subjects?: subjectReviewOrderByRelationAggregateInput
    _relevance?: formReviewOrderByRelevanceInput
  }

  export type formReviewWhereUniqueInput = {
    id?: number
  }

  export type formReviewOrderByWithAggregationInput = {
    id?: SortOrder
    formName?: SortOrder
    usersId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: formReviewCountOrderByAggregateInput
    _avg?: formReviewAvgOrderByAggregateInput
    _max?: formReviewMaxOrderByAggregateInput
    _min?: formReviewMinOrderByAggregateInput
    _sum?: formReviewSumOrderByAggregateInput
  }

  export type formReviewScalarWhereWithAggregatesInput = {
    AND?: Enumerable<formReviewScalarWhereWithAggregatesInput>
    OR?: Enumerable<formReviewScalarWhereWithAggregatesInput>
    NOT?: Enumerable<formReviewScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    formName?: StringWithAggregatesFilter | string
    usersId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type topicReviewWhereInput = {
    AND?: Enumerable<topicReviewWhereInput>
    OR?: Enumerable<topicReviewWhereInput>
    NOT?: Enumerable<topicReviewWhereInput>
    id?: IntFilter | number
    topicName?: StringFilter | string
    topicDefinition?: StringNullableFilter | string | null
    published?: BoolFilter | boolean
    subjectId?: IntFilter | number
    formId?: IntFilter | number
    usersId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    form?: XOR<FormReviewRelationFilter, formReviewWhereInput>
    subject?: XOR<SubjectReviewRelationFilter, subjectReviewWhereInput>
    users?: XOR<UsersRelationFilter, usersWhereInput>
    review?: ReviewListRelationFilter
  }

  export type topicReviewOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    topicName?: SortOrder
    topicDefinition?: SortOrder
    published?: SortOrder
    subjectId?: SortOrder
    formId?: SortOrder
    usersId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    form?: formReviewOrderByWithRelationAndSearchRelevanceInput
    subject?: subjectReviewOrderByWithRelationAndSearchRelevanceInput
    users?: usersOrderByWithRelationAndSearchRelevanceInput
    review?: reviewOrderByRelationAggregateInput
    _relevance?: topicReviewOrderByRelevanceInput
  }

  export type topicReviewWhereUniqueInput = {
    id?: number
  }

  export type topicReviewOrderByWithAggregationInput = {
    id?: SortOrder
    topicName?: SortOrder
    topicDefinition?: SortOrder
    published?: SortOrder
    subjectId?: SortOrder
    formId?: SortOrder
    usersId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: topicReviewCountOrderByAggregateInput
    _avg?: topicReviewAvgOrderByAggregateInput
    _max?: topicReviewMaxOrderByAggregateInput
    _min?: topicReviewMinOrderByAggregateInput
    _sum?: topicReviewSumOrderByAggregateInput
  }

  export type topicReviewScalarWhereWithAggregatesInput = {
    AND?: Enumerable<topicReviewScalarWhereWithAggregatesInput>
    OR?: Enumerable<topicReviewScalarWhereWithAggregatesInput>
    NOT?: Enumerable<topicReviewScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    topicName?: StringWithAggregatesFilter | string
    topicDefinition?: StringNullableWithAggregatesFilter | string | null
    published?: BoolWithAggregatesFilter | boolean
    subjectId?: IntWithAggregatesFilter | number
    formId?: IntWithAggregatesFilter | number
    usersId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type reviewWhereInput = {
    AND?: Enumerable<reviewWhereInput>
    OR?: Enumerable<reviewWhereInput>
    NOT?: Enumerable<reviewWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    published?: BoolFilter | boolean
    topicId?: IntFilter | number
    subjectId?: IntFilter | number
    formId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    usersId?: IntFilter | number
    form?: XOR<FormReviewRelationFilter, formReviewWhereInput>
    subject?: XOR<SubjectReviewRelationFilter, subjectReviewWhereInput>
    topic?: XOR<TopicReviewRelationFilter, topicReviewWhereInput>
    users?: XOR<UsersRelationFilter, usersWhereInput>
    question?: QuestionListRelationFilter
  }

  export type reviewOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    name?: SortOrder
    published?: SortOrder
    topicId?: SortOrder
    subjectId?: SortOrder
    formId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    usersId?: SortOrder
    form?: formReviewOrderByWithRelationAndSearchRelevanceInput
    subject?: subjectReviewOrderByWithRelationAndSearchRelevanceInput
    topic?: topicReviewOrderByWithRelationAndSearchRelevanceInput
    users?: usersOrderByWithRelationAndSearchRelevanceInput
    question?: questionOrderByRelationAggregateInput
    _relevance?: reviewOrderByRelevanceInput
  }

  export type reviewWhereUniqueInput = {
    id?: number
  }

  export type reviewOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    published?: SortOrder
    topicId?: SortOrder
    subjectId?: SortOrder
    formId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    usersId?: SortOrder
    _count?: reviewCountOrderByAggregateInput
    _avg?: reviewAvgOrderByAggregateInput
    _max?: reviewMaxOrderByAggregateInput
    _min?: reviewMinOrderByAggregateInput
    _sum?: reviewSumOrderByAggregateInput
  }

  export type reviewScalarWhereWithAggregatesInput = {
    AND?: Enumerable<reviewScalarWhereWithAggregatesInput>
    OR?: Enumerable<reviewScalarWhereWithAggregatesInput>
    NOT?: Enumerable<reviewScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    published?: BoolWithAggregatesFilter | boolean
    topicId?: IntWithAggregatesFilter | number
    subjectId?: IntWithAggregatesFilter | number
    formId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    usersId?: IntWithAggregatesFilter | number
  }

  export type questionWhereInput = {
    AND?: Enumerable<questionWhereInput>
    OR?: Enumerable<questionWhereInput>
    NOT?: Enumerable<questionWhereInput>
    id?: IntFilter | number
    question?: StringFilter | string
    published?: BoolFilter | boolean
    answerDetails?: StringFilter | string
    questionFormatId?: IntFilter | number
    reviewId?: IntFilter | number
    usersId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    questionFormat?: XOR<QuestionFormatRelationFilter, questionFormatWhereInput>
    review?: XOR<ReviewRelationFilter, reviewWhereInput>
    users?: XOR<UsersRelationFilter, usersWhereInput>
    answer?: AnswerListRelationFilter
  }

  export type questionOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    question?: SortOrder
    published?: SortOrder
    answerDetails?: SortOrder
    questionFormatId?: SortOrder
    reviewId?: SortOrder
    usersId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    questionFormat?: questionFormatOrderByWithRelationAndSearchRelevanceInput
    review?: reviewOrderByWithRelationAndSearchRelevanceInput
    users?: usersOrderByWithRelationAndSearchRelevanceInput
    answer?: answerOrderByRelationAggregateInput
    _relevance?: questionOrderByRelevanceInput
  }

  export type questionWhereUniqueInput = {
    id?: number
  }

  export type questionOrderByWithAggregationInput = {
    id?: SortOrder
    question?: SortOrder
    published?: SortOrder
    answerDetails?: SortOrder
    questionFormatId?: SortOrder
    reviewId?: SortOrder
    usersId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: questionCountOrderByAggregateInput
    _avg?: questionAvgOrderByAggregateInput
    _max?: questionMaxOrderByAggregateInput
    _min?: questionMinOrderByAggregateInput
    _sum?: questionSumOrderByAggregateInput
  }

  export type questionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<questionScalarWhereWithAggregatesInput>
    OR?: Enumerable<questionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<questionScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    question?: StringWithAggregatesFilter | string
    published?: BoolWithAggregatesFilter | boolean
    answerDetails?: StringWithAggregatesFilter | string
    questionFormatId?: IntWithAggregatesFilter | number
    reviewId?: IntWithAggregatesFilter | number
    usersId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type questionFormatWhereInput = {
    AND?: Enumerable<questionFormatWhereInput>
    OR?: Enumerable<questionFormatWhereInput>
    NOT?: Enumerable<questionFormatWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    question?: QuestionListRelationFilter
  }

  export type questionFormatOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    question?: questionOrderByRelationAggregateInput
    _relevance?: questionFormatOrderByRelevanceInput
  }

  export type questionFormatWhereUniqueInput = {
    id?: number
  }

  export type questionFormatOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: questionFormatCountOrderByAggregateInput
    _avg?: questionFormatAvgOrderByAggregateInput
    _max?: questionFormatMaxOrderByAggregateInput
    _min?: questionFormatMinOrderByAggregateInput
    _sum?: questionFormatSumOrderByAggregateInput
  }

  export type questionFormatScalarWhereWithAggregatesInput = {
    AND?: Enumerable<questionFormatScalarWhereWithAggregatesInput>
    OR?: Enumerable<questionFormatScalarWhereWithAggregatesInput>
    NOT?: Enumerable<questionFormatScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type answerWhereInput = {
    AND?: Enumerable<answerWhereInput>
    OR?: Enumerable<answerWhereInput>
    NOT?: Enumerable<answerWhereInput>
    id?: IntFilter | number
    answer?: StringFilter | string
    valid?: BoolFilter | boolean
    questionId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    question?: XOR<QuestionRelationFilter, questionWhereInput>
  }

  export type answerOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    answer?: SortOrder
    valid?: SortOrder
    questionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    question?: questionOrderByWithRelationAndSearchRelevanceInput
    _relevance?: answerOrderByRelevanceInput
  }

  export type answerWhereUniqueInput = {
    id?: number
  }

  export type answerOrderByWithAggregationInput = {
    id?: SortOrder
    answer?: SortOrder
    valid?: SortOrder
    questionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: answerCountOrderByAggregateInput
    _avg?: answerAvgOrderByAggregateInput
    _max?: answerMaxOrderByAggregateInput
    _min?: answerMinOrderByAggregateInput
    _sum?: answerSumOrderByAggregateInput
  }

  export type answerScalarWhereWithAggregatesInput = {
    AND?: Enumerable<answerScalarWhereWithAggregatesInput>
    OR?: Enumerable<answerScalarWhereWithAggregatesInput>
    NOT?: Enumerable<answerScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    answer?: StringWithAggregatesFilter | string
    valid?: BoolWithAggregatesFilter | boolean
    questionId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type subjectExamsWhereInput = {
    AND?: Enumerable<subjectExamsWhereInput>
    OR?: Enumerable<subjectExamsWhereInput>
    NOT?: Enumerable<subjectExamsWhereInput>
    id?: IntFilter | number
    subjectName?: StringFilter | string
    subjectDefinition?: StringFilter | string
    imageLocation?: StringNullableFilter | string | null
    published?: BoolFilter | boolean
    usersId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    users?: XOR<UsersRelationFilter, usersWhereInput>
    examType?: ExamTypeListRelationFilter
    forms?: FormExamsListRelationFilter
  }

  export type subjectExamsOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    subjectName?: SortOrder
    subjectDefinition?: SortOrder
    imageLocation?: SortOrder
    published?: SortOrder
    usersId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: usersOrderByWithRelationAndSearchRelevanceInput
    examType?: examTypeOrderByRelationAggregateInput
    forms?: formExamsOrderByRelationAggregateInput
    _relevance?: subjectExamsOrderByRelevanceInput
  }

  export type subjectExamsWhereUniqueInput = {
    id?: number
  }

  export type subjectExamsOrderByWithAggregationInput = {
    id?: SortOrder
    subjectName?: SortOrder
    subjectDefinition?: SortOrder
    imageLocation?: SortOrder
    published?: SortOrder
    usersId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: subjectExamsCountOrderByAggregateInput
    _avg?: subjectExamsAvgOrderByAggregateInput
    _max?: subjectExamsMaxOrderByAggregateInput
    _min?: subjectExamsMinOrderByAggregateInput
    _sum?: subjectExamsSumOrderByAggregateInput
  }

  export type subjectExamsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<subjectExamsScalarWhereWithAggregatesInput>
    OR?: Enumerable<subjectExamsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<subjectExamsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    subjectName?: StringWithAggregatesFilter | string
    subjectDefinition?: StringWithAggregatesFilter | string
    imageLocation?: StringNullableWithAggregatesFilter | string | null
    published?: BoolWithAggregatesFilter | boolean
    usersId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type formExamsWhereInput = {
    AND?: Enumerable<formExamsWhereInput>
    OR?: Enumerable<formExamsWhereInput>
    NOT?: Enumerable<formExamsWhereInput>
    id?: IntFilter | number
    formName?: StringFilter | string
    usersId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    users?: XOR<UsersRelationFilter, usersWhereInput>
    examType?: ExamTypeListRelationFilter
    subjects?: SubjectExamsListRelationFilter
  }

  export type formExamsOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    formName?: SortOrder
    usersId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: usersOrderByWithRelationAndSearchRelevanceInput
    examType?: examTypeOrderByRelationAggregateInput
    subjects?: subjectExamsOrderByRelationAggregateInput
    _relevance?: formExamsOrderByRelevanceInput
  }

  export type formExamsWhereUniqueInput = {
    id?: number
  }

  export type formExamsOrderByWithAggregationInput = {
    id?: SortOrder
    formName?: SortOrder
    usersId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: formExamsCountOrderByAggregateInput
    _avg?: formExamsAvgOrderByAggregateInput
    _max?: formExamsMaxOrderByAggregateInput
    _min?: formExamsMinOrderByAggregateInput
    _sum?: formExamsSumOrderByAggregateInput
  }

  export type formExamsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<formExamsScalarWhereWithAggregatesInput>
    OR?: Enumerable<formExamsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<formExamsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    formName?: StringWithAggregatesFilter | string
    usersId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type examTypeWhereInput = {
    AND?: Enumerable<examTypeWhereInput>
    OR?: Enumerable<examTypeWhereInput>
    NOT?: Enumerable<examTypeWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    definition?: StringFilter | string
    published?: BoolFilter | boolean
    subjectId?: IntFilter | number
    formId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    formExams?: XOR<FormExamsRelationFilter, formExamsWhereInput>
    subjectExams?: XOR<SubjectExamsRelationFilter, subjectExamsWhereInput>
    exam?: ExamListRelationFilter
  }

  export type examTypeOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    name?: SortOrder
    definition?: SortOrder
    published?: SortOrder
    subjectId?: SortOrder
    formId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    formExams?: formExamsOrderByWithRelationAndSearchRelevanceInput
    subjectExams?: subjectExamsOrderByWithRelationAndSearchRelevanceInput
    exam?: examOrderByRelationAggregateInput
    _relevance?: examTypeOrderByRelevanceInput
  }

  export type examTypeWhereUniqueInput = {
    id?: number
  }

  export type examTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    definition?: SortOrder
    published?: SortOrder
    subjectId?: SortOrder
    formId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: examTypeCountOrderByAggregateInput
    _avg?: examTypeAvgOrderByAggregateInput
    _max?: examTypeMaxOrderByAggregateInput
    _min?: examTypeMinOrderByAggregateInput
    _sum?: examTypeSumOrderByAggregateInput
  }

  export type examTypeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<examTypeScalarWhereWithAggregatesInput>
    OR?: Enumerable<examTypeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<examTypeScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    definition?: StringWithAggregatesFilter | string
    published?: BoolWithAggregatesFilter | boolean
    subjectId?: IntWithAggregatesFilter | number
    formId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type examWhereInput = {
    AND?: Enumerable<examWhereInput>
    OR?: Enumerable<examWhereInput>
    NOT?: Enumerable<examWhereInput>
    id?: IntFilter | number
    description?: StringFilter | string
    year?: IntFilter | number
    hasAnswers?: BoolFilter | boolean
    published?: BoolFilter | boolean
    examTypeId?: IntFilter | number
    exam?: StringFilter | string
    usersId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    examType?: XOR<ExamTypeRelationFilter, examTypeWhereInput>
    users?: XOR<UsersRelationFilter, usersWhereInput>
    examDownloadable?: ExamDownloadableListRelationFilter
  }

  export type examOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    description?: SortOrder
    year?: SortOrder
    hasAnswers?: SortOrder
    published?: SortOrder
    examTypeId?: SortOrder
    exam?: SortOrder
    usersId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    examType?: examTypeOrderByWithRelationAndSearchRelevanceInput
    users?: usersOrderByWithRelationAndSearchRelevanceInput
    examDownloadable?: examDownloadableOrderByRelationAggregateInput
    _relevance?: examOrderByRelevanceInput
  }

  export type examWhereUniqueInput = {
    id?: number
  }

  export type examOrderByWithAggregationInput = {
    id?: SortOrder
    description?: SortOrder
    year?: SortOrder
    hasAnswers?: SortOrder
    published?: SortOrder
    examTypeId?: SortOrder
    exam?: SortOrder
    usersId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: examCountOrderByAggregateInput
    _avg?: examAvgOrderByAggregateInput
    _max?: examMaxOrderByAggregateInput
    _min?: examMinOrderByAggregateInput
    _sum?: examSumOrderByAggregateInput
  }

  export type examScalarWhereWithAggregatesInput = {
    AND?: Enumerable<examScalarWhereWithAggregatesInput>
    OR?: Enumerable<examScalarWhereWithAggregatesInput>
    NOT?: Enumerable<examScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    description?: StringWithAggregatesFilter | string
    year?: IntWithAggregatesFilter | number
    hasAnswers?: BoolWithAggregatesFilter | boolean
    published?: BoolWithAggregatesFilter | boolean
    examTypeId?: IntWithAggregatesFilter | number
    exam?: StringWithAggregatesFilter | string
    usersId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type examDownloadableWhereInput = {
    AND?: Enumerable<examDownloadableWhereInput>
    OR?: Enumerable<examDownloadableWhereInput>
    NOT?: Enumerable<examDownloadableWhereInput>
    id?: IntFilter | number
    link?: StringFilter | string
    fileExtension?: StringFilter | string
    published?: BoolFilter | boolean
    examId?: IntFilter | number
    usersId?: IntFilter | number
    name?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    exam?: XOR<ExamRelationFilter, examWhereInput>
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type examDownloadableOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    link?: SortOrder
    fileExtension?: SortOrder
    published?: SortOrder
    examId?: SortOrder
    usersId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    exam?: examOrderByWithRelationAndSearchRelevanceInput
    users?: usersOrderByWithRelationAndSearchRelevanceInput
    _relevance?: examDownloadableOrderByRelevanceInput
  }

  export type examDownloadableWhereUniqueInput = {
    id?: number
  }

  export type examDownloadableOrderByWithAggregationInput = {
    id?: SortOrder
    link?: SortOrder
    fileExtension?: SortOrder
    published?: SortOrder
    examId?: SortOrder
    usersId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: examDownloadableCountOrderByAggregateInput
    _avg?: examDownloadableAvgOrderByAggregateInput
    _max?: examDownloadableMaxOrderByAggregateInput
    _min?: examDownloadableMinOrderByAggregateInput
    _sum?: examDownloadableSumOrderByAggregateInput
  }

  export type examDownloadableScalarWhereWithAggregatesInput = {
    AND?: Enumerable<examDownloadableScalarWhereWithAggregatesInput>
    OR?: Enumerable<examDownloadableScalarWhereWithAggregatesInput>
    NOT?: Enumerable<examDownloadableScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    link?: StringWithAggregatesFilter | string
    fileExtension?: StringWithAggregatesFilter | string
    published?: BoolWithAggregatesFilter | boolean
    examId?: IntWithAggregatesFilter | number
    usersId?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type subjectReferenceWhereInput = {
    AND?: Enumerable<subjectReferenceWhereInput>
    OR?: Enumerable<subjectReferenceWhereInput>
    NOT?: Enumerable<subjectReferenceWhereInput>
    id?: IntFilter | number
    subjectName?: StringFilter | string
    subjectDefinition?: StringFilter | string
    imageLocation?: StringNullableFilter | string | null
    published?: BoolFilter | boolean
    usersId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    users?: XOR<UsersRelationFilter, usersWhereInput>
    reference?: ReferenceListRelationFilter
    forms?: FormReferenceListRelationFilter
  }

  export type subjectReferenceOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    subjectName?: SortOrder
    subjectDefinition?: SortOrder
    imageLocation?: SortOrder
    published?: SortOrder
    usersId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: usersOrderByWithRelationAndSearchRelevanceInput
    reference?: referenceOrderByRelationAggregateInput
    forms?: formReferenceOrderByRelationAggregateInput
    _relevance?: subjectReferenceOrderByRelevanceInput
  }

  export type subjectReferenceWhereUniqueInput = {
    id?: number
  }

  export type subjectReferenceOrderByWithAggregationInput = {
    id?: SortOrder
    subjectName?: SortOrder
    subjectDefinition?: SortOrder
    imageLocation?: SortOrder
    published?: SortOrder
    usersId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: subjectReferenceCountOrderByAggregateInput
    _avg?: subjectReferenceAvgOrderByAggregateInput
    _max?: subjectReferenceMaxOrderByAggregateInput
    _min?: subjectReferenceMinOrderByAggregateInput
    _sum?: subjectReferenceSumOrderByAggregateInput
  }

  export type subjectReferenceScalarWhereWithAggregatesInput = {
    AND?: Enumerable<subjectReferenceScalarWhereWithAggregatesInput>
    OR?: Enumerable<subjectReferenceScalarWhereWithAggregatesInput>
    NOT?: Enumerable<subjectReferenceScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    subjectName?: StringWithAggregatesFilter | string
    subjectDefinition?: StringWithAggregatesFilter | string
    imageLocation?: StringNullableWithAggregatesFilter | string | null
    published?: BoolWithAggregatesFilter | boolean
    usersId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type formReferenceWhereInput = {
    AND?: Enumerable<formReferenceWhereInput>
    OR?: Enumerable<formReferenceWhereInput>
    NOT?: Enumerable<formReferenceWhereInput>
    id?: IntFilter | number
    formName?: StringFilter | string
    usersId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    users?: XOR<UsersRelationFilter, usersWhereInput>
    reference?: ReferenceListRelationFilter
    subjects?: SubjectReferenceListRelationFilter
  }

  export type formReferenceOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    formName?: SortOrder
    usersId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: usersOrderByWithRelationAndSearchRelevanceInput
    reference?: referenceOrderByRelationAggregateInput
    subjects?: subjectReferenceOrderByRelationAggregateInput
    _relevance?: formReferenceOrderByRelevanceInput
  }

  export type formReferenceWhereUniqueInput = {
    id?: number
  }

  export type formReferenceOrderByWithAggregationInput = {
    id?: SortOrder
    formName?: SortOrder
    usersId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: formReferenceCountOrderByAggregateInput
    _avg?: formReferenceAvgOrderByAggregateInput
    _max?: formReferenceMaxOrderByAggregateInput
    _min?: formReferenceMinOrderByAggregateInput
    _sum?: formReferenceSumOrderByAggregateInput
  }

  export type formReferenceScalarWhereWithAggregatesInput = {
    AND?: Enumerable<formReferenceScalarWhereWithAggregatesInput>
    OR?: Enumerable<formReferenceScalarWhereWithAggregatesInput>
    NOT?: Enumerable<formReferenceScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    formName?: StringWithAggregatesFilter | string
    usersId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type referenceWhereInput = {
    AND?: Enumerable<referenceWhereInput>
    OR?: Enumerable<referenceWhereInput>
    NOT?: Enumerable<referenceWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    description?: StringFilter | string
    data?: StringFilter | string
    isPdf?: BoolFilter | boolean
    published?: BoolFilter | boolean
    subjectId?: IntFilter | number
    usersId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    subjectReference?: XOR<SubjectReferenceRelationFilter, subjectReferenceWhereInput>
    users?: XOR<UsersRelationFilter, usersWhereInput>
    formReference?: FormReferenceListRelationFilter
  }

  export type referenceOrderByWithRelationAndSearchRelevanceInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    data?: SortOrder
    isPdf?: SortOrder
    published?: SortOrder
    subjectId?: SortOrder
    usersId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subjectReference?: subjectReferenceOrderByWithRelationAndSearchRelevanceInput
    users?: usersOrderByWithRelationAndSearchRelevanceInput
    formReference?: formReferenceOrderByRelationAggregateInput
    _relevance?: referenceOrderByRelevanceInput
  }

  export type referenceWhereUniqueInput = {
    id?: number
  }

  export type referenceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    data?: SortOrder
    isPdf?: SortOrder
    published?: SortOrder
    subjectId?: SortOrder
    usersId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: referenceCountOrderByAggregateInput
    _avg?: referenceAvgOrderByAggregateInput
    _max?: referenceMaxOrderByAggregateInput
    _min?: referenceMinOrderByAggregateInput
    _sum?: referenceSumOrderByAggregateInput
  }

  export type referenceScalarWhereWithAggregatesInput = {
    AND?: Enumerable<referenceScalarWhereWithAggregatesInput>
    OR?: Enumerable<referenceScalarWhereWithAggregatesInput>
    NOT?: Enumerable<referenceScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    data?: StringWithAggregatesFilter | string
    isPdf?: BoolWithAggregatesFilter | boolean
    published?: BoolWithAggregatesFilter | boolean
    subjectId?: IntWithAggregatesFilter | number
    usersId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type usersCreateInput = {
    image?: string | null
    username: string
    password: string
    isAdmin?: boolean
    isSuperUser?: boolean
    dateJoined?: Date | string
    name: string
    updatedAt?: Date | string
    isOnline?: boolean
    exam?: examCreateNestedManyWithoutUsersInput
    examDownloadable?: examDownloadableCreateNestedManyWithoutUsersInput
    form?: formCreateNestedManyWithoutUsersInput
    formExams?: formExamsCreateNestedManyWithoutUsersInput
    formReference?: formReferenceCreateNestedManyWithoutUsersInput
    formReview?: formReviewCreateNestedManyWithoutUsersInput
    note?: noteCreateNestedManyWithoutUsersInput
    notesDownloadable?: notesDownloadableCreateNestedManyWithoutUsersInput
    purchase?: purchaseCreateNestedManyWithoutUsersInput
    question?: questionCreateNestedManyWithoutUsersInput
    reference?: referenceCreateNestedManyWithoutUsersInput
    review?: reviewCreateNestedManyWithoutUsersInput
    subject?: subjectCreateNestedManyWithoutUsersInput
    subjectExams?: subjectExamsCreateNestedManyWithoutUsersInput
    subjectReference?: subjectReferenceCreateNestedManyWithoutUsersInput
    subjectReview?: subjectReviewCreateNestedManyWithoutUsersInput
    topic?: topicCreateNestedManyWithoutUsersInput
    topicReview?: topicReviewCreateNestedManyWithoutUsersInput
    vifurushi?: vifurushiCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateInput = {
    id?: number
    image?: string | null
    username: string
    password: string
    isAdmin?: boolean
    isSuperUser?: boolean
    dateJoined?: Date | string
    name: string
    updatedAt?: Date | string
    isOnline?: boolean
    exam?: examUncheckedCreateNestedManyWithoutUsersInput
    examDownloadable?: examDownloadableUncheckedCreateNestedManyWithoutUsersInput
    form?: formUncheckedCreateNestedManyWithoutUsersInput
    formExams?: formExamsUncheckedCreateNestedManyWithoutUsersInput
    formReference?: formReferenceUncheckedCreateNestedManyWithoutUsersInput
    formReview?: formReviewUncheckedCreateNestedManyWithoutUsersInput
    note?: noteUncheckedCreateNestedManyWithoutUsersInput
    notesDownloadable?: notesDownloadableUncheckedCreateNestedManyWithoutUsersInput
    purchase?: purchaseUncheckedCreateNestedManyWithoutUsersInput
    question?: questionUncheckedCreateNestedManyWithoutUsersInput
    reference?: referenceUncheckedCreateNestedManyWithoutUsersInput
    review?: reviewUncheckedCreateNestedManyWithoutUsersInput
    subject?: subjectUncheckedCreateNestedManyWithoutUsersInput
    subjectExams?: subjectExamsUncheckedCreateNestedManyWithoutUsersInput
    subjectReference?: subjectReferenceUncheckedCreateNestedManyWithoutUsersInput
    subjectReview?: subjectReviewUncheckedCreateNestedManyWithoutUsersInput
    topic?: topicUncheckedCreateNestedManyWithoutUsersInput
    topicReview?: topicReviewUncheckedCreateNestedManyWithoutUsersInput
    vifurushi?: vifurushiUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersUpdateInput = {
    image?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isSuperUser?: BoolFieldUpdateOperationsInput | boolean
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    exam?: examUpdateManyWithoutUsersNestedInput
    examDownloadable?: examDownloadableUpdateManyWithoutUsersNestedInput
    form?: formUpdateManyWithoutUsersNestedInput
    formExams?: formExamsUpdateManyWithoutUsersNestedInput
    formReference?: formReferenceUpdateManyWithoutUsersNestedInput
    formReview?: formReviewUpdateManyWithoutUsersNestedInput
    note?: noteUpdateManyWithoutUsersNestedInput
    notesDownloadable?: notesDownloadableUpdateManyWithoutUsersNestedInput
    purchase?: purchaseUpdateManyWithoutUsersNestedInput
    question?: questionUpdateManyWithoutUsersNestedInput
    reference?: referenceUpdateManyWithoutUsersNestedInput
    review?: reviewUpdateManyWithoutUsersNestedInput
    subject?: subjectUpdateManyWithoutUsersNestedInput
    subjectExams?: subjectExamsUpdateManyWithoutUsersNestedInput
    subjectReference?: subjectReferenceUpdateManyWithoutUsersNestedInput
    subjectReview?: subjectReviewUpdateManyWithoutUsersNestedInput
    topic?: topicUpdateManyWithoutUsersNestedInput
    topicReview?: topicReviewUpdateManyWithoutUsersNestedInput
    vifurushi?: vifurushiUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isSuperUser?: BoolFieldUpdateOperationsInput | boolean
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    exam?: examUncheckedUpdateManyWithoutUsersNestedInput
    examDownloadable?: examDownloadableUncheckedUpdateManyWithoutUsersNestedInput
    form?: formUncheckedUpdateManyWithoutUsersNestedInput
    formExams?: formExamsUncheckedUpdateManyWithoutUsersNestedInput
    formReference?: formReferenceUncheckedUpdateManyWithoutUsersNestedInput
    formReview?: formReviewUncheckedUpdateManyWithoutUsersNestedInput
    note?: noteUncheckedUpdateManyWithoutUsersNestedInput
    notesDownloadable?: notesDownloadableUncheckedUpdateManyWithoutUsersNestedInput
    purchase?: purchaseUncheckedUpdateManyWithoutUsersNestedInput
    question?: questionUncheckedUpdateManyWithoutUsersNestedInput
    reference?: referenceUncheckedUpdateManyWithoutUsersNestedInput
    review?: reviewUncheckedUpdateManyWithoutUsersNestedInput
    subject?: subjectUncheckedUpdateManyWithoutUsersNestedInput
    subjectExams?: subjectExamsUncheckedUpdateManyWithoutUsersNestedInput
    subjectReference?: subjectReferenceUncheckedUpdateManyWithoutUsersNestedInput
    subjectReview?: subjectReviewUncheckedUpdateManyWithoutUsersNestedInput
    topic?: topicUncheckedUpdateManyWithoutUsersNestedInput
    topicReview?: topicReviewUncheckedUpdateManyWithoutUsersNestedInput
    vifurushi?: vifurushiUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersCreateManyInput = {
    id?: number
    image?: string | null
    username: string
    password: string
    isAdmin?: boolean
    isSuperUser?: boolean
    dateJoined?: Date | string
    name: string
    updatedAt?: Date | string
    isOnline?: boolean
  }

  export type usersUpdateManyMutationInput = {
    image?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isSuperUser?: BoolFieldUpdateOperationsInput | boolean
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
  }

  export type usersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isSuperUser?: BoolFieldUpdateOperationsInput | boolean
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
  }

  export type vifurushiCreateInput = {
    name: string
    value: number
    users: usersCreateNestedOneWithoutVifurushiInput
  }

  export type vifurushiUncheckedCreateInput = {
    id?: number
    name: string
    value: number
    usersId: number
  }

  export type vifurushiUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    users?: usersUpdateOneRequiredWithoutVifurushiNestedInput
  }

  export type vifurushiUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    usersId?: IntFieldUpdateOperationsInput | number
  }

  export type vifurushiCreateManyInput = {
    id?: number
    name: string
    value: number
    usersId: number
  }

  export type vifurushiUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
  }

  export type vifurushiUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    usersId?: IntFieldUpdateOperationsInput | number
  }

  export type vifurushiPriceCreateInput = {
    name: string
    price: number
  }

  export type vifurushiPriceUncheckedCreateInput = {
    id?: number
    name: string
    price: number
  }

  export type vifurushiPriceUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
  }

  export type vifurushiPriceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
  }

  export type vifurushiPriceCreateManyInput = {
    id?: number
    name: string
    price: number
  }

  export type vifurushiPriceUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
  }

  export type vifurushiPriceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
  }

  export type vifurushiPackageCreateInput = {
    name: string
    value: number
    booksDownload?: booksDownloadCreateNestedOneWithoutVifurushiPackageInput
    examAccess?: examAccessCreateNestedOneWithoutVifurushiPackageInput
    examsSolvedDownload?: examsSolvedDownloadCreateNestedOneWithoutVifurushiPackageInput
    examsUnsolvedDownload?: examsUnsolvedDownloadCreateNestedOneWithoutVifurushiPackageInput
    notesDownload?: notesDownloadCreateNestedOneWithoutVifurushiPackageInput
    quizExcercises?: quizExcercisesCreateNestedOneWithoutVifurushiPackageInput
  }

  export type vifurushiPackageUncheckedCreateInput = {
    id?: number
    name: string
    value: number
    booksDownload?: booksDownloadUncheckedCreateNestedOneWithoutVifurushiPackageInput
    examAccess?: examAccessUncheckedCreateNestedOneWithoutVifurushiPackageInput
    examsSolvedDownload?: examsSolvedDownloadUncheckedCreateNestedOneWithoutVifurushiPackageInput
    examsUnsolvedDownload?: examsUnsolvedDownloadUncheckedCreateNestedOneWithoutVifurushiPackageInput
    notesDownload?: notesDownloadUncheckedCreateNestedOneWithoutVifurushiPackageInput
    quizExcercises?: quizExcercisesUncheckedCreateNestedOneWithoutVifurushiPackageInput
  }

  export type vifurushiPackageUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    booksDownload?: booksDownloadUpdateOneWithoutVifurushiPackageNestedInput
    examAccess?: examAccessUpdateOneWithoutVifurushiPackageNestedInput
    examsSolvedDownload?: examsSolvedDownloadUpdateOneWithoutVifurushiPackageNestedInput
    examsUnsolvedDownload?: examsUnsolvedDownloadUpdateOneWithoutVifurushiPackageNestedInput
    notesDownload?: notesDownloadUpdateOneWithoutVifurushiPackageNestedInput
    quizExcercises?: quizExcercisesUpdateOneWithoutVifurushiPackageNestedInput
  }

  export type vifurushiPackageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    booksDownload?: booksDownloadUncheckedUpdateOneWithoutVifurushiPackageNestedInput
    examAccess?: examAccessUncheckedUpdateOneWithoutVifurushiPackageNestedInput
    examsSolvedDownload?: examsSolvedDownloadUncheckedUpdateOneWithoutVifurushiPackageNestedInput
    examsUnsolvedDownload?: examsUnsolvedDownloadUncheckedUpdateOneWithoutVifurushiPackageNestedInput
    notesDownload?: notesDownloadUncheckedUpdateOneWithoutVifurushiPackageNestedInput
    quizExcercises?: quizExcercisesUncheckedUpdateOneWithoutVifurushiPackageNestedInput
  }

  export type vifurushiPackageCreateManyInput = {
    id?: number
    name: string
    value: number
  }

  export type vifurushiPackageUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
  }

  export type vifurushiPackageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
  }

  export type notesDownloadCreateInput = {
    name: string
    value: number
    vifurushiPackage: vifurushiPackageCreateNestedOneWithoutNotesDownloadInput
  }

  export type notesDownloadUncheckedCreateInput = {
    id?: number
    name: string
    value: number
    vifurushiPackageId: number
  }

  export type notesDownloadUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    vifurushiPackage?: vifurushiPackageUpdateOneRequiredWithoutNotesDownloadNestedInput
  }

  export type notesDownloadUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    vifurushiPackageId?: IntFieldUpdateOperationsInput | number
  }

  export type notesDownloadCreateManyInput = {
    id?: number
    name: string
    value: number
    vifurushiPackageId: number
  }

  export type notesDownloadUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
  }

  export type notesDownloadUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    vifurushiPackageId?: IntFieldUpdateOperationsInput | number
  }

  export type quizExcercisesCreateInput = {
    name: string
    value: number
    vifurushiPackage: vifurushiPackageCreateNestedOneWithoutQuizExcercisesInput
  }

  export type quizExcercisesUncheckedCreateInput = {
    id?: number
    name: string
    value: number
    vifurushiPackageId: number
  }

  export type quizExcercisesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    vifurushiPackage?: vifurushiPackageUpdateOneRequiredWithoutQuizExcercisesNestedInput
  }

  export type quizExcercisesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    vifurushiPackageId?: IntFieldUpdateOperationsInput | number
  }

  export type quizExcercisesCreateManyInput = {
    id?: number
    name: string
    value: number
    vifurushiPackageId: number
  }

  export type quizExcercisesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
  }

  export type quizExcercisesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    vifurushiPackageId?: IntFieldUpdateOperationsInput | number
  }

  export type examsUnsolvedDownloadCreateInput = {
    name: string
    value: number
    vifurushiPackage: vifurushiPackageCreateNestedOneWithoutExamsUnsolvedDownloadInput
  }

  export type examsUnsolvedDownloadUncheckedCreateInput = {
    id?: number
    name: string
    value: number
    vifurushiPackageId: number
  }

  export type examsUnsolvedDownloadUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    vifurushiPackage?: vifurushiPackageUpdateOneRequiredWithoutExamsUnsolvedDownloadNestedInput
  }

  export type examsUnsolvedDownloadUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    vifurushiPackageId?: IntFieldUpdateOperationsInput | number
  }

  export type examsUnsolvedDownloadCreateManyInput = {
    id?: number
    name: string
    value: number
    vifurushiPackageId: number
  }

  export type examsUnsolvedDownloadUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
  }

  export type examsUnsolvedDownloadUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    vifurushiPackageId?: IntFieldUpdateOperationsInput | number
  }

  export type examsSolvedDownloadCreateInput = {
    name: string
    value: number
    vifurushiPackage: vifurushiPackageCreateNestedOneWithoutExamsSolvedDownloadInput
  }

  export type examsSolvedDownloadUncheckedCreateInput = {
    id?: number
    name: string
    value: number
    vifurushiPackageId: number
  }

  export type examsSolvedDownloadUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    vifurushiPackage?: vifurushiPackageUpdateOneRequiredWithoutExamsSolvedDownloadNestedInput
  }

  export type examsSolvedDownloadUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    vifurushiPackageId?: IntFieldUpdateOperationsInput | number
  }

  export type examsSolvedDownloadCreateManyInput = {
    id?: number
    name: string
    value: number
    vifurushiPackageId: number
  }

  export type examsSolvedDownloadUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
  }

  export type examsSolvedDownloadUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    vifurushiPackageId?: IntFieldUpdateOperationsInput | number
  }

  export type examAccessCreateInput = {
    name: string
    value: number
    vifurushiPackage: vifurushiPackageCreateNestedOneWithoutExamAccessInput
  }

  export type examAccessUncheckedCreateInput = {
    id?: number
    name: string
    value: number
    vifurushiPackageId: number
  }

  export type examAccessUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    vifurushiPackage?: vifurushiPackageUpdateOneRequiredWithoutExamAccessNestedInput
  }

  export type examAccessUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    vifurushiPackageId?: IntFieldUpdateOperationsInput | number
  }

  export type examAccessCreateManyInput = {
    id?: number
    name: string
    value: number
    vifurushiPackageId: number
  }

  export type examAccessUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
  }

  export type examAccessUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    vifurushiPackageId?: IntFieldUpdateOperationsInput | number
  }

  export type booksDownloadCreateInput = {
    name: string
    value: number
    vifurushiPackage: vifurushiPackageCreateNestedOneWithoutBooksDownloadInput
  }

  export type booksDownloadUncheckedCreateInput = {
    id?: number
    name: string
    value: number
    vifurushiPackageId: number
  }

  export type booksDownloadUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    vifurushiPackage?: vifurushiPackageUpdateOneRequiredWithoutBooksDownloadNestedInput
  }

  export type booksDownloadUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    vifurushiPackageId?: IntFieldUpdateOperationsInput | number
  }

  export type booksDownloadCreateManyInput = {
    id?: number
    name: string
    value: number
    vifurushiPackageId: number
  }

  export type booksDownloadUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
  }

  export type booksDownloadUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    vifurushiPackageId?: IntFieldUpdateOperationsInput | number
  }

  export type purchaseCreateInput = {
    name: string
    value: number
    users: usersCreateNestedOneWithoutPurchaseInput
  }

  export type purchaseUncheckedCreateInput = {
    id?: number
    name: string
    value: number
    usersId: number
  }

  export type purchaseUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    users?: usersUpdateOneRequiredWithoutPurchaseNestedInput
  }

  export type purchaseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    usersId?: IntFieldUpdateOperationsInput | number
  }

  export type purchaseCreateManyInput = {
    id?: number
    name: string
    value: number
    usersId: number
  }

  export type purchaseUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
  }

  export type purchaseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    usersId?: IntFieldUpdateOperationsInput | number
  }

  export type subjectCreateInput = {
    subjectName: string
    subjectDefinition: string
    imageLocation?: string | null
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users: usersCreateNestedOneWithoutSubjectInput
    note?: noteCreateNestedManyWithoutSubjectInput
    notesDownloadable?: notesDownloadableCreateNestedManyWithoutSubjectInput
    topic?: topicCreateNestedManyWithoutSubjectInput
    forms?: formCreateNestedManyWithoutSubjectsInput
  }

  export type subjectUncheckedCreateInput = {
    id?: number
    subjectName: string
    subjectDefinition: string
    imageLocation?: string | null
    published?: boolean
    usersId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    note?: noteUncheckedCreateNestedManyWithoutSubjectInput
    notesDownloadable?: notesDownloadableUncheckedCreateNestedManyWithoutSubjectInput
    topic?: topicUncheckedCreateNestedManyWithoutSubjectInput
    forms?: formUncheckedCreateNestedManyWithoutSubjectsInput
  }

  export type subjectUpdateInput = {
    subjectName?: StringFieldUpdateOperationsInput | string
    subjectDefinition?: StringFieldUpdateOperationsInput | string
    imageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutSubjectNestedInput
    note?: noteUpdateManyWithoutSubjectNestedInput
    notesDownloadable?: notesDownloadableUpdateManyWithoutSubjectNestedInput
    topic?: topicUpdateManyWithoutSubjectNestedInput
    forms?: formUpdateManyWithoutSubjectsNestedInput
  }

  export type subjectUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    subjectName?: StringFieldUpdateOperationsInput | string
    subjectDefinition?: StringFieldUpdateOperationsInput | string
    imageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    usersId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: noteUncheckedUpdateManyWithoutSubjectNestedInput
    notesDownloadable?: notesDownloadableUncheckedUpdateManyWithoutSubjectNestedInput
    topic?: topicUncheckedUpdateManyWithoutSubjectNestedInput
    forms?: formUncheckedUpdateManyWithoutSubjectsNestedInput
  }

  export type subjectCreateManyInput = {
    id?: number
    subjectName: string
    subjectDefinition: string
    imageLocation?: string | null
    published?: boolean
    usersId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type subjectUpdateManyMutationInput = {
    subjectName?: StringFieldUpdateOperationsInput | string
    subjectDefinition?: StringFieldUpdateOperationsInput | string
    imageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type subjectUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    subjectName?: StringFieldUpdateOperationsInput | string
    subjectDefinition?: StringFieldUpdateOperationsInput | string
    imageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    usersId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type formCreateInput = {
    formName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users: usersCreateNestedOneWithoutFormInput
    note?: noteCreateNestedManyWithoutFormInput
    notesDownloadable?: notesDownloadableCreateNestedManyWithoutFormInput
    topic?: topicCreateNestedManyWithoutFormInput
    subjects?: subjectCreateNestedManyWithoutFormsInput
  }

  export type formUncheckedCreateInput = {
    id?: number
    formName: string
    usersId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    note?: noteUncheckedCreateNestedManyWithoutFormInput
    notesDownloadable?: notesDownloadableUncheckedCreateNestedManyWithoutFormInput
    topic?: topicUncheckedCreateNestedManyWithoutFormInput
    subjects?: subjectUncheckedCreateNestedManyWithoutFormsInput
  }

  export type formUpdateInput = {
    formName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutFormNestedInput
    note?: noteUpdateManyWithoutFormNestedInput
    notesDownloadable?: notesDownloadableUpdateManyWithoutFormNestedInput
    topic?: topicUpdateManyWithoutFormNestedInput
    subjects?: subjectUpdateManyWithoutFormsNestedInput
  }

  export type formUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    formName?: StringFieldUpdateOperationsInput | string
    usersId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: noteUncheckedUpdateManyWithoutFormNestedInput
    notesDownloadable?: notesDownloadableUncheckedUpdateManyWithoutFormNestedInput
    topic?: topicUncheckedUpdateManyWithoutFormNestedInput
    subjects?: subjectUncheckedUpdateManyWithoutFormsNestedInput
  }

  export type formCreateManyInput = {
    id?: number
    formName: string
    usersId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type formUpdateManyMutationInput = {
    formName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type formUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    formName?: StringFieldUpdateOperationsInput | string
    usersId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type topicCreateInput = {
    topicName: string
    topicDefinition?: string | null
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    form: formCreateNestedOneWithoutTopicInput
    subject: subjectCreateNestedOneWithoutTopicInput
    users: usersCreateNestedOneWithoutTopicInput
    note?: noteCreateNestedOneWithoutTopicInput
  }

  export type topicUncheckedCreateInput = {
    id?: number
    topicName: string
    topicDefinition?: string | null
    published?: boolean
    subjectId: number
    formId: number
    usersId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    note?: noteUncheckedCreateNestedOneWithoutTopicInput
  }

  export type topicUpdateInput = {
    topicName?: StringFieldUpdateOperationsInput | string
    topicDefinition?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    form?: formUpdateOneRequiredWithoutTopicNestedInput
    subject?: subjectUpdateOneRequiredWithoutTopicNestedInput
    users?: usersUpdateOneRequiredWithoutTopicNestedInput
    note?: noteUpdateOneWithoutTopicNestedInput
  }

  export type topicUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    topicName?: StringFieldUpdateOperationsInput | string
    topicDefinition?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    subjectId?: IntFieldUpdateOperationsInput | number
    formId?: IntFieldUpdateOperationsInput | number
    usersId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: noteUncheckedUpdateOneWithoutTopicNestedInput
  }

  export type topicCreateManyInput = {
    id?: number
    topicName: string
    topicDefinition?: string | null
    published?: boolean
    subjectId: number
    formId: number
    usersId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type topicUpdateManyMutationInput = {
    topicName?: StringFieldUpdateOperationsInput | string
    topicDefinition?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type topicUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    topicName?: StringFieldUpdateOperationsInput | string
    topicDefinition?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    subjectId?: IntFieldUpdateOperationsInput | number
    formId?: IntFieldUpdateOperationsInput | number
    usersId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type noteCreateInput = {
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    published?: boolean
    form: formCreateNestedOneWithoutNoteInput
    subject: subjectCreateNestedOneWithoutNoteInput
    topic: topicCreateNestedOneWithoutNoteInput
    users: usersCreateNestedOneWithoutNoteInput
  }

  export type noteUncheckedCreateInput = {
    id?: number
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    published?: boolean
    subjectId: number
    formId: number
    usersId: number
    topicId: number
  }

  export type noteUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    published?: BoolFieldUpdateOperationsInput | boolean
    form?: formUpdateOneRequiredWithoutNoteNestedInput
    subject?: subjectUpdateOneRequiredWithoutNoteNestedInput
    topic?: topicUpdateOneRequiredWithoutNoteNestedInput
    users?: usersUpdateOneRequiredWithoutNoteNestedInput
  }

  export type noteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    published?: BoolFieldUpdateOperationsInput | boolean
    subjectId?: IntFieldUpdateOperationsInput | number
    formId?: IntFieldUpdateOperationsInput | number
    usersId?: IntFieldUpdateOperationsInput | number
    topicId?: IntFieldUpdateOperationsInput | number
  }

  export type noteCreateManyInput = {
    id?: number
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    published?: boolean
    subjectId: number
    formId: number
    usersId: number
    topicId: number
  }

  export type noteUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    published?: BoolFieldUpdateOperationsInput | boolean
  }

  export type noteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    published?: BoolFieldUpdateOperationsInput | boolean
    subjectId?: IntFieldUpdateOperationsInput | number
    formId?: IntFieldUpdateOperationsInput | number
    usersId?: IntFieldUpdateOperationsInput | number
    topicId?: IntFieldUpdateOperationsInput | number
  }

  export type notesDownloadableCreateInput = {
    link: string
    fileExtension: string
    published?: boolean
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    form: formCreateNestedOneWithoutNotesDownloadableInput
    subject: subjectCreateNestedOneWithoutNotesDownloadableInput
    users: usersCreateNestedOneWithoutNotesDownloadableInput
  }

  export type notesDownloadableUncheckedCreateInput = {
    id?: number
    link: string
    fileExtension: string
    published?: boolean
    formId: number
    subjectId: number
    usersId: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type notesDownloadableUpdateInput = {
    link?: StringFieldUpdateOperationsInput | string
    fileExtension?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    form?: formUpdateOneRequiredWithoutNotesDownloadableNestedInput
    subject?: subjectUpdateOneRequiredWithoutNotesDownloadableNestedInput
    users?: usersUpdateOneRequiredWithoutNotesDownloadableNestedInput
  }

  export type notesDownloadableUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    link?: StringFieldUpdateOperationsInput | string
    fileExtension?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    formId?: IntFieldUpdateOperationsInput | number
    subjectId?: IntFieldUpdateOperationsInput | number
    usersId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notesDownloadableCreateManyInput = {
    id?: number
    link: string
    fileExtension: string
    published?: boolean
    formId: number
    subjectId: number
    usersId: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type notesDownloadableUpdateManyMutationInput = {
    link?: StringFieldUpdateOperationsInput | string
    fileExtension?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notesDownloadableUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    link?: StringFieldUpdateOperationsInput | string
    fileExtension?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    formId?: IntFieldUpdateOperationsInput | number
    subjectId?: IntFieldUpdateOperationsInput | number
    usersId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type subjectReviewCreateInput = {
    subjectName: string
    subjectDefinition: string
    imageLocation?: string | null
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users: usersCreateNestedOneWithoutSubjectReviewInput
    review?: reviewCreateNestedManyWithoutSubjectInput
    topic?: topicReviewCreateNestedManyWithoutSubjectInput
    forms?: formReviewCreateNestedManyWithoutSubjectsInput
  }

  export type subjectReviewUncheckedCreateInput = {
    id?: number
    subjectName: string
    subjectDefinition: string
    imageLocation?: string | null
    published?: boolean
    usersId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    review?: reviewUncheckedCreateNestedManyWithoutSubjectInput
    topic?: topicReviewUncheckedCreateNestedManyWithoutSubjectInput
    forms?: formReviewUncheckedCreateNestedManyWithoutSubjectsInput
  }

  export type subjectReviewUpdateInput = {
    subjectName?: StringFieldUpdateOperationsInput | string
    subjectDefinition?: StringFieldUpdateOperationsInput | string
    imageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutSubjectReviewNestedInput
    review?: reviewUpdateManyWithoutSubjectNestedInput
    topic?: topicReviewUpdateManyWithoutSubjectNestedInput
    forms?: formReviewUpdateManyWithoutSubjectsNestedInput
  }

  export type subjectReviewUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    subjectName?: StringFieldUpdateOperationsInput | string
    subjectDefinition?: StringFieldUpdateOperationsInput | string
    imageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    usersId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    review?: reviewUncheckedUpdateManyWithoutSubjectNestedInput
    topic?: topicReviewUncheckedUpdateManyWithoutSubjectNestedInput
    forms?: formReviewUncheckedUpdateManyWithoutSubjectsNestedInput
  }

  export type subjectReviewCreateManyInput = {
    id?: number
    subjectName: string
    subjectDefinition: string
    imageLocation?: string | null
    published?: boolean
    usersId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type subjectReviewUpdateManyMutationInput = {
    subjectName?: StringFieldUpdateOperationsInput | string
    subjectDefinition?: StringFieldUpdateOperationsInput | string
    imageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type subjectReviewUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    subjectName?: StringFieldUpdateOperationsInput | string
    subjectDefinition?: StringFieldUpdateOperationsInput | string
    imageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    usersId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type formReviewCreateInput = {
    formName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users: usersCreateNestedOneWithoutFormReviewInput
    review?: reviewCreateNestedManyWithoutFormInput
    topic?: topicReviewCreateNestedManyWithoutFormInput
    subjects?: subjectReviewCreateNestedManyWithoutFormsInput
  }

  export type formReviewUncheckedCreateInput = {
    id?: number
    formName: string
    usersId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    review?: reviewUncheckedCreateNestedManyWithoutFormInput
    topic?: topicReviewUncheckedCreateNestedManyWithoutFormInput
    subjects?: subjectReviewUncheckedCreateNestedManyWithoutFormsInput
  }

  export type formReviewUpdateInput = {
    formName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutFormReviewNestedInput
    review?: reviewUpdateManyWithoutFormNestedInput
    topic?: topicReviewUpdateManyWithoutFormNestedInput
    subjects?: subjectReviewUpdateManyWithoutFormsNestedInput
  }

  export type formReviewUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    formName?: StringFieldUpdateOperationsInput | string
    usersId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    review?: reviewUncheckedUpdateManyWithoutFormNestedInput
    topic?: topicReviewUncheckedUpdateManyWithoutFormNestedInput
    subjects?: subjectReviewUncheckedUpdateManyWithoutFormsNestedInput
  }

  export type formReviewCreateManyInput = {
    id?: number
    formName: string
    usersId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type formReviewUpdateManyMutationInput = {
    formName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type formReviewUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    formName?: StringFieldUpdateOperationsInput | string
    usersId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type topicReviewCreateInput = {
    topicName: string
    topicDefinition?: string | null
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    form: formReviewCreateNestedOneWithoutTopicInput
    subject: subjectReviewCreateNestedOneWithoutTopicInput
    users: usersCreateNestedOneWithoutTopicReviewInput
    review?: reviewCreateNestedManyWithoutTopicInput
  }

  export type topicReviewUncheckedCreateInput = {
    id?: number
    topicName: string
    topicDefinition?: string | null
    published?: boolean
    subjectId: number
    formId: number
    usersId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    review?: reviewUncheckedCreateNestedManyWithoutTopicInput
  }

  export type topicReviewUpdateInput = {
    topicName?: StringFieldUpdateOperationsInput | string
    topicDefinition?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    form?: formReviewUpdateOneRequiredWithoutTopicNestedInput
    subject?: subjectReviewUpdateOneRequiredWithoutTopicNestedInput
    users?: usersUpdateOneRequiredWithoutTopicReviewNestedInput
    review?: reviewUpdateManyWithoutTopicNestedInput
  }

  export type topicReviewUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    topicName?: StringFieldUpdateOperationsInput | string
    topicDefinition?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    subjectId?: IntFieldUpdateOperationsInput | number
    formId?: IntFieldUpdateOperationsInput | number
    usersId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    review?: reviewUncheckedUpdateManyWithoutTopicNestedInput
  }

  export type topicReviewCreateManyInput = {
    id?: number
    topicName: string
    topicDefinition?: string | null
    published?: boolean
    subjectId: number
    formId: number
    usersId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type topicReviewUpdateManyMutationInput = {
    topicName?: StringFieldUpdateOperationsInput | string
    topicDefinition?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type topicReviewUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    topicName?: StringFieldUpdateOperationsInput | string
    topicDefinition?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    subjectId?: IntFieldUpdateOperationsInput | number
    formId?: IntFieldUpdateOperationsInput | number
    usersId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type reviewCreateInput = {
    name: string
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    form: formReviewCreateNestedOneWithoutReviewInput
    subject: subjectReviewCreateNestedOneWithoutReviewInput
    topic: topicReviewCreateNestedOneWithoutReviewInput
    users: usersCreateNestedOneWithoutReviewInput
    question?: questionCreateNestedManyWithoutReviewInput
  }

  export type reviewUncheckedCreateInput = {
    id?: number
    name: string
    published?: boolean
    topicId: number
    subjectId: number
    formId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    usersId: number
    question?: questionUncheckedCreateNestedManyWithoutReviewInput
  }

  export type reviewUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    form?: formReviewUpdateOneRequiredWithoutReviewNestedInput
    subject?: subjectReviewUpdateOneRequiredWithoutReviewNestedInput
    topic?: topicReviewUpdateOneRequiredWithoutReviewNestedInput
    users?: usersUpdateOneRequiredWithoutReviewNestedInput
    question?: questionUpdateManyWithoutReviewNestedInput
  }

  export type reviewUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    topicId?: IntFieldUpdateOperationsInput | number
    subjectId?: IntFieldUpdateOperationsInput | number
    formId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usersId?: IntFieldUpdateOperationsInput | number
    question?: questionUncheckedUpdateManyWithoutReviewNestedInput
  }

  export type reviewCreateManyInput = {
    id?: number
    name: string
    published?: boolean
    topicId: number
    subjectId: number
    formId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    usersId: number
  }

  export type reviewUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type reviewUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    topicId?: IntFieldUpdateOperationsInput | number
    subjectId?: IntFieldUpdateOperationsInput | number
    formId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usersId?: IntFieldUpdateOperationsInput | number
  }

  export type questionCreateInput = {
    question: string
    published?: boolean
    answerDetails?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    questionFormat: questionFormatCreateNestedOneWithoutQuestionInput
    review: reviewCreateNestedOneWithoutQuestionInput
    users: usersCreateNestedOneWithoutQuestionInput
    answer?: answerCreateNestedManyWithoutQuestionInput
  }

  export type questionUncheckedCreateInput = {
    id?: number
    question: string
    published?: boolean
    answerDetails?: string
    questionFormatId: number
    reviewId: number
    usersId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    answer?: answerUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type questionUpdateInput = {
    question?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    answerDetails?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questionFormat?: questionFormatUpdateOneRequiredWithoutQuestionNestedInput
    review?: reviewUpdateOneRequiredWithoutQuestionNestedInput
    users?: usersUpdateOneRequiredWithoutQuestionNestedInput
    answer?: answerUpdateManyWithoutQuestionNestedInput
  }

  export type questionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    answerDetails?: StringFieldUpdateOperationsInput | string
    questionFormatId?: IntFieldUpdateOperationsInput | number
    reviewId?: IntFieldUpdateOperationsInput | number
    usersId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answer?: answerUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type questionCreateManyInput = {
    id?: number
    question: string
    published?: boolean
    answerDetails?: string
    questionFormatId: number
    reviewId: number
    usersId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type questionUpdateManyMutationInput = {
    question?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    answerDetails?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type questionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    answerDetails?: StringFieldUpdateOperationsInput | string
    questionFormatId?: IntFieldUpdateOperationsInput | number
    reviewId?: IntFieldUpdateOperationsInput | number
    usersId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type questionFormatCreateInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    question?: questionCreateNestedManyWithoutQuestionFormatInput
  }

  export type questionFormatUncheckedCreateInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    question?: questionUncheckedCreateNestedManyWithoutQuestionFormatInput
  }

  export type questionFormatUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    question?: questionUpdateManyWithoutQuestionFormatNestedInput
  }

  export type questionFormatUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    question?: questionUncheckedUpdateManyWithoutQuestionFormatNestedInput
  }

  export type questionFormatCreateManyInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type questionFormatUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type questionFormatUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type answerCreateInput = {
    answer: string
    valid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    question: questionCreateNestedOneWithoutAnswerInput
  }

  export type answerUncheckedCreateInput = {
    id?: number
    answer: string
    valid?: boolean
    questionId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type answerUpdateInput = {
    answer?: StringFieldUpdateOperationsInput | string
    valid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    question?: questionUpdateOneRequiredWithoutAnswerNestedInput
  }

  export type answerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    answer?: StringFieldUpdateOperationsInput | string
    valid?: BoolFieldUpdateOperationsInput | boolean
    questionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type answerCreateManyInput = {
    id?: number
    answer: string
    valid?: boolean
    questionId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type answerUpdateManyMutationInput = {
    answer?: StringFieldUpdateOperationsInput | string
    valid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type answerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    answer?: StringFieldUpdateOperationsInput | string
    valid?: BoolFieldUpdateOperationsInput | boolean
    questionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type subjectExamsCreateInput = {
    subjectName: string
    subjectDefinition: string
    imageLocation?: string | null
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users: usersCreateNestedOneWithoutSubjectExamsInput
    examType?: examTypeCreateNestedManyWithoutSubjectExamsInput
    forms?: formExamsCreateNestedManyWithoutSubjectsInput
  }

  export type subjectExamsUncheckedCreateInput = {
    id?: number
    subjectName: string
    subjectDefinition: string
    imageLocation?: string | null
    published?: boolean
    usersId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    examType?: examTypeUncheckedCreateNestedManyWithoutSubjectExamsInput
    forms?: formExamsUncheckedCreateNestedManyWithoutSubjectsInput
  }

  export type subjectExamsUpdateInput = {
    subjectName?: StringFieldUpdateOperationsInput | string
    subjectDefinition?: StringFieldUpdateOperationsInput | string
    imageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutSubjectExamsNestedInput
    examType?: examTypeUpdateManyWithoutSubjectExamsNestedInput
    forms?: formExamsUpdateManyWithoutSubjectsNestedInput
  }

  export type subjectExamsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    subjectName?: StringFieldUpdateOperationsInput | string
    subjectDefinition?: StringFieldUpdateOperationsInput | string
    imageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    usersId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examType?: examTypeUncheckedUpdateManyWithoutSubjectExamsNestedInput
    forms?: formExamsUncheckedUpdateManyWithoutSubjectsNestedInput
  }

  export type subjectExamsCreateManyInput = {
    id?: number
    subjectName: string
    subjectDefinition: string
    imageLocation?: string | null
    published?: boolean
    usersId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type subjectExamsUpdateManyMutationInput = {
    subjectName?: StringFieldUpdateOperationsInput | string
    subjectDefinition?: StringFieldUpdateOperationsInput | string
    imageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type subjectExamsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    subjectName?: StringFieldUpdateOperationsInput | string
    subjectDefinition?: StringFieldUpdateOperationsInput | string
    imageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    usersId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type formExamsCreateInput = {
    formName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users: usersCreateNestedOneWithoutFormExamsInput
    examType?: examTypeCreateNestedManyWithoutFormExamsInput
    subjects?: subjectExamsCreateNestedManyWithoutFormsInput
  }

  export type formExamsUncheckedCreateInput = {
    id?: number
    formName: string
    usersId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    examType?: examTypeUncheckedCreateNestedManyWithoutFormExamsInput
    subjects?: subjectExamsUncheckedCreateNestedManyWithoutFormsInput
  }

  export type formExamsUpdateInput = {
    formName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutFormExamsNestedInput
    examType?: examTypeUpdateManyWithoutFormExamsNestedInput
    subjects?: subjectExamsUpdateManyWithoutFormsNestedInput
  }

  export type formExamsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    formName?: StringFieldUpdateOperationsInput | string
    usersId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examType?: examTypeUncheckedUpdateManyWithoutFormExamsNestedInput
    subjects?: subjectExamsUncheckedUpdateManyWithoutFormsNestedInput
  }

  export type formExamsCreateManyInput = {
    id?: number
    formName: string
    usersId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type formExamsUpdateManyMutationInput = {
    formName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type formExamsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    formName?: StringFieldUpdateOperationsInput | string
    usersId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type examTypeCreateInput = {
    name: string
    definition: string
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    formExams: formExamsCreateNestedOneWithoutExamTypeInput
    subjectExams: subjectExamsCreateNestedOneWithoutExamTypeInput
    exam?: examCreateNestedManyWithoutExamTypeInput
  }

  export type examTypeUncheckedCreateInput = {
    id?: number
    name: string
    definition: string
    published?: boolean
    subjectId: number
    formId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    exam?: examUncheckedCreateNestedManyWithoutExamTypeInput
  }

  export type examTypeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    definition?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    formExams?: formExamsUpdateOneRequiredWithoutExamTypeNestedInput
    subjectExams?: subjectExamsUpdateOneRequiredWithoutExamTypeNestedInput
    exam?: examUpdateManyWithoutExamTypeNestedInput
  }

  export type examTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    definition?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    subjectId?: IntFieldUpdateOperationsInput | number
    formId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exam?: examUncheckedUpdateManyWithoutExamTypeNestedInput
  }

  export type examTypeCreateManyInput = {
    id?: number
    name: string
    definition: string
    published?: boolean
    subjectId: number
    formId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type examTypeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    definition?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type examTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    definition?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    subjectId?: IntFieldUpdateOperationsInput | number
    formId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type examCreateInput = {
    description: string
    year: number
    hasAnswers?: boolean
    published?: boolean
    exam: string
    createdAt?: Date | string
    updatedAt?: Date | string
    examType: examTypeCreateNestedOneWithoutExamInput
    users: usersCreateNestedOneWithoutExamInput
    examDownloadable?: examDownloadableCreateNestedManyWithoutExamInput
  }

  export type examUncheckedCreateInput = {
    id?: number
    description: string
    year: number
    hasAnswers?: boolean
    published?: boolean
    examTypeId: number
    exam: string
    usersId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    examDownloadable?: examDownloadableUncheckedCreateNestedManyWithoutExamInput
  }

  export type examUpdateInput = {
    description?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    hasAnswers?: BoolFieldUpdateOperationsInput | boolean
    published?: BoolFieldUpdateOperationsInput | boolean
    exam?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examType?: examTypeUpdateOneRequiredWithoutExamNestedInput
    users?: usersUpdateOneRequiredWithoutExamNestedInput
    examDownloadable?: examDownloadableUpdateManyWithoutExamNestedInput
  }

  export type examUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    hasAnswers?: BoolFieldUpdateOperationsInput | boolean
    published?: BoolFieldUpdateOperationsInput | boolean
    examTypeId?: IntFieldUpdateOperationsInput | number
    exam?: StringFieldUpdateOperationsInput | string
    usersId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examDownloadable?: examDownloadableUncheckedUpdateManyWithoutExamNestedInput
  }

  export type examCreateManyInput = {
    id?: number
    description: string
    year: number
    hasAnswers?: boolean
    published?: boolean
    examTypeId: number
    exam: string
    usersId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type examUpdateManyMutationInput = {
    description?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    hasAnswers?: BoolFieldUpdateOperationsInput | boolean
    published?: BoolFieldUpdateOperationsInput | boolean
    exam?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type examUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    hasAnswers?: BoolFieldUpdateOperationsInput | boolean
    published?: BoolFieldUpdateOperationsInput | boolean
    examTypeId?: IntFieldUpdateOperationsInput | number
    exam?: StringFieldUpdateOperationsInput | string
    usersId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type examDownloadableCreateInput = {
    link: string
    fileExtension: string
    published?: boolean
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    exam: examCreateNestedOneWithoutExamDownloadableInput
    users: usersCreateNestedOneWithoutExamDownloadableInput
  }

  export type examDownloadableUncheckedCreateInput = {
    id?: number
    link: string
    fileExtension: string
    published?: boolean
    examId: number
    usersId: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type examDownloadableUpdateInput = {
    link?: StringFieldUpdateOperationsInput | string
    fileExtension?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exam?: examUpdateOneRequiredWithoutExamDownloadableNestedInput
    users?: usersUpdateOneRequiredWithoutExamDownloadableNestedInput
  }

  export type examDownloadableUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    link?: StringFieldUpdateOperationsInput | string
    fileExtension?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    examId?: IntFieldUpdateOperationsInput | number
    usersId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type examDownloadableCreateManyInput = {
    id?: number
    link: string
    fileExtension: string
    published?: boolean
    examId: number
    usersId: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type examDownloadableUpdateManyMutationInput = {
    link?: StringFieldUpdateOperationsInput | string
    fileExtension?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type examDownloadableUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    link?: StringFieldUpdateOperationsInput | string
    fileExtension?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    examId?: IntFieldUpdateOperationsInput | number
    usersId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type subjectReferenceCreateInput = {
    subjectName: string
    subjectDefinition: string
    imageLocation?: string | null
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users: usersCreateNestedOneWithoutSubjectReferenceInput
    reference?: referenceCreateNestedManyWithoutSubjectReferenceInput
    forms?: formReferenceCreateNestedManyWithoutSubjectsInput
  }

  export type subjectReferenceUncheckedCreateInput = {
    id?: number
    subjectName: string
    subjectDefinition: string
    imageLocation?: string | null
    published?: boolean
    usersId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    reference?: referenceUncheckedCreateNestedManyWithoutSubjectReferenceInput
    forms?: formReferenceUncheckedCreateNestedManyWithoutSubjectsInput
  }

  export type subjectReferenceUpdateInput = {
    subjectName?: StringFieldUpdateOperationsInput | string
    subjectDefinition?: StringFieldUpdateOperationsInput | string
    imageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutSubjectReferenceNestedInput
    reference?: referenceUpdateManyWithoutSubjectReferenceNestedInput
    forms?: formReferenceUpdateManyWithoutSubjectsNestedInput
  }

  export type subjectReferenceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    subjectName?: StringFieldUpdateOperationsInput | string
    subjectDefinition?: StringFieldUpdateOperationsInput | string
    imageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    usersId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: referenceUncheckedUpdateManyWithoutSubjectReferenceNestedInput
    forms?: formReferenceUncheckedUpdateManyWithoutSubjectsNestedInput
  }

  export type subjectReferenceCreateManyInput = {
    id?: number
    subjectName: string
    subjectDefinition: string
    imageLocation?: string | null
    published?: boolean
    usersId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type subjectReferenceUpdateManyMutationInput = {
    subjectName?: StringFieldUpdateOperationsInput | string
    subjectDefinition?: StringFieldUpdateOperationsInput | string
    imageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type subjectReferenceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    subjectName?: StringFieldUpdateOperationsInput | string
    subjectDefinition?: StringFieldUpdateOperationsInput | string
    imageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    usersId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type formReferenceCreateInput = {
    formName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users: usersCreateNestedOneWithoutFormReferenceInput
    reference?: referenceCreateNestedManyWithoutFormReferenceInput
    subjects?: subjectReferenceCreateNestedManyWithoutFormsInput
  }

  export type formReferenceUncheckedCreateInput = {
    id?: number
    formName: string
    usersId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    reference?: referenceUncheckedCreateNestedManyWithoutFormReferenceInput
    subjects?: subjectReferenceUncheckedCreateNestedManyWithoutFormsInput
  }

  export type formReferenceUpdateInput = {
    formName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutFormReferenceNestedInput
    reference?: referenceUpdateManyWithoutFormReferenceNestedInput
    subjects?: subjectReferenceUpdateManyWithoutFormsNestedInput
  }

  export type formReferenceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    formName?: StringFieldUpdateOperationsInput | string
    usersId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: referenceUncheckedUpdateManyWithoutFormReferenceNestedInput
    subjects?: subjectReferenceUncheckedUpdateManyWithoutFormsNestedInput
  }

  export type formReferenceCreateManyInput = {
    id?: number
    formName: string
    usersId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type formReferenceUpdateManyMutationInput = {
    formName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type formReferenceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    formName?: StringFieldUpdateOperationsInput | string
    usersId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type referenceCreateInput = {
    name: string
    description: string
    data: string
    isPdf: boolean
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    subjectReference: subjectReferenceCreateNestedOneWithoutReferenceInput
    users: usersCreateNestedOneWithoutReferenceInput
    formReference?: formReferenceCreateNestedManyWithoutReferenceInput
  }

  export type referenceUncheckedCreateInput = {
    id?: number
    name: string
    description: string
    data: string
    isPdf: boolean
    published?: boolean
    subjectId: number
    usersId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    formReference?: formReferenceUncheckedCreateNestedManyWithoutReferenceInput
  }

  export type referenceUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    isPdf?: BoolFieldUpdateOperationsInput | boolean
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subjectReference?: subjectReferenceUpdateOneRequiredWithoutReferenceNestedInput
    users?: usersUpdateOneRequiredWithoutReferenceNestedInput
    formReference?: formReferenceUpdateManyWithoutReferenceNestedInput
  }

  export type referenceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    isPdf?: BoolFieldUpdateOperationsInput | boolean
    published?: BoolFieldUpdateOperationsInput | boolean
    subjectId?: IntFieldUpdateOperationsInput | number
    usersId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    formReference?: formReferenceUncheckedUpdateManyWithoutReferenceNestedInput
  }

  export type referenceCreateManyInput = {
    id?: number
    name: string
    description: string
    data: string
    isPdf: boolean
    published?: boolean
    subjectId: number
    usersId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type referenceUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    isPdf?: BoolFieldUpdateOperationsInput | boolean
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type referenceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    isPdf?: BoolFieldUpdateOperationsInput | boolean
    published?: BoolFieldUpdateOperationsInput | boolean
    subjectId?: IntFieldUpdateOperationsInput | number
    usersId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    search?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    search?: string
    not?: NestedStringFilter | string
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type ExamListRelationFilter = {
    every?: examWhereInput
    some?: examWhereInput
    none?: examWhereInput
  }

  export type ExamDownloadableListRelationFilter = {
    every?: examDownloadableWhereInput
    some?: examDownloadableWhereInput
    none?: examDownloadableWhereInput
  }

  export type FormListRelationFilter = {
    every?: formWhereInput
    some?: formWhereInput
    none?: formWhereInput
  }

  export type FormExamsListRelationFilter = {
    every?: formExamsWhereInput
    some?: formExamsWhereInput
    none?: formExamsWhereInput
  }

  export type FormReferenceListRelationFilter = {
    every?: formReferenceWhereInput
    some?: formReferenceWhereInput
    none?: formReferenceWhereInput
  }

  export type FormReviewListRelationFilter = {
    every?: formReviewWhereInput
    some?: formReviewWhereInput
    none?: formReviewWhereInput
  }

  export type NoteListRelationFilter = {
    every?: noteWhereInput
    some?: noteWhereInput
    none?: noteWhereInput
  }

  export type NotesDownloadableListRelationFilter = {
    every?: notesDownloadableWhereInput
    some?: notesDownloadableWhereInput
    none?: notesDownloadableWhereInput
  }

  export type PurchaseListRelationFilter = {
    every?: purchaseWhereInput
    some?: purchaseWhereInput
    none?: purchaseWhereInput
  }

  export type QuestionListRelationFilter = {
    every?: questionWhereInput
    some?: questionWhereInput
    none?: questionWhereInput
  }

  export type ReferenceListRelationFilter = {
    every?: referenceWhereInput
    some?: referenceWhereInput
    none?: referenceWhereInput
  }

  export type ReviewListRelationFilter = {
    every?: reviewWhereInput
    some?: reviewWhereInput
    none?: reviewWhereInput
  }

  export type SubjectListRelationFilter = {
    every?: subjectWhereInput
    some?: subjectWhereInput
    none?: subjectWhereInput
  }

  export type SubjectExamsListRelationFilter = {
    every?: subjectExamsWhereInput
    some?: subjectExamsWhereInput
    none?: subjectExamsWhereInput
  }

  export type SubjectReferenceListRelationFilter = {
    every?: subjectReferenceWhereInput
    some?: subjectReferenceWhereInput
    none?: subjectReferenceWhereInput
  }

  export type SubjectReviewListRelationFilter = {
    every?: subjectReviewWhereInput
    some?: subjectReviewWhereInput
    none?: subjectReviewWhereInput
  }

  export type TopicListRelationFilter = {
    every?: topicWhereInput
    some?: topicWhereInput
    none?: topicWhereInput
  }

  export type TopicReviewListRelationFilter = {
    every?: topicReviewWhereInput
    some?: topicReviewWhereInput
    none?: topicReviewWhereInput
  }

  export type VifurushiListRelationFilter = {
    every?: vifurushiWhereInput
    some?: vifurushiWhereInput
    none?: vifurushiWhereInput
  }

  export type examOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type examDownloadableOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type formOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type formExamsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type formReferenceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type formReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type noteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type notesDownloadableOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type purchaseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type questionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type referenceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type reviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type subjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type subjectExamsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type subjectReferenceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type subjectReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type topicOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type topicReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type vifurushiOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usersOrderByRelevanceInput = {
    fields: Enumerable<usersOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type usersCountOrderByAggregateInput = {
    id?: SortOrder
    image?: SortOrder
    username?: SortOrder
    password?: SortOrder
    isAdmin?: SortOrder
    isSuperUser?: SortOrder
    dateJoined?: SortOrder
    name?: SortOrder
    updatedAt?: SortOrder
    isOnline?: SortOrder
  }

  export type usersAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    id?: SortOrder
    image?: SortOrder
    username?: SortOrder
    password?: SortOrder
    isAdmin?: SortOrder
    isSuperUser?: SortOrder
    dateJoined?: SortOrder
    name?: SortOrder
    updatedAt?: SortOrder
    isOnline?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    id?: SortOrder
    image?: SortOrder
    username?: SortOrder
    password?: SortOrder
    isAdmin?: SortOrder
    isSuperUser?: SortOrder
    dateJoined?: SortOrder
    name?: SortOrder
    updatedAt?: SortOrder
    isOnline?: SortOrder
  }

  export type usersSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    search?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    search?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type UsersRelationFilter = {
    is?: usersWhereInput
    isNot?: usersWhereInput
  }

  export type vifurushiOrderByRelevanceInput = {
    fields: Enumerable<vifurushiOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type vifurushiCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    usersId?: SortOrder
  }

  export type vifurushiAvgOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    usersId?: SortOrder
  }

  export type vifurushiMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    usersId?: SortOrder
  }

  export type vifurushiMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    usersId?: SortOrder
  }

  export type vifurushiSumOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    usersId?: SortOrder
  }

  export type vifurushiPriceOrderByRelevanceInput = {
    fields: Enumerable<vifurushiPriceOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type vifurushiPriceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
  }

  export type vifurushiPriceAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
  }

  export type vifurushiPriceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
  }

  export type vifurushiPriceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
  }

  export type vifurushiPriceSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
  }

  export type BooksDownloadRelationFilter = {
    is?: booksDownloadWhereInput | null
    isNot?: booksDownloadWhereInput | null
  }

  export type ExamAccessRelationFilter = {
    is?: examAccessWhereInput | null
    isNot?: examAccessWhereInput | null
  }

  export type ExamsSolvedDownloadRelationFilter = {
    is?: examsSolvedDownloadWhereInput | null
    isNot?: examsSolvedDownloadWhereInput | null
  }

  export type ExamsUnsolvedDownloadRelationFilter = {
    is?: examsUnsolvedDownloadWhereInput | null
    isNot?: examsUnsolvedDownloadWhereInput | null
  }

  export type NotesDownloadRelationFilter = {
    is?: notesDownloadWhereInput | null
    isNot?: notesDownloadWhereInput | null
  }

  export type QuizExcercisesRelationFilter = {
    is?: quizExcercisesWhereInput | null
    isNot?: quizExcercisesWhereInput | null
  }

  export type vifurushiPackageOrderByRelevanceInput = {
    fields: Enumerable<vifurushiPackageOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type vifurushiPackageCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
  }

  export type vifurushiPackageAvgOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
  }

  export type vifurushiPackageMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
  }

  export type vifurushiPackageMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
  }

  export type vifurushiPackageSumOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
  }

  export type VifurushiPackageRelationFilter = {
    is?: vifurushiPackageWhereInput
    isNot?: vifurushiPackageWhereInput
  }

  export type notesDownloadOrderByRelevanceInput = {
    fields: Enumerable<notesDownloadOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type notesDownloadCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    vifurushiPackageId?: SortOrder
  }

  export type notesDownloadAvgOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    vifurushiPackageId?: SortOrder
  }

  export type notesDownloadMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    vifurushiPackageId?: SortOrder
  }

  export type notesDownloadMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    vifurushiPackageId?: SortOrder
  }

  export type notesDownloadSumOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    vifurushiPackageId?: SortOrder
  }

  export type quizExcercisesOrderByRelevanceInput = {
    fields: Enumerable<quizExcercisesOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type quizExcercisesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    vifurushiPackageId?: SortOrder
  }

  export type quizExcercisesAvgOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    vifurushiPackageId?: SortOrder
  }

  export type quizExcercisesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    vifurushiPackageId?: SortOrder
  }

  export type quizExcercisesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    vifurushiPackageId?: SortOrder
  }

  export type quizExcercisesSumOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    vifurushiPackageId?: SortOrder
  }

  export type examsUnsolvedDownloadOrderByRelevanceInput = {
    fields: Enumerable<examsUnsolvedDownloadOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type examsUnsolvedDownloadCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    vifurushiPackageId?: SortOrder
  }

  export type examsUnsolvedDownloadAvgOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    vifurushiPackageId?: SortOrder
  }

  export type examsUnsolvedDownloadMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    vifurushiPackageId?: SortOrder
  }

  export type examsUnsolvedDownloadMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    vifurushiPackageId?: SortOrder
  }

  export type examsUnsolvedDownloadSumOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    vifurushiPackageId?: SortOrder
  }

  export type examsSolvedDownloadOrderByRelevanceInput = {
    fields: Enumerable<examsSolvedDownloadOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type examsSolvedDownloadCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    vifurushiPackageId?: SortOrder
  }

  export type examsSolvedDownloadAvgOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    vifurushiPackageId?: SortOrder
  }

  export type examsSolvedDownloadMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    vifurushiPackageId?: SortOrder
  }

  export type examsSolvedDownloadMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    vifurushiPackageId?: SortOrder
  }

  export type examsSolvedDownloadSumOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    vifurushiPackageId?: SortOrder
  }

  export type examAccessOrderByRelevanceInput = {
    fields: Enumerable<examAccessOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type examAccessCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    vifurushiPackageId?: SortOrder
  }

  export type examAccessAvgOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    vifurushiPackageId?: SortOrder
  }

  export type examAccessMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    vifurushiPackageId?: SortOrder
  }

  export type examAccessMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    vifurushiPackageId?: SortOrder
  }

  export type examAccessSumOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    vifurushiPackageId?: SortOrder
  }

  export type booksDownloadOrderByRelevanceInput = {
    fields: Enumerable<booksDownloadOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type booksDownloadCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    vifurushiPackageId?: SortOrder
  }

  export type booksDownloadAvgOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    vifurushiPackageId?: SortOrder
  }

  export type booksDownloadMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    vifurushiPackageId?: SortOrder
  }

  export type booksDownloadMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    vifurushiPackageId?: SortOrder
  }

  export type booksDownloadSumOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    vifurushiPackageId?: SortOrder
  }

  export type purchaseOrderByRelevanceInput = {
    fields: Enumerable<purchaseOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type purchaseCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    usersId?: SortOrder
  }

  export type purchaseAvgOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    usersId?: SortOrder
  }

  export type purchaseMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    usersId?: SortOrder
  }

  export type purchaseMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    usersId?: SortOrder
  }

  export type purchaseSumOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    usersId?: SortOrder
  }

  export type subjectOrderByRelevanceInput = {
    fields: Enumerable<subjectOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type subjectCountOrderByAggregateInput = {
    id?: SortOrder
    subjectName?: SortOrder
    subjectDefinition?: SortOrder
    imageLocation?: SortOrder
    published?: SortOrder
    usersId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type subjectAvgOrderByAggregateInput = {
    id?: SortOrder
    usersId?: SortOrder
  }

  export type subjectMaxOrderByAggregateInput = {
    id?: SortOrder
    subjectName?: SortOrder
    subjectDefinition?: SortOrder
    imageLocation?: SortOrder
    published?: SortOrder
    usersId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type subjectMinOrderByAggregateInput = {
    id?: SortOrder
    subjectName?: SortOrder
    subjectDefinition?: SortOrder
    imageLocation?: SortOrder
    published?: SortOrder
    usersId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type subjectSumOrderByAggregateInput = {
    id?: SortOrder
    usersId?: SortOrder
  }

  export type formOrderByRelevanceInput = {
    fields: Enumerable<formOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type formCountOrderByAggregateInput = {
    id?: SortOrder
    formName?: SortOrder
    usersId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type formAvgOrderByAggregateInput = {
    id?: SortOrder
    usersId?: SortOrder
  }

  export type formMaxOrderByAggregateInput = {
    id?: SortOrder
    formName?: SortOrder
    usersId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type formMinOrderByAggregateInput = {
    id?: SortOrder
    formName?: SortOrder
    usersId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type formSumOrderByAggregateInput = {
    id?: SortOrder
    usersId?: SortOrder
  }

  export type FormRelationFilter = {
    is?: formWhereInput
    isNot?: formWhereInput
  }

  export type SubjectRelationFilter = {
    is?: subjectWhereInput
    isNot?: subjectWhereInput
  }

  export type NoteRelationFilter = {
    is?: noteWhereInput | null
    isNot?: noteWhereInput | null
  }

  export type topicOrderByRelevanceInput = {
    fields: Enumerable<topicOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type topicCountOrderByAggregateInput = {
    id?: SortOrder
    topicName?: SortOrder
    topicDefinition?: SortOrder
    published?: SortOrder
    subjectId?: SortOrder
    formId?: SortOrder
    usersId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type topicAvgOrderByAggregateInput = {
    id?: SortOrder
    subjectId?: SortOrder
    formId?: SortOrder
    usersId?: SortOrder
  }

  export type topicMaxOrderByAggregateInput = {
    id?: SortOrder
    topicName?: SortOrder
    topicDefinition?: SortOrder
    published?: SortOrder
    subjectId?: SortOrder
    formId?: SortOrder
    usersId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type topicMinOrderByAggregateInput = {
    id?: SortOrder
    topicName?: SortOrder
    topicDefinition?: SortOrder
    published?: SortOrder
    subjectId?: SortOrder
    formId?: SortOrder
    usersId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type topicSumOrderByAggregateInput = {
    id?: SortOrder
    subjectId?: SortOrder
    formId?: SortOrder
    usersId?: SortOrder
  }

  export type TopicRelationFilter = {
    is?: topicWhereInput
    isNot?: topicWhereInput
  }

  export type noteOrderByRelevanceInput = {
    fields: Enumerable<noteOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type noteCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    published?: SortOrder
    subjectId?: SortOrder
    formId?: SortOrder
    usersId?: SortOrder
    topicId?: SortOrder
  }

  export type noteAvgOrderByAggregateInput = {
    id?: SortOrder
    subjectId?: SortOrder
    formId?: SortOrder
    usersId?: SortOrder
    topicId?: SortOrder
  }

  export type noteMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    published?: SortOrder
    subjectId?: SortOrder
    formId?: SortOrder
    usersId?: SortOrder
    topicId?: SortOrder
  }

  export type noteMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    published?: SortOrder
    subjectId?: SortOrder
    formId?: SortOrder
    usersId?: SortOrder
    topicId?: SortOrder
  }

  export type noteSumOrderByAggregateInput = {
    id?: SortOrder
    subjectId?: SortOrder
    formId?: SortOrder
    usersId?: SortOrder
    topicId?: SortOrder
  }

  export type notesDownloadableOrderByRelevanceInput = {
    fields: Enumerable<notesDownloadableOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type notesDownloadableCountOrderByAggregateInput = {
    id?: SortOrder
    link?: SortOrder
    fileExtension?: SortOrder
    published?: SortOrder
    formId?: SortOrder
    subjectId?: SortOrder
    usersId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type notesDownloadableAvgOrderByAggregateInput = {
    id?: SortOrder
    formId?: SortOrder
    subjectId?: SortOrder
    usersId?: SortOrder
  }

  export type notesDownloadableMaxOrderByAggregateInput = {
    id?: SortOrder
    link?: SortOrder
    fileExtension?: SortOrder
    published?: SortOrder
    formId?: SortOrder
    subjectId?: SortOrder
    usersId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type notesDownloadableMinOrderByAggregateInput = {
    id?: SortOrder
    link?: SortOrder
    fileExtension?: SortOrder
    published?: SortOrder
    formId?: SortOrder
    subjectId?: SortOrder
    usersId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type notesDownloadableSumOrderByAggregateInput = {
    id?: SortOrder
    formId?: SortOrder
    subjectId?: SortOrder
    usersId?: SortOrder
  }

  export type subjectReviewOrderByRelevanceInput = {
    fields: Enumerable<subjectReviewOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type subjectReviewCountOrderByAggregateInput = {
    id?: SortOrder
    subjectName?: SortOrder
    subjectDefinition?: SortOrder
    imageLocation?: SortOrder
    published?: SortOrder
    usersId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type subjectReviewAvgOrderByAggregateInput = {
    id?: SortOrder
    usersId?: SortOrder
  }

  export type subjectReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    subjectName?: SortOrder
    subjectDefinition?: SortOrder
    imageLocation?: SortOrder
    published?: SortOrder
    usersId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type subjectReviewMinOrderByAggregateInput = {
    id?: SortOrder
    subjectName?: SortOrder
    subjectDefinition?: SortOrder
    imageLocation?: SortOrder
    published?: SortOrder
    usersId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type subjectReviewSumOrderByAggregateInput = {
    id?: SortOrder
    usersId?: SortOrder
  }

  export type formReviewOrderByRelevanceInput = {
    fields: Enumerable<formReviewOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type formReviewCountOrderByAggregateInput = {
    id?: SortOrder
    formName?: SortOrder
    usersId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type formReviewAvgOrderByAggregateInput = {
    id?: SortOrder
    usersId?: SortOrder
  }

  export type formReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    formName?: SortOrder
    usersId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type formReviewMinOrderByAggregateInput = {
    id?: SortOrder
    formName?: SortOrder
    usersId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type formReviewSumOrderByAggregateInput = {
    id?: SortOrder
    usersId?: SortOrder
  }

  export type FormReviewRelationFilter = {
    is?: formReviewWhereInput
    isNot?: formReviewWhereInput
  }

  export type SubjectReviewRelationFilter = {
    is?: subjectReviewWhereInput
    isNot?: subjectReviewWhereInput
  }

  export type topicReviewOrderByRelevanceInput = {
    fields: Enumerable<topicReviewOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type topicReviewCountOrderByAggregateInput = {
    id?: SortOrder
    topicName?: SortOrder
    topicDefinition?: SortOrder
    published?: SortOrder
    subjectId?: SortOrder
    formId?: SortOrder
    usersId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type topicReviewAvgOrderByAggregateInput = {
    id?: SortOrder
    subjectId?: SortOrder
    formId?: SortOrder
    usersId?: SortOrder
  }

  export type topicReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    topicName?: SortOrder
    topicDefinition?: SortOrder
    published?: SortOrder
    subjectId?: SortOrder
    formId?: SortOrder
    usersId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type topicReviewMinOrderByAggregateInput = {
    id?: SortOrder
    topicName?: SortOrder
    topicDefinition?: SortOrder
    published?: SortOrder
    subjectId?: SortOrder
    formId?: SortOrder
    usersId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type topicReviewSumOrderByAggregateInput = {
    id?: SortOrder
    subjectId?: SortOrder
    formId?: SortOrder
    usersId?: SortOrder
  }

  export type TopicReviewRelationFilter = {
    is?: topicReviewWhereInput
    isNot?: topicReviewWhereInput
  }

  export type reviewOrderByRelevanceInput = {
    fields: Enumerable<reviewOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type reviewCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    published?: SortOrder
    topicId?: SortOrder
    subjectId?: SortOrder
    formId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    usersId?: SortOrder
  }

  export type reviewAvgOrderByAggregateInput = {
    id?: SortOrder
    topicId?: SortOrder
    subjectId?: SortOrder
    formId?: SortOrder
    usersId?: SortOrder
  }

  export type reviewMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    published?: SortOrder
    topicId?: SortOrder
    subjectId?: SortOrder
    formId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    usersId?: SortOrder
  }

  export type reviewMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    published?: SortOrder
    topicId?: SortOrder
    subjectId?: SortOrder
    formId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    usersId?: SortOrder
  }

  export type reviewSumOrderByAggregateInput = {
    id?: SortOrder
    topicId?: SortOrder
    subjectId?: SortOrder
    formId?: SortOrder
    usersId?: SortOrder
  }

  export type QuestionFormatRelationFilter = {
    is?: questionFormatWhereInput
    isNot?: questionFormatWhereInput
  }

  export type ReviewRelationFilter = {
    is?: reviewWhereInput
    isNot?: reviewWhereInput
  }

  export type AnswerListRelationFilter = {
    every?: answerWhereInput
    some?: answerWhereInput
    none?: answerWhereInput
  }

  export type answerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type questionOrderByRelevanceInput = {
    fields: Enumerable<questionOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type questionCountOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    published?: SortOrder
    answerDetails?: SortOrder
    questionFormatId?: SortOrder
    reviewId?: SortOrder
    usersId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type questionAvgOrderByAggregateInput = {
    id?: SortOrder
    questionFormatId?: SortOrder
    reviewId?: SortOrder
    usersId?: SortOrder
  }

  export type questionMaxOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    published?: SortOrder
    answerDetails?: SortOrder
    questionFormatId?: SortOrder
    reviewId?: SortOrder
    usersId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type questionMinOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    published?: SortOrder
    answerDetails?: SortOrder
    questionFormatId?: SortOrder
    reviewId?: SortOrder
    usersId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type questionSumOrderByAggregateInput = {
    id?: SortOrder
    questionFormatId?: SortOrder
    reviewId?: SortOrder
    usersId?: SortOrder
  }

  export type questionFormatOrderByRelevanceInput = {
    fields: Enumerable<questionFormatOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type questionFormatCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type questionFormatAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type questionFormatMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type questionFormatMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type questionFormatSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type QuestionRelationFilter = {
    is?: questionWhereInput
    isNot?: questionWhereInput
  }

  export type answerOrderByRelevanceInput = {
    fields: Enumerable<answerOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type answerCountOrderByAggregateInput = {
    id?: SortOrder
    answer?: SortOrder
    valid?: SortOrder
    questionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type answerAvgOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
  }

  export type answerMaxOrderByAggregateInput = {
    id?: SortOrder
    answer?: SortOrder
    valid?: SortOrder
    questionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type answerMinOrderByAggregateInput = {
    id?: SortOrder
    answer?: SortOrder
    valid?: SortOrder
    questionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type answerSumOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
  }

  export type ExamTypeListRelationFilter = {
    every?: examTypeWhereInput
    some?: examTypeWhereInput
    none?: examTypeWhereInput
  }

  export type examTypeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type subjectExamsOrderByRelevanceInput = {
    fields: Enumerable<subjectExamsOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type subjectExamsCountOrderByAggregateInput = {
    id?: SortOrder
    subjectName?: SortOrder
    subjectDefinition?: SortOrder
    imageLocation?: SortOrder
    published?: SortOrder
    usersId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type subjectExamsAvgOrderByAggregateInput = {
    id?: SortOrder
    usersId?: SortOrder
  }

  export type subjectExamsMaxOrderByAggregateInput = {
    id?: SortOrder
    subjectName?: SortOrder
    subjectDefinition?: SortOrder
    imageLocation?: SortOrder
    published?: SortOrder
    usersId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type subjectExamsMinOrderByAggregateInput = {
    id?: SortOrder
    subjectName?: SortOrder
    subjectDefinition?: SortOrder
    imageLocation?: SortOrder
    published?: SortOrder
    usersId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type subjectExamsSumOrderByAggregateInput = {
    id?: SortOrder
    usersId?: SortOrder
  }

  export type formExamsOrderByRelevanceInput = {
    fields: Enumerable<formExamsOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type formExamsCountOrderByAggregateInput = {
    id?: SortOrder
    formName?: SortOrder
    usersId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type formExamsAvgOrderByAggregateInput = {
    id?: SortOrder
    usersId?: SortOrder
  }

  export type formExamsMaxOrderByAggregateInput = {
    id?: SortOrder
    formName?: SortOrder
    usersId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type formExamsMinOrderByAggregateInput = {
    id?: SortOrder
    formName?: SortOrder
    usersId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type formExamsSumOrderByAggregateInput = {
    id?: SortOrder
    usersId?: SortOrder
  }

  export type FormExamsRelationFilter = {
    is?: formExamsWhereInput
    isNot?: formExamsWhereInput
  }

  export type SubjectExamsRelationFilter = {
    is?: subjectExamsWhereInput
    isNot?: subjectExamsWhereInput
  }

  export type examTypeOrderByRelevanceInput = {
    fields: Enumerable<examTypeOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type examTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    definition?: SortOrder
    published?: SortOrder
    subjectId?: SortOrder
    formId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type examTypeAvgOrderByAggregateInput = {
    id?: SortOrder
    subjectId?: SortOrder
    formId?: SortOrder
  }

  export type examTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    definition?: SortOrder
    published?: SortOrder
    subjectId?: SortOrder
    formId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type examTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    definition?: SortOrder
    published?: SortOrder
    subjectId?: SortOrder
    formId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type examTypeSumOrderByAggregateInput = {
    id?: SortOrder
    subjectId?: SortOrder
    formId?: SortOrder
  }

  export type ExamTypeRelationFilter = {
    is?: examTypeWhereInput
    isNot?: examTypeWhereInput
  }

  export type examOrderByRelevanceInput = {
    fields: Enumerable<examOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type examCountOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    year?: SortOrder
    hasAnswers?: SortOrder
    published?: SortOrder
    examTypeId?: SortOrder
    exam?: SortOrder
    usersId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type examAvgOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    examTypeId?: SortOrder
    usersId?: SortOrder
  }

  export type examMaxOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    year?: SortOrder
    hasAnswers?: SortOrder
    published?: SortOrder
    examTypeId?: SortOrder
    exam?: SortOrder
    usersId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type examMinOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    year?: SortOrder
    hasAnswers?: SortOrder
    published?: SortOrder
    examTypeId?: SortOrder
    exam?: SortOrder
    usersId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type examSumOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    examTypeId?: SortOrder
    usersId?: SortOrder
  }

  export type ExamRelationFilter = {
    is?: examWhereInput
    isNot?: examWhereInput
  }

  export type examDownloadableOrderByRelevanceInput = {
    fields: Enumerable<examDownloadableOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type examDownloadableCountOrderByAggregateInput = {
    id?: SortOrder
    link?: SortOrder
    fileExtension?: SortOrder
    published?: SortOrder
    examId?: SortOrder
    usersId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type examDownloadableAvgOrderByAggregateInput = {
    id?: SortOrder
    examId?: SortOrder
    usersId?: SortOrder
  }

  export type examDownloadableMaxOrderByAggregateInput = {
    id?: SortOrder
    link?: SortOrder
    fileExtension?: SortOrder
    published?: SortOrder
    examId?: SortOrder
    usersId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type examDownloadableMinOrderByAggregateInput = {
    id?: SortOrder
    link?: SortOrder
    fileExtension?: SortOrder
    published?: SortOrder
    examId?: SortOrder
    usersId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type examDownloadableSumOrderByAggregateInput = {
    id?: SortOrder
    examId?: SortOrder
    usersId?: SortOrder
  }

  export type subjectReferenceOrderByRelevanceInput = {
    fields: Enumerable<subjectReferenceOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type subjectReferenceCountOrderByAggregateInput = {
    id?: SortOrder
    subjectName?: SortOrder
    subjectDefinition?: SortOrder
    imageLocation?: SortOrder
    published?: SortOrder
    usersId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type subjectReferenceAvgOrderByAggregateInput = {
    id?: SortOrder
    usersId?: SortOrder
  }

  export type subjectReferenceMaxOrderByAggregateInput = {
    id?: SortOrder
    subjectName?: SortOrder
    subjectDefinition?: SortOrder
    imageLocation?: SortOrder
    published?: SortOrder
    usersId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type subjectReferenceMinOrderByAggregateInput = {
    id?: SortOrder
    subjectName?: SortOrder
    subjectDefinition?: SortOrder
    imageLocation?: SortOrder
    published?: SortOrder
    usersId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type subjectReferenceSumOrderByAggregateInput = {
    id?: SortOrder
    usersId?: SortOrder
  }

  export type formReferenceOrderByRelevanceInput = {
    fields: Enumerable<formReferenceOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type formReferenceCountOrderByAggregateInput = {
    id?: SortOrder
    formName?: SortOrder
    usersId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type formReferenceAvgOrderByAggregateInput = {
    id?: SortOrder
    usersId?: SortOrder
  }

  export type formReferenceMaxOrderByAggregateInput = {
    id?: SortOrder
    formName?: SortOrder
    usersId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type formReferenceMinOrderByAggregateInput = {
    id?: SortOrder
    formName?: SortOrder
    usersId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type formReferenceSumOrderByAggregateInput = {
    id?: SortOrder
    usersId?: SortOrder
  }

  export type SubjectReferenceRelationFilter = {
    is?: subjectReferenceWhereInput
    isNot?: subjectReferenceWhereInput
  }

  export type referenceOrderByRelevanceInput = {
    fields: Enumerable<referenceOrderByRelevanceFieldEnum>
    sort: SortOrder
    search: string
  }

  export type referenceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    data?: SortOrder
    isPdf?: SortOrder
    published?: SortOrder
    subjectId?: SortOrder
    usersId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type referenceAvgOrderByAggregateInput = {
    id?: SortOrder
    subjectId?: SortOrder
    usersId?: SortOrder
  }

  export type referenceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    data?: SortOrder
    isPdf?: SortOrder
    published?: SortOrder
    subjectId?: SortOrder
    usersId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type referenceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    data?: SortOrder
    isPdf?: SortOrder
    published?: SortOrder
    subjectId?: SortOrder
    usersId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type referenceSumOrderByAggregateInput = {
    id?: SortOrder
    subjectId?: SortOrder
    usersId?: SortOrder
  }

  export type examCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<examCreateWithoutUsersInput>, Enumerable<examUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<examCreateOrConnectWithoutUsersInput>
    createMany?: examCreateManyUsersInputEnvelope
    connect?: Enumerable<examWhereUniqueInput>
  }

  export type examDownloadableCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<examDownloadableCreateWithoutUsersInput>, Enumerable<examDownloadableUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<examDownloadableCreateOrConnectWithoutUsersInput>
    createMany?: examDownloadableCreateManyUsersInputEnvelope
    connect?: Enumerable<examDownloadableWhereUniqueInput>
  }

  export type formCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<formCreateWithoutUsersInput>, Enumerable<formUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<formCreateOrConnectWithoutUsersInput>
    createMany?: formCreateManyUsersInputEnvelope
    connect?: Enumerable<formWhereUniqueInput>
  }

  export type formExamsCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<formExamsCreateWithoutUsersInput>, Enumerable<formExamsUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<formExamsCreateOrConnectWithoutUsersInput>
    createMany?: formExamsCreateManyUsersInputEnvelope
    connect?: Enumerable<formExamsWhereUniqueInput>
  }

  export type formReferenceCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<formReferenceCreateWithoutUsersInput>, Enumerable<formReferenceUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<formReferenceCreateOrConnectWithoutUsersInput>
    createMany?: formReferenceCreateManyUsersInputEnvelope
    connect?: Enumerable<formReferenceWhereUniqueInput>
  }

  export type formReviewCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<formReviewCreateWithoutUsersInput>, Enumerable<formReviewUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<formReviewCreateOrConnectWithoutUsersInput>
    createMany?: formReviewCreateManyUsersInputEnvelope
    connect?: Enumerable<formReviewWhereUniqueInput>
  }

  export type noteCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<noteCreateWithoutUsersInput>, Enumerable<noteUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<noteCreateOrConnectWithoutUsersInput>
    createMany?: noteCreateManyUsersInputEnvelope
    connect?: Enumerable<noteWhereUniqueInput>
  }

  export type notesDownloadableCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<notesDownloadableCreateWithoutUsersInput>, Enumerable<notesDownloadableUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<notesDownloadableCreateOrConnectWithoutUsersInput>
    createMany?: notesDownloadableCreateManyUsersInputEnvelope
    connect?: Enumerable<notesDownloadableWhereUniqueInput>
  }

  export type purchaseCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<purchaseCreateWithoutUsersInput>, Enumerable<purchaseUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<purchaseCreateOrConnectWithoutUsersInput>
    createMany?: purchaseCreateManyUsersInputEnvelope
    connect?: Enumerable<purchaseWhereUniqueInput>
  }

  export type questionCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<questionCreateWithoutUsersInput>, Enumerable<questionUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<questionCreateOrConnectWithoutUsersInput>
    createMany?: questionCreateManyUsersInputEnvelope
    connect?: Enumerable<questionWhereUniqueInput>
  }

  export type referenceCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<referenceCreateWithoutUsersInput>, Enumerable<referenceUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<referenceCreateOrConnectWithoutUsersInput>
    createMany?: referenceCreateManyUsersInputEnvelope
    connect?: Enumerable<referenceWhereUniqueInput>
  }

  export type reviewCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<reviewCreateWithoutUsersInput>, Enumerable<reviewUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<reviewCreateOrConnectWithoutUsersInput>
    createMany?: reviewCreateManyUsersInputEnvelope
    connect?: Enumerable<reviewWhereUniqueInput>
  }

  export type subjectCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<subjectCreateWithoutUsersInput>, Enumerable<subjectUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<subjectCreateOrConnectWithoutUsersInput>
    createMany?: subjectCreateManyUsersInputEnvelope
    connect?: Enumerable<subjectWhereUniqueInput>
  }

  export type subjectExamsCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<subjectExamsCreateWithoutUsersInput>, Enumerable<subjectExamsUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<subjectExamsCreateOrConnectWithoutUsersInput>
    createMany?: subjectExamsCreateManyUsersInputEnvelope
    connect?: Enumerable<subjectExamsWhereUniqueInput>
  }

  export type subjectReferenceCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<subjectReferenceCreateWithoutUsersInput>, Enumerable<subjectReferenceUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<subjectReferenceCreateOrConnectWithoutUsersInput>
    createMany?: subjectReferenceCreateManyUsersInputEnvelope
    connect?: Enumerable<subjectReferenceWhereUniqueInput>
  }

  export type subjectReviewCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<subjectReviewCreateWithoutUsersInput>, Enumerable<subjectReviewUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<subjectReviewCreateOrConnectWithoutUsersInput>
    createMany?: subjectReviewCreateManyUsersInputEnvelope
    connect?: Enumerable<subjectReviewWhereUniqueInput>
  }

  export type topicCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<topicCreateWithoutUsersInput>, Enumerable<topicUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<topicCreateOrConnectWithoutUsersInput>
    createMany?: topicCreateManyUsersInputEnvelope
    connect?: Enumerable<topicWhereUniqueInput>
  }

  export type topicReviewCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<topicReviewCreateWithoutUsersInput>, Enumerable<topicReviewUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<topicReviewCreateOrConnectWithoutUsersInput>
    createMany?: topicReviewCreateManyUsersInputEnvelope
    connect?: Enumerable<topicReviewWhereUniqueInput>
  }

  export type vifurushiCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<vifurushiCreateWithoutUsersInput>, Enumerable<vifurushiUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<vifurushiCreateOrConnectWithoutUsersInput>
    createMany?: vifurushiCreateManyUsersInputEnvelope
    connect?: Enumerable<vifurushiWhereUniqueInput>
  }

  export type examUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<examCreateWithoutUsersInput>, Enumerable<examUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<examCreateOrConnectWithoutUsersInput>
    createMany?: examCreateManyUsersInputEnvelope
    connect?: Enumerable<examWhereUniqueInput>
  }

  export type examDownloadableUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<examDownloadableCreateWithoutUsersInput>, Enumerable<examDownloadableUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<examDownloadableCreateOrConnectWithoutUsersInput>
    createMany?: examDownloadableCreateManyUsersInputEnvelope
    connect?: Enumerable<examDownloadableWhereUniqueInput>
  }

  export type formUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<formCreateWithoutUsersInput>, Enumerable<formUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<formCreateOrConnectWithoutUsersInput>
    createMany?: formCreateManyUsersInputEnvelope
    connect?: Enumerable<formWhereUniqueInput>
  }

  export type formExamsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<formExamsCreateWithoutUsersInput>, Enumerable<formExamsUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<formExamsCreateOrConnectWithoutUsersInput>
    createMany?: formExamsCreateManyUsersInputEnvelope
    connect?: Enumerable<formExamsWhereUniqueInput>
  }

  export type formReferenceUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<formReferenceCreateWithoutUsersInput>, Enumerable<formReferenceUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<formReferenceCreateOrConnectWithoutUsersInput>
    createMany?: formReferenceCreateManyUsersInputEnvelope
    connect?: Enumerable<formReferenceWhereUniqueInput>
  }

  export type formReviewUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<formReviewCreateWithoutUsersInput>, Enumerable<formReviewUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<formReviewCreateOrConnectWithoutUsersInput>
    createMany?: formReviewCreateManyUsersInputEnvelope
    connect?: Enumerable<formReviewWhereUniqueInput>
  }

  export type noteUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<noteCreateWithoutUsersInput>, Enumerable<noteUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<noteCreateOrConnectWithoutUsersInput>
    createMany?: noteCreateManyUsersInputEnvelope
    connect?: Enumerable<noteWhereUniqueInput>
  }

  export type notesDownloadableUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<notesDownloadableCreateWithoutUsersInput>, Enumerable<notesDownloadableUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<notesDownloadableCreateOrConnectWithoutUsersInput>
    createMany?: notesDownloadableCreateManyUsersInputEnvelope
    connect?: Enumerable<notesDownloadableWhereUniqueInput>
  }

  export type purchaseUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<purchaseCreateWithoutUsersInput>, Enumerable<purchaseUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<purchaseCreateOrConnectWithoutUsersInput>
    createMany?: purchaseCreateManyUsersInputEnvelope
    connect?: Enumerable<purchaseWhereUniqueInput>
  }

  export type questionUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<questionCreateWithoutUsersInput>, Enumerable<questionUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<questionCreateOrConnectWithoutUsersInput>
    createMany?: questionCreateManyUsersInputEnvelope
    connect?: Enumerable<questionWhereUniqueInput>
  }

  export type referenceUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<referenceCreateWithoutUsersInput>, Enumerable<referenceUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<referenceCreateOrConnectWithoutUsersInput>
    createMany?: referenceCreateManyUsersInputEnvelope
    connect?: Enumerable<referenceWhereUniqueInput>
  }

  export type reviewUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<reviewCreateWithoutUsersInput>, Enumerable<reviewUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<reviewCreateOrConnectWithoutUsersInput>
    createMany?: reviewCreateManyUsersInputEnvelope
    connect?: Enumerable<reviewWhereUniqueInput>
  }

  export type subjectUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<subjectCreateWithoutUsersInput>, Enumerable<subjectUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<subjectCreateOrConnectWithoutUsersInput>
    createMany?: subjectCreateManyUsersInputEnvelope
    connect?: Enumerable<subjectWhereUniqueInput>
  }

  export type subjectExamsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<subjectExamsCreateWithoutUsersInput>, Enumerable<subjectExamsUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<subjectExamsCreateOrConnectWithoutUsersInput>
    createMany?: subjectExamsCreateManyUsersInputEnvelope
    connect?: Enumerable<subjectExamsWhereUniqueInput>
  }

  export type subjectReferenceUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<subjectReferenceCreateWithoutUsersInput>, Enumerable<subjectReferenceUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<subjectReferenceCreateOrConnectWithoutUsersInput>
    createMany?: subjectReferenceCreateManyUsersInputEnvelope
    connect?: Enumerable<subjectReferenceWhereUniqueInput>
  }

  export type subjectReviewUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<subjectReviewCreateWithoutUsersInput>, Enumerable<subjectReviewUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<subjectReviewCreateOrConnectWithoutUsersInput>
    createMany?: subjectReviewCreateManyUsersInputEnvelope
    connect?: Enumerable<subjectReviewWhereUniqueInput>
  }

  export type topicUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<topicCreateWithoutUsersInput>, Enumerable<topicUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<topicCreateOrConnectWithoutUsersInput>
    createMany?: topicCreateManyUsersInputEnvelope
    connect?: Enumerable<topicWhereUniqueInput>
  }

  export type topicReviewUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<topicReviewCreateWithoutUsersInput>, Enumerable<topicReviewUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<topicReviewCreateOrConnectWithoutUsersInput>
    createMany?: topicReviewCreateManyUsersInputEnvelope
    connect?: Enumerable<topicReviewWhereUniqueInput>
  }

  export type vifurushiUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<vifurushiCreateWithoutUsersInput>, Enumerable<vifurushiUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<vifurushiCreateOrConnectWithoutUsersInput>
    createMany?: vifurushiCreateManyUsersInputEnvelope
    connect?: Enumerable<vifurushiWhereUniqueInput>
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type examUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<examCreateWithoutUsersInput>, Enumerable<examUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<examCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<examUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: examCreateManyUsersInputEnvelope
    set?: Enumerable<examWhereUniqueInput>
    disconnect?: Enumerable<examWhereUniqueInput>
    delete?: Enumerable<examWhereUniqueInput>
    connect?: Enumerable<examWhereUniqueInput>
    update?: Enumerable<examUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<examUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<examScalarWhereInput>
  }

  export type examDownloadableUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<examDownloadableCreateWithoutUsersInput>, Enumerable<examDownloadableUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<examDownloadableCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<examDownloadableUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: examDownloadableCreateManyUsersInputEnvelope
    set?: Enumerable<examDownloadableWhereUniqueInput>
    disconnect?: Enumerable<examDownloadableWhereUniqueInput>
    delete?: Enumerable<examDownloadableWhereUniqueInput>
    connect?: Enumerable<examDownloadableWhereUniqueInput>
    update?: Enumerable<examDownloadableUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<examDownloadableUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<examDownloadableScalarWhereInput>
  }

  export type formUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<formCreateWithoutUsersInput>, Enumerable<formUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<formCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<formUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: formCreateManyUsersInputEnvelope
    set?: Enumerable<formWhereUniqueInput>
    disconnect?: Enumerable<formWhereUniqueInput>
    delete?: Enumerable<formWhereUniqueInput>
    connect?: Enumerable<formWhereUniqueInput>
    update?: Enumerable<formUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<formUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<formScalarWhereInput>
  }

  export type formExamsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<formExamsCreateWithoutUsersInput>, Enumerable<formExamsUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<formExamsCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<formExamsUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: formExamsCreateManyUsersInputEnvelope
    set?: Enumerable<formExamsWhereUniqueInput>
    disconnect?: Enumerable<formExamsWhereUniqueInput>
    delete?: Enumerable<formExamsWhereUniqueInput>
    connect?: Enumerable<formExamsWhereUniqueInput>
    update?: Enumerable<formExamsUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<formExamsUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<formExamsScalarWhereInput>
  }

  export type formReferenceUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<formReferenceCreateWithoutUsersInput>, Enumerable<formReferenceUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<formReferenceCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<formReferenceUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: formReferenceCreateManyUsersInputEnvelope
    set?: Enumerable<formReferenceWhereUniqueInput>
    disconnect?: Enumerable<formReferenceWhereUniqueInput>
    delete?: Enumerable<formReferenceWhereUniqueInput>
    connect?: Enumerable<formReferenceWhereUniqueInput>
    update?: Enumerable<formReferenceUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<formReferenceUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<formReferenceScalarWhereInput>
  }

  export type formReviewUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<formReviewCreateWithoutUsersInput>, Enumerable<formReviewUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<formReviewCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<formReviewUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: formReviewCreateManyUsersInputEnvelope
    set?: Enumerable<formReviewWhereUniqueInput>
    disconnect?: Enumerable<formReviewWhereUniqueInput>
    delete?: Enumerable<formReviewWhereUniqueInput>
    connect?: Enumerable<formReviewWhereUniqueInput>
    update?: Enumerable<formReviewUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<formReviewUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<formReviewScalarWhereInput>
  }

  export type noteUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<noteCreateWithoutUsersInput>, Enumerable<noteUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<noteCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<noteUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: noteCreateManyUsersInputEnvelope
    set?: Enumerable<noteWhereUniqueInput>
    disconnect?: Enumerable<noteWhereUniqueInput>
    delete?: Enumerable<noteWhereUniqueInput>
    connect?: Enumerable<noteWhereUniqueInput>
    update?: Enumerable<noteUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<noteUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<noteScalarWhereInput>
  }

  export type notesDownloadableUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<notesDownloadableCreateWithoutUsersInput>, Enumerable<notesDownloadableUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<notesDownloadableCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<notesDownloadableUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: notesDownloadableCreateManyUsersInputEnvelope
    set?: Enumerable<notesDownloadableWhereUniqueInput>
    disconnect?: Enumerable<notesDownloadableWhereUniqueInput>
    delete?: Enumerable<notesDownloadableWhereUniqueInput>
    connect?: Enumerable<notesDownloadableWhereUniqueInput>
    update?: Enumerable<notesDownloadableUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<notesDownloadableUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<notesDownloadableScalarWhereInput>
  }

  export type purchaseUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<purchaseCreateWithoutUsersInput>, Enumerable<purchaseUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<purchaseCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<purchaseUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: purchaseCreateManyUsersInputEnvelope
    set?: Enumerable<purchaseWhereUniqueInput>
    disconnect?: Enumerable<purchaseWhereUniqueInput>
    delete?: Enumerable<purchaseWhereUniqueInput>
    connect?: Enumerable<purchaseWhereUniqueInput>
    update?: Enumerable<purchaseUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<purchaseUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<purchaseScalarWhereInput>
  }

  export type questionUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<questionCreateWithoutUsersInput>, Enumerable<questionUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<questionCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<questionUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: questionCreateManyUsersInputEnvelope
    set?: Enumerable<questionWhereUniqueInput>
    disconnect?: Enumerable<questionWhereUniqueInput>
    delete?: Enumerable<questionWhereUniqueInput>
    connect?: Enumerable<questionWhereUniqueInput>
    update?: Enumerable<questionUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<questionUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<questionScalarWhereInput>
  }

  export type referenceUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<referenceCreateWithoutUsersInput>, Enumerable<referenceUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<referenceCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<referenceUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: referenceCreateManyUsersInputEnvelope
    set?: Enumerable<referenceWhereUniqueInput>
    disconnect?: Enumerable<referenceWhereUniqueInput>
    delete?: Enumerable<referenceWhereUniqueInput>
    connect?: Enumerable<referenceWhereUniqueInput>
    update?: Enumerable<referenceUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<referenceUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<referenceScalarWhereInput>
  }

  export type reviewUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<reviewCreateWithoutUsersInput>, Enumerable<reviewUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<reviewCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<reviewUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: reviewCreateManyUsersInputEnvelope
    set?: Enumerable<reviewWhereUniqueInput>
    disconnect?: Enumerable<reviewWhereUniqueInput>
    delete?: Enumerable<reviewWhereUniqueInput>
    connect?: Enumerable<reviewWhereUniqueInput>
    update?: Enumerable<reviewUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<reviewUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<reviewScalarWhereInput>
  }

  export type subjectUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<subjectCreateWithoutUsersInput>, Enumerable<subjectUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<subjectCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<subjectUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: subjectCreateManyUsersInputEnvelope
    set?: Enumerable<subjectWhereUniqueInput>
    disconnect?: Enumerable<subjectWhereUniqueInput>
    delete?: Enumerable<subjectWhereUniqueInput>
    connect?: Enumerable<subjectWhereUniqueInput>
    update?: Enumerable<subjectUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<subjectUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<subjectScalarWhereInput>
  }

  export type subjectExamsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<subjectExamsCreateWithoutUsersInput>, Enumerable<subjectExamsUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<subjectExamsCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<subjectExamsUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: subjectExamsCreateManyUsersInputEnvelope
    set?: Enumerable<subjectExamsWhereUniqueInput>
    disconnect?: Enumerable<subjectExamsWhereUniqueInput>
    delete?: Enumerable<subjectExamsWhereUniqueInput>
    connect?: Enumerable<subjectExamsWhereUniqueInput>
    update?: Enumerable<subjectExamsUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<subjectExamsUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<subjectExamsScalarWhereInput>
  }

  export type subjectReferenceUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<subjectReferenceCreateWithoutUsersInput>, Enumerable<subjectReferenceUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<subjectReferenceCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<subjectReferenceUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: subjectReferenceCreateManyUsersInputEnvelope
    set?: Enumerable<subjectReferenceWhereUniqueInput>
    disconnect?: Enumerable<subjectReferenceWhereUniqueInput>
    delete?: Enumerable<subjectReferenceWhereUniqueInput>
    connect?: Enumerable<subjectReferenceWhereUniqueInput>
    update?: Enumerable<subjectReferenceUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<subjectReferenceUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<subjectReferenceScalarWhereInput>
  }

  export type subjectReviewUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<subjectReviewCreateWithoutUsersInput>, Enumerable<subjectReviewUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<subjectReviewCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<subjectReviewUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: subjectReviewCreateManyUsersInputEnvelope
    set?: Enumerable<subjectReviewWhereUniqueInput>
    disconnect?: Enumerable<subjectReviewWhereUniqueInput>
    delete?: Enumerable<subjectReviewWhereUniqueInput>
    connect?: Enumerable<subjectReviewWhereUniqueInput>
    update?: Enumerable<subjectReviewUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<subjectReviewUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<subjectReviewScalarWhereInput>
  }

  export type topicUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<topicCreateWithoutUsersInput>, Enumerable<topicUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<topicCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<topicUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: topicCreateManyUsersInputEnvelope
    set?: Enumerable<topicWhereUniqueInput>
    disconnect?: Enumerable<topicWhereUniqueInput>
    delete?: Enumerable<topicWhereUniqueInput>
    connect?: Enumerable<topicWhereUniqueInput>
    update?: Enumerable<topicUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<topicUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<topicScalarWhereInput>
  }

  export type topicReviewUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<topicReviewCreateWithoutUsersInput>, Enumerable<topicReviewUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<topicReviewCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<topicReviewUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: topicReviewCreateManyUsersInputEnvelope
    set?: Enumerable<topicReviewWhereUniqueInput>
    disconnect?: Enumerable<topicReviewWhereUniqueInput>
    delete?: Enumerable<topicReviewWhereUniqueInput>
    connect?: Enumerable<topicReviewWhereUniqueInput>
    update?: Enumerable<topicReviewUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<topicReviewUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<topicReviewScalarWhereInput>
  }

  export type vifurushiUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<vifurushiCreateWithoutUsersInput>, Enumerable<vifurushiUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<vifurushiCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<vifurushiUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: vifurushiCreateManyUsersInputEnvelope
    set?: Enumerable<vifurushiWhereUniqueInput>
    disconnect?: Enumerable<vifurushiWhereUniqueInput>
    delete?: Enumerable<vifurushiWhereUniqueInput>
    connect?: Enumerable<vifurushiWhereUniqueInput>
    update?: Enumerable<vifurushiUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<vifurushiUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<vifurushiScalarWhereInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type examUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<examCreateWithoutUsersInput>, Enumerable<examUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<examCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<examUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: examCreateManyUsersInputEnvelope
    set?: Enumerable<examWhereUniqueInput>
    disconnect?: Enumerable<examWhereUniqueInput>
    delete?: Enumerable<examWhereUniqueInput>
    connect?: Enumerable<examWhereUniqueInput>
    update?: Enumerable<examUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<examUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<examScalarWhereInput>
  }

  export type examDownloadableUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<examDownloadableCreateWithoutUsersInput>, Enumerable<examDownloadableUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<examDownloadableCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<examDownloadableUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: examDownloadableCreateManyUsersInputEnvelope
    set?: Enumerable<examDownloadableWhereUniqueInput>
    disconnect?: Enumerable<examDownloadableWhereUniqueInput>
    delete?: Enumerable<examDownloadableWhereUniqueInput>
    connect?: Enumerable<examDownloadableWhereUniqueInput>
    update?: Enumerable<examDownloadableUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<examDownloadableUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<examDownloadableScalarWhereInput>
  }

  export type formUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<formCreateWithoutUsersInput>, Enumerable<formUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<formCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<formUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: formCreateManyUsersInputEnvelope
    set?: Enumerable<formWhereUniqueInput>
    disconnect?: Enumerable<formWhereUniqueInput>
    delete?: Enumerable<formWhereUniqueInput>
    connect?: Enumerable<formWhereUniqueInput>
    update?: Enumerable<formUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<formUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<formScalarWhereInput>
  }

  export type formExamsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<formExamsCreateWithoutUsersInput>, Enumerable<formExamsUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<formExamsCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<formExamsUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: formExamsCreateManyUsersInputEnvelope
    set?: Enumerable<formExamsWhereUniqueInput>
    disconnect?: Enumerable<formExamsWhereUniqueInput>
    delete?: Enumerable<formExamsWhereUniqueInput>
    connect?: Enumerable<formExamsWhereUniqueInput>
    update?: Enumerable<formExamsUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<formExamsUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<formExamsScalarWhereInput>
  }

  export type formReferenceUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<formReferenceCreateWithoutUsersInput>, Enumerable<formReferenceUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<formReferenceCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<formReferenceUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: formReferenceCreateManyUsersInputEnvelope
    set?: Enumerable<formReferenceWhereUniqueInput>
    disconnect?: Enumerable<formReferenceWhereUniqueInput>
    delete?: Enumerable<formReferenceWhereUniqueInput>
    connect?: Enumerable<formReferenceWhereUniqueInput>
    update?: Enumerable<formReferenceUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<formReferenceUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<formReferenceScalarWhereInput>
  }

  export type formReviewUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<formReviewCreateWithoutUsersInput>, Enumerable<formReviewUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<formReviewCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<formReviewUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: formReviewCreateManyUsersInputEnvelope
    set?: Enumerable<formReviewWhereUniqueInput>
    disconnect?: Enumerable<formReviewWhereUniqueInput>
    delete?: Enumerable<formReviewWhereUniqueInput>
    connect?: Enumerable<formReviewWhereUniqueInput>
    update?: Enumerable<formReviewUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<formReviewUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<formReviewScalarWhereInput>
  }

  export type noteUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<noteCreateWithoutUsersInput>, Enumerable<noteUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<noteCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<noteUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: noteCreateManyUsersInputEnvelope
    set?: Enumerable<noteWhereUniqueInput>
    disconnect?: Enumerable<noteWhereUniqueInput>
    delete?: Enumerable<noteWhereUniqueInput>
    connect?: Enumerable<noteWhereUniqueInput>
    update?: Enumerable<noteUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<noteUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<noteScalarWhereInput>
  }

  export type notesDownloadableUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<notesDownloadableCreateWithoutUsersInput>, Enumerable<notesDownloadableUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<notesDownloadableCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<notesDownloadableUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: notesDownloadableCreateManyUsersInputEnvelope
    set?: Enumerable<notesDownloadableWhereUniqueInput>
    disconnect?: Enumerable<notesDownloadableWhereUniqueInput>
    delete?: Enumerable<notesDownloadableWhereUniqueInput>
    connect?: Enumerable<notesDownloadableWhereUniqueInput>
    update?: Enumerable<notesDownloadableUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<notesDownloadableUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<notesDownloadableScalarWhereInput>
  }

  export type purchaseUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<purchaseCreateWithoutUsersInput>, Enumerable<purchaseUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<purchaseCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<purchaseUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: purchaseCreateManyUsersInputEnvelope
    set?: Enumerable<purchaseWhereUniqueInput>
    disconnect?: Enumerable<purchaseWhereUniqueInput>
    delete?: Enumerable<purchaseWhereUniqueInput>
    connect?: Enumerable<purchaseWhereUniqueInput>
    update?: Enumerable<purchaseUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<purchaseUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<purchaseScalarWhereInput>
  }

  export type questionUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<questionCreateWithoutUsersInput>, Enumerable<questionUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<questionCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<questionUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: questionCreateManyUsersInputEnvelope
    set?: Enumerable<questionWhereUniqueInput>
    disconnect?: Enumerable<questionWhereUniqueInput>
    delete?: Enumerable<questionWhereUniqueInput>
    connect?: Enumerable<questionWhereUniqueInput>
    update?: Enumerable<questionUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<questionUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<questionScalarWhereInput>
  }

  export type referenceUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<referenceCreateWithoutUsersInput>, Enumerable<referenceUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<referenceCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<referenceUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: referenceCreateManyUsersInputEnvelope
    set?: Enumerable<referenceWhereUniqueInput>
    disconnect?: Enumerable<referenceWhereUniqueInput>
    delete?: Enumerable<referenceWhereUniqueInput>
    connect?: Enumerable<referenceWhereUniqueInput>
    update?: Enumerable<referenceUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<referenceUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<referenceScalarWhereInput>
  }

  export type reviewUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<reviewCreateWithoutUsersInput>, Enumerable<reviewUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<reviewCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<reviewUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: reviewCreateManyUsersInputEnvelope
    set?: Enumerable<reviewWhereUniqueInput>
    disconnect?: Enumerable<reviewWhereUniqueInput>
    delete?: Enumerable<reviewWhereUniqueInput>
    connect?: Enumerable<reviewWhereUniqueInput>
    update?: Enumerable<reviewUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<reviewUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<reviewScalarWhereInput>
  }

  export type subjectUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<subjectCreateWithoutUsersInput>, Enumerable<subjectUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<subjectCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<subjectUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: subjectCreateManyUsersInputEnvelope
    set?: Enumerable<subjectWhereUniqueInput>
    disconnect?: Enumerable<subjectWhereUniqueInput>
    delete?: Enumerable<subjectWhereUniqueInput>
    connect?: Enumerable<subjectWhereUniqueInput>
    update?: Enumerable<subjectUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<subjectUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<subjectScalarWhereInput>
  }

  export type subjectExamsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<subjectExamsCreateWithoutUsersInput>, Enumerable<subjectExamsUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<subjectExamsCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<subjectExamsUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: subjectExamsCreateManyUsersInputEnvelope
    set?: Enumerable<subjectExamsWhereUniqueInput>
    disconnect?: Enumerable<subjectExamsWhereUniqueInput>
    delete?: Enumerable<subjectExamsWhereUniqueInput>
    connect?: Enumerable<subjectExamsWhereUniqueInput>
    update?: Enumerable<subjectExamsUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<subjectExamsUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<subjectExamsScalarWhereInput>
  }

  export type subjectReferenceUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<subjectReferenceCreateWithoutUsersInput>, Enumerable<subjectReferenceUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<subjectReferenceCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<subjectReferenceUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: subjectReferenceCreateManyUsersInputEnvelope
    set?: Enumerable<subjectReferenceWhereUniqueInput>
    disconnect?: Enumerable<subjectReferenceWhereUniqueInput>
    delete?: Enumerable<subjectReferenceWhereUniqueInput>
    connect?: Enumerable<subjectReferenceWhereUniqueInput>
    update?: Enumerable<subjectReferenceUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<subjectReferenceUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<subjectReferenceScalarWhereInput>
  }

  export type subjectReviewUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<subjectReviewCreateWithoutUsersInput>, Enumerable<subjectReviewUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<subjectReviewCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<subjectReviewUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: subjectReviewCreateManyUsersInputEnvelope
    set?: Enumerable<subjectReviewWhereUniqueInput>
    disconnect?: Enumerable<subjectReviewWhereUniqueInput>
    delete?: Enumerable<subjectReviewWhereUniqueInput>
    connect?: Enumerable<subjectReviewWhereUniqueInput>
    update?: Enumerable<subjectReviewUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<subjectReviewUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<subjectReviewScalarWhereInput>
  }

  export type topicUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<topicCreateWithoutUsersInput>, Enumerable<topicUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<topicCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<topicUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: topicCreateManyUsersInputEnvelope
    set?: Enumerable<topicWhereUniqueInput>
    disconnect?: Enumerable<topicWhereUniqueInput>
    delete?: Enumerable<topicWhereUniqueInput>
    connect?: Enumerable<topicWhereUniqueInput>
    update?: Enumerable<topicUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<topicUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<topicScalarWhereInput>
  }

  export type topicReviewUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<topicReviewCreateWithoutUsersInput>, Enumerable<topicReviewUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<topicReviewCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<topicReviewUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: topicReviewCreateManyUsersInputEnvelope
    set?: Enumerable<topicReviewWhereUniqueInput>
    disconnect?: Enumerable<topicReviewWhereUniqueInput>
    delete?: Enumerable<topicReviewWhereUniqueInput>
    connect?: Enumerable<topicReviewWhereUniqueInput>
    update?: Enumerable<topicReviewUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<topicReviewUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<topicReviewScalarWhereInput>
  }

  export type vifurushiUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<vifurushiCreateWithoutUsersInput>, Enumerable<vifurushiUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<vifurushiCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<vifurushiUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: vifurushiCreateManyUsersInputEnvelope
    set?: Enumerable<vifurushiWhereUniqueInput>
    disconnect?: Enumerable<vifurushiWhereUniqueInput>
    delete?: Enumerable<vifurushiWhereUniqueInput>
    connect?: Enumerable<vifurushiWhereUniqueInput>
    update?: Enumerable<vifurushiUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<vifurushiUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<vifurushiScalarWhereInput>
  }

  export type usersCreateNestedOneWithoutVifurushiInput = {
    create?: XOR<usersCreateWithoutVifurushiInput, usersUncheckedCreateWithoutVifurushiInput>
    connectOrCreate?: usersCreateOrConnectWithoutVifurushiInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutVifurushiNestedInput = {
    create?: XOR<usersCreateWithoutVifurushiInput, usersUncheckedCreateWithoutVifurushiInput>
    connectOrCreate?: usersCreateOrConnectWithoutVifurushiInput
    upsert?: usersUpsertWithoutVifurushiInput
    connect?: usersWhereUniqueInput
    update?: XOR<usersUpdateWithoutVifurushiInput, usersUncheckedUpdateWithoutVifurushiInput>
  }

  export type booksDownloadCreateNestedOneWithoutVifurushiPackageInput = {
    create?: XOR<booksDownloadCreateWithoutVifurushiPackageInput, booksDownloadUncheckedCreateWithoutVifurushiPackageInput>
    connectOrCreate?: booksDownloadCreateOrConnectWithoutVifurushiPackageInput
    connect?: booksDownloadWhereUniqueInput
  }

  export type examAccessCreateNestedOneWithoutVifurushiPackageInput = {
    create?: XOR<examAccessCreateWithoutVifurushiPackageInput, examAccessUncheckedCreateWithoutVifurushiPackageInput>
    connectOrCreate?: examAccessCreateOrConnectWithoutVifurushiPackageInput
    connect?: examAccessWhereUniqueInput
  }

  export type examsSolvedDownloadCreateNestedOneWithoutVifurushiPackageInput = {
    create?: XOR<examsSolvedDownloadCreateWithoutVifurushiPackageInput, examsSolvedDownloadUncheckedCreateWithoutVifurushiPackageInput>
    connectOrCreate?: examsSolvedDownloadCreateOrConnectWithoutVifurushiPackageInput
    connect?: examsSolvedDownloadWhereUniqueInput
  }

  export type examsUnsolvedDownloadCreateNestedOneWithoutVifurushiPackageInput = {
    create?: XOR<examsUnsolvedDownloadCreateWithoutVifurushiPackageInput, examsUnsolvedDownloadUncheckedCreateWithoutVifurushiPackageInput>
    connectOrCreate?: examsUnsolvedDownloadCreateOrConnectWithoutVifurushiPackageInput
    connect?: examsUnsolvedDownloadWhereUniqueInput
  }

  export type notesDownloadCreateNestedOneWithoutVifurushiPackageInput = {
    create?: XOR<notesDownloadCreateWithoutVifurushiPackageInput, notesDownloadUncheckedCreateWithoutVifurushiPackageInput>
    connectOrCreate?: notesDownloadCreateOrConnectWithoutVifurushiPackageInput
    connect?: notesDownloadWhereUniqueInput
  }

  export type quizExcercisesCreateNestedOneWithoutVifurushiPackageInput = {
    create?: XOR<quizExcercisesCreateWithoutVifurushiPackageInput, quizExcercisesUncheckedCreateWithoutVifurushiPackageInput>
    connectOrCreate?: quizExcercisesCreateOrConnectWithoutVifurushiPackageInput
    connect?: quizExcercisesWhereUniqueInput
  }

  export type booksDownloadUncheckedCreateNestedOneWithoutVifurushiPackageInput = {
    create?: XOR<booksDownloadCreateWithoutVifurushiPackageInput, booksDownloadUncheckedCreateWithoutVifurushiPackageInput>
    connectOrCreate?: booksDownloadCreateOrConnectWithoutVifurushiPackageInput
    connect?: booksDownloadWhereUniqueInput
  }

  export type examAccessUncheckedCreateNestedOneWithoutVifurushiPackageInput = {
    create?: XOR<examAccessCreateWithoutVifurushiPackageInput, examAccessUncheckedCreateWithoutVifurushiPackageInput>
    connectOrCreate?: examAccessCreateOrConnectWithoutVifurushiPackageInput
    connect?: examAccessWhereUniqueInput
  }

  export type examsSolvedDownloadUncheckedCreateNestedOneWithoutVifurushiPackageInput = {
    create?: XOR<examsSolvedDownloadCreateWithoutVifurushiPackageInput, examsSolvedDownloadUncheckedCreateWithoutVifurushiPackageInput>
    connectOrCreate?: examsSolvedDownloadCreateOrConnectWithoutVifurushiPackageInput
    connect?: examsSolvedDownloadWhereUniqueInput
  }

  export type examsUnsolvedDownloadUncheckedCreateNestedOneWithoutVifurushiPackageInput = {
    create?: XOR<examsUnsolvedDownloadCreateWithoutVifurushiPackageInput, examsUnsolvedDownloadUncheckedCreateWithoutVifurushiPackageInput>
    connectOrCreate?: examsUnsolvedDownloadCreateOrConnectWithoutVifurushiPackageInput
    connect?: examsUnsolvedDownloadWhereUniqueInput
  }

  export type notesDownloadUncheckedCreateNestedOneWithoutVifurushiPackageInput = {
    create?: XOR<notesDownloadCreateWithoutVifurushiPackageInput, notesDownloadUncheckedCreateWithoutVifurushiPackageInput>
    connectOrCreate?: notesDownloadCreateOrConnectWithoutVifurushiPackageInput
    connect?: notesDownloadWhereUniqueInput
  }

  export type quizExcercisesUncheckedCreateNestedOneWithoutVifurushiPackageInput = {
    create?: XOR<quizExcercisesCreateWithoutVifurushiPackageInput, quizExcercisesUncheckedCreateWithoutVifurushiPackageInput>
    connectOrCreate?: quizExcercisesCreateOrConnectWithoutVifurushiPackageInput
    connect?: quizExcercisesWhereUniqueInput
  }

  export type booksDownloadUpdateOneWithoutVifurushiPackageNestedInput = {
    create?: XOR<booksDownloadCreateWithoutVifurushiPackageInput, booksDownloadUncheckedCreateWithoutVifurushiPackageInput>
    connectOrCreate?: booksDownloadCreateOrConnectWithoutVifurushiPackageInput
    upsert?: booksDownloadUpsertWithoutVifurushiPackageInput
    disconnect?: boolean
    delete?: boolean
    connect?: booksDownloadWhereUniqueInput
    update?: XOR<booksDownloadUpdateWithoutVifurushiPackageInput, booksDownloadUncheckedUpdateWithoutVifurushiPackageInput>
  }

  export type examAccessUpdateOneWithoutVifurushiPackageNestedInput = {
    create?: XOR<examAccessCreateWithoutVifurushiPackageInput, examAccessUncheckedCreateWithoutVifurushiPackageInput>
    connectOrCreate?: examAccessCreateOrConnectWithoutVifurushiPackageInput
    upsert?: examAccessUpsertWithoutVifurushiPackageInput
    disconnect?: boolean
    delete?: boolean
    connect?: examAccessWhereUniqueInput
    update?: XOR<examAccessUpdateWithoutVifurushiPackageInput, examAccessUncheckedUpdateWithoutVifurushiPackageInput>
  }

  export type examsSolvedDownloadUpdateOneWithoutVifurushiPackageNestedInput = {
    create?: XOR<examsSolvedDownloadCreateWithoutVifurushiPackageInput, examsSolvedDownloadUncheckedCreateWithoutVifurushiPackageInput>
    connectOrCreate?: examsSolvedDownloadCreateOrConnectWithoutVifurushiPackageInput
    upsert?: examsSolvedDownloadUpsertWithoutVifurushiPackageInput
    disconnect?: boolean
    delete?: boolean
    connect?: examsSolvedDownloadWhereUniqueInput
    update?: XOR<examsSolvedDownloadUpdateWithoutVifurushiPackageInput, examsSolvedDownloadUncheckedUpdateWithoutVifurushiPackageInput>
  }

  export type examsUnsolvedDownloadUpdateOneWithoutVifurushiPackageNestedInput = {
    create?: XOR<examsUnsolvedDownloadCreateWithoutVifurushiPackageInput, examsUnsolvedDownloadUncheckedCreateWithoutVifurushiPackageInput>
    connectOrCreate?: examsUnsolvedDownloadCreateOrConnectWithoutVifurushiPackageInput
    upsert?: examsUnsolvedDownloadUpsertWithoutVifurushiPackageInput
    disconnect?: boolean
    delete?: boolean
    connect?: examsUnsolvedDownloadWhereUniqueInput
    update?: XOR<examsUnsolvedDownloadUpdateWithoutVifurushiPackageInput, examsUnsolvedDownloadUncheckedUpdateWithoutVifurushiPackageInput>
  }

  export type notesDownloadUpdateOneWithoutVifurushiPackageNestedInput = {
    create?: XOR<notesDownloadCreateWithoutVifurushiPackageInput, notesDownloadUncheckedCreateWithoutVifurushiPackageInput>
    connectOrCreate?: notesDownloadCreateOrConnectWithoutVifurushiPackageInput
    upsert?: notesDownloadUpsertWithoutVifurushiPackageInput
    disconnect?: boolean
    delete?: boolean
    connect?: notesDownloadWhereUniqueInput
    update?: XOR<notesDownloadUpdateWithoutVifurushiPackageInput, notesDownloadUncheckedUpdateWithoutVifurushiPackageInput>
  }

  export type quizExcercisesUpdateOneWithoutVifurushiPackageNestedInput = {
    create?: XOR<quizExcercisesCreateWithoutVifurushiPackageInput, quizExcercisesUncheckedCreateWithoutVifurushiPackageInput>
    connectOrCreate?: quizExcercisesCreateOrConnectWithoutVifurushiPackageInput
    upsert?: quizExcercisesUpsertWithoutVifurushiPackageInput
    disconnect?: boolean
    delete?: boolean
    connect?: quizExcercisesWhereUniqueInput
    update?: XOR<quizExcercisesUpdateWithoutVifurushiPackageInput, quizExcercisesUncheckedUpdateWithoutVifurushiPackageInput>
  }

  export type booksDownloadUncheckedUpdateOneWithoutVifurushiPackageNestedInput = {
    create?: XOR<booksDownloadCreateWithoutVifurushiPackageInput, booksDownloadUncheckedCreateWithoutVifurushiPackageInput>
    connectOrCreate?: booksDownloadCreateOrConnectWithoutVifurushiPackageInput
    upsert?: booksDownloadUpsertWithoutVifurushiPackageInput
    disconnect?: boolean
    delete?: boolean
    connect?: booksDownloadWhereUniqueInput
    update?: XOR<booksDownloadUpdateWithoutVifurushiPackageInput, booksDownloadUncheckedUpdateWithoutVifurushiPackageInput>
  }

  export type examAccessUncheckedUpdateOneWithoutVifurushiPackageNestedInput = {
    create?: XOR<examAccessCreateWithoutVifurushiPackageInput, examAccessUncheckedCreateWithoutVifurushiPackageInput>
    connectOrCreate?: examAccessCreateOrConnectWithoutVifurushiPackageInput
    upsert?: examAccessUpsertWithoutVifurushiPackageInput
    disconnect?: boolean
    delete?: boolean
    connect?: examAccessWhereUniqueInput
    update?: XOR<examAccessUpdateWithoutVifurushiPackageInput, examAccessUncheckedUpdateWithoutVifurushiPackageInput>
  }

  export type examsSolvedDownloadUncheckedUpdateOneWithoutVifurushiPackageNestedInput = {
    create?: XOR<examsSolvedDownloadCreateWithoutVifurushiPackageInput, examsSolvedDownloadUncheckedCreateWithoutVifurushiPackageInput>
    connectOrCreate?: examsSolvedDownloadCreateOrConnectWithoutVifurushiPackageInput
    upsert?: examsSolvedDownloadUpsertWithoutVifurushiPackageInput
    disconnect?: boolean
    delete?: boolean
    connect?: examsSolvedDownloadWhereUniqueInput
    update?: XOR<examsSolvedDownloadUpdateWithoutVifurushiPackageInput, examsSolvedDownloadUncheckedUpdateWithoutVifurushiPackageInput>
  }

  export type examsUnsolvedDownloadUncheckedUpdateOneWithoutVifurushiPackageNestedInput = {
    create?: XOR<examsUnsolvedDownloadCreateWithoutVifurushiPackageInput, examsUnsolvedDownloadUncheckedCreateWithoutVifurushiPackageInput>
    connectOrCreate?: examsUnsolvedDownloadCreateOrConnectWithoutVifurushiPackageInput
    upsert?: examsUnsolvedDownloadUpsertWithoutVifurushiPackageInput
    disconnect?: boolean
    delete?: boolean
    connect?: examsUnsolvedDownloadWhereUniqueInput
    update?: XOR<examsUnsolvedDownloadUpdateWithoutVifurushiPackageInput, examsUnsolvedDownloadUncheckedUpdateWithoutVifurushiPackageInput>
  }

  export type notesDownloadUncheckedUpdateOneWithoutVifurushiPackageNestedInput = {
    create?: XOR<notesDownloadCreateWithoutVifurushiPackageInput, notesDownloadUncheckedCreateWithoutVifurushiPackageInput>
    connectOrCreate?: notesDownloadCreateOrConnectWithoutVifurushiPackageInput
    upsert?: notesDownloadUpsertWithoutVifurushiPackageInput
    disconnect?: boolean
    delete?: boolean
    connect?: notesDownloadWhereUniqueInput
    update?: XOR<notesDownloadUpdateWithoutVifurushiPackageInput, notesDownloadUncheckedUpdateWithoutVifurushiPackageInput>
  }

  export type quizExcercisesUncheckedUpdateOneWithoutVifurushiPackageNestedInput = {
    create?: XOR<quizExcercisesCreateWithoutVifurushiPackageInput, quizExcercisesUncheckedCreateWithoutVifurushiPackageInput>
    connectOrCreate?: quizExcercisesCreateOrConnectWithoutVifurushiPackageInput
    upsert?: quizExcercisesUpsertWithoutVifurushiPackageInput
    disconnect?: boolean
    delete?: boolean
    connect?: quizExcercisesWhereUniqueInput
    update?: XOR<quizExcercisesUpdateWithoutVifurushiPackageInput, quizExcercisesUncheckedUpdateWithoutVifurushiPackageInput>
  }

  export type vifurushiPackageCreateNestedOneWithoutNotesDownloadInput = {
    create?: XOR<vifurushiPackageCreateWithoutNotesDownloadInput, vifurushiPackageUncheckedCreateWithoutNotesDownloadInput>
    connectOrCreate?: vifurushiPackageCreateOrConnectWithoutNotesDownloadInput
    connect?: vifurushiPackageWhereUniqueInput
  }

  export type vifurushiPackageUpdateOneRequiredWithoutNotesDownloadNestedInput = {
    create?: XOR<vifurushiPackageCreateWithoutNotesDownloadInput, vifurushiPackageUncheckedCreateWithoutNotesDownloadInput>
    connectOrCreate?: vifurushiPackageCreateOrConnectWithoutNotesDownloadInput
    upsert?: vifurushiPackageUpsertWithoutNotesDownloadInput
    connect?: vifurushiPackageWhereUniqueInput
    update?: XOR<vifurushiPackageUpdateWithoutNotesDownloadInput, vifurushiPackageUncheckedUpdateWithoutNotesDownloadInput>
  }

  export type vifurushiPackageCreateNestedOneWithoutQuizExcercisesInput = {
    create?: XOR<vifurushiPackageCreateWithoutQuizExcercisesInput, vifurushiPackageUncheckedCreateWithoutQuizExcercisesInput>
    connectOrCreate?: vifurushiPackageCreateOrConnectWithoutQuizExcercisesInput
    connect?: vifurushiPackageWhereUniqueInput
  }

  export type vifurushiPackageUpdateOneRequiredWithoutQuizExcercisesNestedInput = {
    create?: XOR<vifurushiPackageCreateWithoutQuizExcercisesInput, vifurushiPackageUncheckedCreateWithoutQuizExcercisesInput>
    connectOrCreate?: vifurushiPackageCreateOrConnectWithoutQuizExcercisesInput
    upsert?: vifurushiPackageUpsertWithoutQuizExcercisesInput
    connect?: vifurushiPackageWhereUniqueInput
    update?: XOR<vifurushiPackageUpdateWithoutQuizExcercisesInput, vifurushiPackageUncheckedUpdateWithoutQuizExcercisesInput>
  }

  export type vifurushiPackageCreateNestedOneWithoutExamsUnsolvedDownloadInput = {
    create?: XOR<vifurushiPackageCreateWithoutExamsUnsolvedDownloadInput, vifurushiPackageUncheckedCreateWithoutExamsUnsolvedDownloadInput>
    connectOrCreate?: vifurushiPackageCreateOrConnectWithoutExamsUnsolvedDownloadInput
    connect?: vifurushiPackageWhereUniqueInput
  }

  export type vifurushiPackageUpdateOneRequiredWithoutExamsUnsolvedDownloadNestedInput = {
    create?: XOR<vifurushiPackageCreateWithoutExamsUnsolvedDownloadInput, vifurushiPackageUncheckedCreateWithoutExamsUnsolvedDownloadInput>
    connectOrCreate?: vifurushiPackageCreateOrConnectWithoutExamsUnsolvedDownloadInput
    upsert?: vifurushiPackageUpsertWithoutExamsUnsolvedDownloadInput
    connect?: vifurushiPackageWhereUniqueInput
    update?: XOR<vifurushiPackageUpdateWithoutExamsUnsolvedDownloadInput, vifurushiPackageUncheckedUpdateWithoutExamsUnsolvedDownloadInput>
  }

  export type vifurushiPackageCreateNestedOneWithoutExamsSolvedDownloadInput = {
    create?: XOR<vifurushiPackageCreateWithoutExamsSolvedDownloadInput, vifurushiPackageUncheckedCreateWithoutExamsSolvedDownloadInput>
    connectOrCreate?: vifurushiPackageCreateOrConnectWithoutExamsSolvedDownloadInput
    connect?: vifurushiPackageWhereUniqueInput
  }

  export type vifurushiPackageUpdateOneRequiredWithoutExamsSolvedDownloadNestedInput = {
    create?: XOR<vifurushiPackageCreateWithoutExamsSolvedDownloadInput, vifurushiPackageUncheckedCreateWithoutExamsSolvedDownloadInput>
    connectOrCreate?: vifurushiPackageCreateOrConnectWithoutExamsSolvedDownloadInput
    upsert?: vifurushiPackageUpsertWithoutExamsSolvedDownloadInput
    connect?: vifurushiPackageWhereUniqueInput
    update?: XOR<vifurushiPackageUpdateWithoutExamsSolvedDownloadInput, vifurushiPackageUncheckedUpdateWithoutExamsSolvedDownloadInput>
  }

  export type vifurushiPackageCreateNestedOneWithoutExamAccessInput = {
    create?: XOR<vifurushiPackageCreateWithoutExamAccessInput, vifurushiPackageUncheckedCreateWithoutExamAccessInput>
    connectOrCreate?: vifurushiPackageCreateOrConnectWithoutExamAccessInput
    connect?: vifurushiPackageWhereUniqueInput
  }

  export type vifurushiPackageUpdateOneRequiredWithoutExamAccessNestedInput = {
    create?: XOR<vifurushiPackageCreateWithoutExamAccessInput, vifurushiPackageUncheckedCreateWithoutExamAccessInput>
    connectOrCreate?: vifurushiPackageCreateOrConnectWithoutExamAccessInput
    upsert?: vifurushiPackageUpsertWithoutExamAccessInput
    connect?: vifurushiPackageWhereUniqueInput
    update?: XOR<vifurushiPackageUpdateWithoutExamAccessInput, vifurushiPackageUncheckedUpdateWithoutExamAccessInput>
  }

  export type vifurushiPackageCreateNestedOneWithoutBooksDownloadInput = {
    create?: XOR<vifurushiPackageCreateWithoutBooksDownloadInput, vifurushiPackageUncheckedCreateWithoutBooksDownloadInput>
    connectOrCreate?: vifurushiPackageCreateOrConnectWithoutBooksDownloadInput
    connect?: vifurushiPackageWhereUniqueInput
  }

  export type vifurushiPackageUpdateOneRequiredWithoutBooksDownloadNestedInput = {
    create?: XOR<vifurushiPackageCreateWithoutBooksDownloadInput, vifurushiPackageUncheckedCreateWithoutBooksDownloadInput>
    connectOrCreate?: vifurushiPackageCreateOrConnectWithoutBooksDownloadInput
    upsert?: vifurushiPackageUpsertWithoutBooksDownloadInput
    connect?: vifurushiPackageWhereUniqueInput
    update?: XOR<vifurushiPackageUpdateWithoutBooksDownloadInput, vifurushiPackageUncheckedUpdateWithoutBooksDownloadInput>
  }

  export type usersCreateNestedOneWithoutPurchaseInput = {
    create?: XOR<usersCreateWithoutPurchaseInput, usersUncheckedCreateWithoutPurchaseInput>
    connectOrCreate?: usersCreateOrConnectWithoutPurchaseInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutPurchaseNestedInput = {
    create?: XOR<usersCreateWithoutPurchaseInput, usersUncheckedCreateWithoutPurchaseInput>
    connectOrCreate?: usersCreateOrConnectWithoutPurchaseInput
    upsert?: usersUpsertWithoutPurchaseInput
    connect?: usersWhereUniqueInput
    update?: XOR<usersUpdateWithoutPurchaseInput, usersUncheckedUpdateWithoutPurchaseInput>
  }

  export type usersCreateNestedOneWithoutSubjectInput = {
    create?: XOR<usersCreateWithoutSubjectInput, usersUncheckedCreateWithoutSubjectInput>
    connectOrCreate?: usersCreateOrConnectWithoutSubjectInput
    connect?: usersWhereUniqueInput
  }

  export type noteCreateNestedManyWithoutSubjectInput = {
    create?: XOR<Enumerable<noteCreateWithoutSubjectInput>, Enumerable<noteUncheckedCreateWithoutSubjectInput>>
    connectOrCreate?: Enumerable<noteCreateOrConnectWithoutSubjectInput>
    createMany?: noteCreateManySubjectInputEnvelope
    connect?: Enumerable<noteWhereUniqueInput>
  }

  export type notesDownloadableCreateNestedManyWithoutSubjectInput = {
    create?: XOR<Enumerable<notesDownloadableCreateWithoutSubjectInput>, Enumerable<notesDownloadableUncheckedCreateWithoutSubjectInput>>
    connectOrCreate?: Enumerable<notesDownloadableCreateOrConnectWithoutSubjectInput>
    createMany?: notesDownloadableCreateManySubjectInputEnvelope
    connect?: Enumerable<notesDownloadableWhereUniqueInput>
  }

  export type topicCreateNestedManyWithoutSubjectInput = {
    create?: XOR<Enumerable<topicCreateWithoutSubjectInput>, Enumerable<topicUncheckedCreateWithoutSubjectInput>>
    connectOrCreate?: Enumerable<topicCreateOrConnectWithoutSubjectInput>
    createMany?: topicCreateManySubjectInputEnvelope
    connect?: Enumerable<topicWhereUniqueInput>
  }

  export type formCreateNestedManyWithoutSubjectsInput = {
    create?: XOR<Enumerable<formCreateWithoutSubjectsInput>, Enumerable<formUncheckedCreateWithoutSubjectsInput>>
    connectOrCreate?: Enumerable<formCreateOrConnectWithoutSubjectsInput>
    connect?: Enumerable<formWhereUniqueInput>
  }

  export type noteUncheckedCreateNestedManyWithoutSubjectInput = {
    create?: XOR<Enumerable<noteCreateWithoutSubjectInput>, Enumerable<noteUncheckedCreateWithoutSubjectInput>>
    connectOrCreate?: Enumerable<noteCreateOrConnectWithoutSubjectInput>
    createMany?: noteCreateManySubjectInputEnvelope
    connect?: Enumerable<noteWhereUniqueInput>
  }

  export type notesDownloadableUncheckedCreateNestedManyWithoutSubjectInput = {
    create?: XOR<Enumerable<notesDownloadableCreateWithoutSubjectInput>, Enumerable<notesDownloadableUncheckedCreateWithoutSubjectInput>>
    connectOrCreate?: Enumerable<notesDownloadableCreateOrConnectWithoutSubjectInput>
    createMany?: notesDownloadableCreateManySubjectInputEnvelope
    connect?: Enumerable<notesDownloadableWhereUniqueInput>
  }

  export type topicUncheckedCreateNestedManyWithoutSubjectInput = {
    create?: XOR<Enumerable<topicCreateWithoutSubjectInput>, Enumerable<topicUncheckedCreateWithoutSubjectInput>>
    connectOrCreate?: Enumerable<topicCreateOrConnectWithoutSubjectInput>
    createMany?: topicCreateManySubjectInputEnvelope
    connect?: Enumerable<topicWhereUniqueInput>
  }

  export type formUncheckedCreateNestedManyWithoutSubjectsInput = {
    create?: XOR<Enumerable<formCreateWithoutSubjectsInput>, Enumerable<formUncheckedCreateWithoutSubjectsInput>>
    connectOrCreate?: Enumerable<formCreateOrConnectWithoutSubjectsInput>
    connect?: Enumerable<formWhereUniqueInput>
  }

  export type usersUpdateOneRequiredWithoutSubjectNestedInput = {
    create?: XOR<usersCreateWithoutSubjectInput, usersUncheckedCreateWithoutSubjectInput>
    connectOrCreate?: usersCreateOrConnectWithoutSubjectInput
    upsert?: usersUpsertWithoutSubjectInput
    connect?: usersWhereUniqueInput
    update?: XOR<usersUpdateWithoutSubjectInput, usersUncheckedUpdateWithoutSubjectInput>
  }

  export type noteUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<Enumerable<noteCreateWithoutSubjectInput>, Enumerable<noteUncheckedCreateWithoutSubjectInput>>
    connectOrCreate?: Enumerable<noteCreateOrConnectWithoutSubjectInput>
    upsert?: Enumerable<noteUpsertWithWhereUniqueWithoutSubjectInput>
    createMany?: noteCreateManySubjectInputEnvelope
    set?: Enumerable<noteWhereUniqueInput>
    disconnect?: Enumerable<noteWhereUniqueInput>
    delete?: Enumerable<noteWhereUniqueInput>
    connect?: Enumerable<noteWhereUniqueInput>
    update?: Enumerable<noteUpdateWithWhereUniqueWithoutSubjectInput>
    updateMany?: Enumerable<noteUpdateManyWithWhereWithoutSubjectInput>
    deleteMany?: Enumerable<noteScalarWhereInput>
  }

  export type notesDownloadableUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<Enumerable<notesDownloadableCreateWithoutSubjectInput>, Enumerable<notesDownloadableUncheckedCreateWithoutSubjectInput>>
    connectOrCreate?: Enumerable<notesDownloadableCreateOrConnectWithoutSubjectInput>
    upsert?: Enumerable<notesDownloadableUpsertWithWhereUniqueWithoutSubjectInput>
    createMany?: notesDownloadableCreateManySubjectInputEnvelope
    set?: Enumerable<notesDownloadableWhereUniqueInput>
    disconnect?: Enumerable<notesDownloadableWhereUniqueInput>
    delete?: Enumerable<notesDownloadableWhereUniqueInput>
    connect?: Enumerable<notesDownloadableWhereUniqueInput>
    update?: Enumerable<notesDownloadableUpdateWithWhereUniqueWithoutSubjectInput>
    updateMany?: Enumerable<notesDownloadableUpdateManyWithWhereWithoutSubjectInput>
    deleteMany?: Enumerable<notesDownloadableScalarWhereInput>
  }

  export type topicUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<Enumerable<topicCreateWithoutSubjectInput>, Enumerable<topicUncheckedCreateWithoutSubjectInput>>
    connectOrCreate?: Enumerable<topicCreateOrConnectWithoutSubjectInput>
    upsert?: Enumerable<topicUpsertWithWhereUniqueWithoutSubjectInput>
    createMany?: topicCreateManySubjectInputEnvelope
    set?: Enumerable<topicWhereUniqueInput>
    disconnect?: Enumerable<topicWhereUniqueInput>
    delete?: Enumerable<topicWhereUniqueInput>
    connect?: Enumerable<topicWhereUniqueInput>
    update?: Enumerable<topicUpdateWithWhereUniqueWithoutSubjectInput>
    updateMany?: Enumerable<topicUpdateManyWithWhereWithoutSubjectInput>
    deleteMany?: Enumerable<topicScalarWhereInput>
  }

  export type formUpdateManyWithoutSubjectsNestedInput = {
    create?: XOR<Enumerable<formCreateWithoutSubjectsInput>, Enumerable<formUncheckedCreateWithoutSubjectsInput>>
    connectOrCreate?: Enumerable<formCreateOrConnectWithoutSubjectsInput>
    upsert?: Enumerable<formUpsertWithWhereUniqueWithoutSubjectsInput>
    set?: Enumerable<formWhereUniqueInput>
    disconnect?: Enumerable<formWhereUniqueInput>
    delete?: Enumerable<formWhereUniqueInput>
    connect?: Enumerable<formWhereUniqueInput>
    update?: Enumerable<formUpdateWithWhereUniqueWithoutSubjectsInput>
    updateMany?: Enumerable<formUpdateManyWithWhereWithoutSubjectsInput>
    deleteMany?: Enumerable<formScalarWhereInput>
  }

  export type noteUncheckedUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<Enumerable<noteCreateWithoutSubjectInput>, Enumerable<noteUncheckedCreateWithoutSubjectInput>>
    connectOrCreate?: Enumerable<noteCreateOrConnectWithoutSubjectInput>
    upsert?: Enumerable<noteUpsertWithWhereUniqueWithoutSubjectInput>
    createMany?: noteCreateManySubjectInputEnvelope
    set?: Enumerable<noteWhereUniqueInput>
    disconnect?: Enumerable<noteWhereUniqueInput>
    delete?: Enumerable<noteWhereUniqueInput>
    connect?: Enumerable<noteWhereUniqueInput>
    update?: Enumerable<noteUpdateWithWhereUniqueWithoutSubjectInput>
    updateMany?: Enumerable<noteUpdateManyWithWhereWithoutSubjectInput>
    deleteMany?: Enumerable<noteScalarWhereInput>
  }

  export type notesDownloadableUncheckedUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<Enumerable<notesDownloadableCreateWithoutSubjectInput>, Enumerable<notesDownloadableUncheckedCreateWithoutSubjectInput>>
    connectOrCreate?: Enumerable<notesDownloadableCreateOrConnectWithoutSubjectInput>
    upsert?: Enumerable<notesDownloadableUpsertWithWhereUniqueWithoutSubjectInput>
    createMany?: notesDownloadableCreateManySubjectInputEnvelope
    set?: Enumerable<notesDownloadableWhereUniqueInput>
    disconnect?: Enumerable<notesDownloadableWhereUniqueInput>
    delete?: Enumerable<notesDownloadableWhereUniqueInput>
    connect?: Enumerable<notesDownloadableWhereUniqueInput>
    update?: Enumerable<notesDownloadableUpdateWithWhereUniqueWithoutSubjectInput>
    updateMany?: Enumerable<notesDownloadableUpdateManyWithWhereWithoutSubjectInput>
    deleteMany?: Enumerable<notesDownloadableScalarWhereInput>
  }

  export type topicUncheckedUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<Enumerable<topicCreateWithoutSubjectInput>, Enumerable<topicUncheckedCreateWithoutSubjectInput>>
    connectOrCreate?: Enumerable<topicCreateOrConnectWithoutSubjectInput>
    upsert?: Enumerable<topicUpsertWithWhereUniqueWithoutSubjectInput>
    createMany?: topicCreateManySubjectInputEnvelope
    set?: Enumerable<topicWhereUniqueInput>
    disconnect?: Enumerable<topicWhereUniqueInput>
    delete?: Enumerable<topicWhereUniqueInput>
    connect?: Enumerable<topicWhereUniqueInput>
    update?: Enumerable<topicUpdateWithWhereUniqueWithoutSubjectInput>
    updateMany?: Enumerable<topicUpdateManyWithWhereWithoutSubjectInput>
    deleteMany?: Enumerable<topicScalarWhereInput>
  }

  export type formUncheckedUpdateManyWithoutSubjectsNestedInput = {
    create?: XOR<Enumerable<formCreateWithoutSubjectsInput>, Enumerable<formUncheckedCreateWithoutSubjectsInput>>
    connectOrCreate?: Enumerable<formCreateOrConnectWithoutSubjectsInput>
    upsert?: Enumerable<formUpsertWithWhereUniqueWithoutSubjectsInput>
    set?: Enumerable<formWhereUniqueInput>
    disconnect?: Enumerable<formWhereUniqueInput>
    delete?: Enumerable<formWhereUniqueInput>
    connect?: Enumerable<formWhereUniqueInput>
    update?: Enumerable<formUpdateWithWhereUniqueWithoutSubjectsInput>
    updateMany?: Enumerable<formUpdateManyWithWhereWithoutSubjectsInput>
    deleteMany?: Enumerable<formScalarWhereInput>
  }

  export type usersCreateNestedOneWithoutFormInput = {
    create?: XOR<usersCreateWithoutFormInput, usersUncheckedCreateWithoutFormInput>
    connectOrCreate?: usersCreateOrConnectWithoutFormInput
    connect?: usersWhereUniqueInput
  }

  export type noteCreateNestedManyWithoutFormInput = {
    create?: XOR<Enumerable<noteCreateWithoutFormInput>, Enumerable<noteUncheckedCreateWithoutFormInput>>
    connectOrCreate?: Enumerable<noteCreateOrConnectWithoutFormInput>
    createMany?: noteCreateManyFormInputEnvelope
    connect?: Enumerable<noteWhereUniqueInput>
  }

  export type notesDownloadableCreateNestedManyWithoutFormInput = {
    create?: XOR<Enumerable<notesDownloadableCreateWithoutFormInput>, Enumerable<notesDownloadableUncheckedCreateWithoutFormInput>>
    connectOrCreate?: Enumerable<notesDownloadableCreateOrConnectWithoutFormInput>
    createMany?: notesDownloadableCreateManyFormInputEnvelope
    connect?: Enumerable<notesDownloadableWhereUniqueInput>
  }

  export type topicCreateNestedManyWithoutFormInput = {
    create?: XOR<Enumerable<topicCreateWithoutFormInput>, Enumerable<topicUncheckedCreateWithoutFormInput>>
    connectOrCreate?: Enumerable<topicCreateOrConnectWithoutFormInput>
    createMany?: topicCreateManyFormInputEnvelope
    connect?: Enumerable<topicWhereUniqueInput>
  }

  export type subjectCreateNestedManyWithoutFormsInput = {
    create?: XOR<Enumerable<subjectCreateWithoutFormsInput>, Enumerable<subjectUncheckedCreateWithoutFormsInput>>
    connectOrCreate?: Enumerable<subjectCreateOrConnectWithoutFormsInput>
    connect?: Enumerable<subjectWhereUniqueInput>
  }

  export type noteUncheckedCreateNestedManyWithoutFormInput = {
    create?: XOR<Enumerable<noteCreateWithoutFormInput>, Enumerable<noteUncheckedCreateWithoutFormInput>>
    connectOrCreate?: Enumerable<noteCreateOrConnectWithoutFormInput>
    createMany?: noteCreateManyFormInputEnvelope
    connect?: Enumerable<noteWhereUniqueInput>
  }

  export type notesDownloadableUncheckedCreateNestedManyWithoutFormInput = {
    create?: XOR<Enumerable<notesDownloadableCreateWithoutFormInput>, Enumerable<notesDownloadableUncheckedCreateWithoutFormInput>>
    connectOrCreate?: Enumerable<notesDownloadableCreateOrConnectWithoutFormInput>
    createMany?: notesDownloadableCreateManyFormInputEnvelope
    connect?: Enumerable<notesDownloadableWhereUniqueInput>
  }

  export type topicUncheckedCreateNestedManyWithoutFormInput = {
    create?: XOR<Enumerable<topicCreateWithoutFormInput>, Enumerable<topicUncheckedCreateWithoutFormInput>>
    connectOrCreate?: Enumerable<topicCreateOrConnectWithoutFormInput>
    createMany?: topicCreateManyFormInputEnvelope
    connect?: Enumerable<topicWhereUniqueInput>
  }

  export type subjectUncheckedCreateNestedManyWithoutFormsInput = {
    create?: XOR<Enumerable<subjectCreateWithoutFormsInput>, Enumerable<subjectUncheckedCreateWithoutFormsInput>>
    connectOrCreate?: Enumerable<subjectCreateOrConnectWithoutFormsInput>
    connect?: Enumerable<subjectWhereUniqueInput>
  }

  export type usersUpdateOneRequiredWithoutFormNestedInput = {
    create?: XOR<usersCreateWithoutFormInput, usersUncheckedCreateWithoutFormInput>
    connectOrCreate?: usersCreateOrConnectWithoutFormInput
    upsert?: usersUpsertWithoutFormInput
    connect?: usersWhereUniqueInput
    update?: XOR<usersUpdateWithoutFormInput, usersUncheckedUpdateWithoutFormInput>
  }

  export type noteUpdateManyWithoutFormNestedInput = {
    create?: XOR<Enumerable<noteCreateWithoutFormInput>, Enumerable<noteUncheckedCreateWithoutFormInput>>
    connectOrCreate?: Enumerable<noteCreateOrConnectWithoutFormInput>
    upsert?: Enumerable<noteUpsertWithWhereUniqueWithoutFormInput>
    createMany?: noteCreateManyFormInputEnvelope
    set?: Enumerable<noteWhereUniqueInput>
    disconnect?: Enumerable<noteWhereUniqueInput>
    delete?: Enumerable<noteWhereUniqueInput>
    connect?: Enumerable<noteWhereUniqueInput>
    update?: Enumerable<noteUpdateWithWhereUniqueWithoutFormInput>
    updateMany?: Enumerable<noteUpdateManyWithWhereWithoutFormInput>
    deleteMany?: Enumerable<noteScalarWhereInput>
  }

  export type notesDownloadableUpdateManyWithoutFormNestedInput = {
    create?: XOR<Enumerable<notesDownloadableCreateWithoutFormInput>, Enumerable<notesDownloadableUncheckedCreateWithoutFormInput>>
    connectOrCreate?: Enumerable<notesDownloadableCreateOrConnectWithoutFormInput>
    upsert?: Enumerable<notesDownloadableUpsertWithWhereUniqueWithoutFormInput>
    createMany?: notesDownloadableCreateManyFormInputEnvelope
    set?: Enumerable<notesDownloadableWhereUniqueInput>
    disconnect?: Enumerable<notesDownloadableWhereUniqueInput>
    delete?: Enumerable<notesDownloadableWhereUniqueInput>
    connect?: Enumerable<notesDownloadableWhereUniqueInput>
    update?: Enumerable<notesDownloadableUpdateWithWhereUniqueWithoutFormInput>
    updateMany?: Enumerable<notesDownloadableUpdateManyWithWhereWithoutFormInput>
    deleteMany?: Enumerable<notesDownloadableScalarWhereInput>
  }

  export type topicUpdateManyWithoutFormNestedInput = {
    create?: XOR<Enumerable<topicCreateWithoutFormInput>, Enumerable<topicUncheckedCreateWithoutFormInput>>
    connectOrCreate?: Enumerable<topicCreateOrConnectWithoutFormInput>
    upsert?: Enumerable<topicUpsertWithWhereUniqueWithoutFormInput>
    createMany?: topicCreateManyFormInputEnvelope
    set?: Enumerable<topicWhereUniqueInput>
    disconnect?: Enumerable<topicWhereUniqueInput>
    delete?: Enumerable<topicWhereUniqueInput>
    connect?: Enumerable<topicWhereUniqueInput>
    update?: Enumerable<topicUpdateWithWhereUniqueWithoutFormInput>
    updateMany?: Enumerable<topicUpdateManyWithWhereWithoutFormInput>
    deleteMany?: Enumerable<topicScalarWhereInput>
  }

  export type subjectUpdateManyWithoutFormsNestedInput = {
    create?: XOR<Enumerable<subjectCreateWithoutFormsInput>, Enumerable<subjectUncheckedCreateWithoutFormsInput>>
    connectOrCreate?: Enumerable<subjectCreateOrConnectWithoutFormsInput>
    upsert?: Enumerable<subjectUpsertWithWhereUniqueWithoutFormsInput>
    set?: Enumerable<subjectWhereUniqueInput>
    disconnect?: Enumerable<subjectWhereUniqueInput>
    delete?: Enumerable<subjectWhereUniqueInput>
    connect?: Enumerable<subjectWhereUniqueInput>
    update?: Enumerable<subjectUpdateWithWhereUniqueWithoutFormsInput>
    updateMany?: Enumerable<subjectUpdateManyWithWhereWithoutFormsInput>
    deleteMany?: Enumerable<subjectScalarWhereInput>
  }

  export type noteUncheckedUpdateManyWithoutFormNestedInput = {
    create?: XOR<Enumerable<noteCreateWithoutFormInput>, Enumerable<noteUncheckedCreateWithoutFormInput>>
    connectOrCreate?: Enumerable<noteCreateOrConnectWithoutFormInput>
    upsert?: Enumerable<noteUpsertWithWhereUniqueWithoutFormInput>
    createMany?: noteCreateManyFormInputEnvelope
    set?: Enumerable<noteWhereUniqueInput>
    disconnect?: Enumerable<noteWhereUniqueInput>
    delete?: Enumerable<noteWhereUniqueInput>
    connect?: Enumerable<noteWhereUniqueInput>
    update?: Enumerable<noteUpdateWithWhereUniqueWithoutFormInput>
    updateMany?: Enumerable<noteUpdateManyWithWhereWithoutFormInput>
    deleteMany?: Enumerable<noteScalarWhereInput>
  }

  export type notesDownloadableUncheckedUpdateManyWithoutFormNestedInput = {
    create?: XOR<Enumerable<notesDownloadableCreateWithoutFormInput>, Enumerable<notesDownloadableUncheckedCreateWithoutFormInput>>
    connectOrCreate?: Enumerable<notesDownloadableCreateOrConnectWithoutFormInput>
    upsert?: Enumerable<notesDownloadableUpsertWithWhereUniqueWithoutFormInput>
    createMany?: notesDownloadableCreateManyFormInputEnvelope
    set?: Enumerable<notesDownloadableWhereUniqueInput>
    disconnect?: Enumerable<notesDownloadableWhereUniqueInput>
    delete?: Enumerable<notesDownloadableWhereUniqueInput>
    connect?: Enumerable<notesDownloadableWhereUniqueInput>
    update?: Enumerable<notesDownloadableUpdateWithWhereUniqueWithoutFormInput>
    updateMany?: Enumerable<notesDownloadableUpdateManyWithWhereWithoutFormInput>
    deleteMany?: Enumerable<notesDownloadableScalarWhereInput>
  }

  export type topicUncheckedUpdateManyWithoutFormNestedInput = {
    create?: XOR<Enumerable<topicCreateWithoutFormInput>, Enumerable<topicUncheckedCreateWithoutFormInput>>
    connectOrCreate?: Enumerable<topicCreateOrConnectWithoutFormInput>
    upsert?: Enumerable<topicUpsertWithWhereUniqueWithoutFormInput>
    createMany?: topicCreateManyFormInputEnvelope
    set?: Enumerable<topicWhereUniqueInput>
    disconnect?: Enumerable<topicWhereUniqueInput>
    delete?: Enumerable<topicWhereUniqueInput>
    connect?: Enumerable<topicWhereUniqueInput>
    update?: Enumerable<topicUpdateWithWhereUniqueWithoutFormInput>
    updateMany?: Enumerable<topicUpdateManyWithWhereWithoutFormInput>
    deleteMany?: Enumerable<topicScalarWhereInput>
  }

  export type subjectUncheckedUpdateManyWithoutFormsNestedInput = {
    create?: XOR<Enumerable<subjectCreateWithoutFormsInput>, Enumerable<subjectUncheckedCreateWithoutFormsInput>>
    connectOrCreate?: Enumerable<subjectCreateOrConnectWithoutFormsInput>
    upsert?: Enumerable<subjectUpsertWithWhereUniqueWithoutFormsInput>
    set?: Enumerable<subjectWhereUniqueInput>
    disconnect?: Enumerable<subjectWhereUniqueInput>
    delete?: Enumerable<subjectWhereUniqueInput>
    connect?: Enumerable<subjectWhereUniqueInput>
    update?: Enumerable<subjectUpdateWithWhereUniqueWithoutFormsInput>
    updateMany?: Enumerable<subjectUpdateManyWithWhereWithoutFormsInput>
    deleteMany?: Enumerable<subjectScalarWhereInput>
  }

  export type formCreateNestedOneWithoutTopicInput = {
    create?: XOR<formCreateWithoutTopicInput, formUncheckedCreateWithoutTopicInput>
    connectOrCreate?: formCreateOrConnectWithoutTopicInput
    connect?: formWhereUniqueInput
  }

  export type subjectCreateNestedOneWithoutTopicInput = {
    create?: XOR<subjectCreateWithoutTopicInput, subjectUncheckedCreateWithoutTopicInput>
    connectOrCreate?: subjectCreateOrConnectWithoutTopicInput
    connect?: subjectWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutTopicInput = {
    create?: XOR<usersCreateWithoutTopicInput, usersUncheckedCreateWithoutTopicInput>
    connectOrCreate?: usersCreateOrConnectWithoutTopicInput
    connect?: usersWhereUniqueInput
  }

  export type noteCreateNestedOneWithoutTopicInput = {
    create?: XOR<noteCreateWithoutTopicInput, noteUncheckedCreateWithoutTopicInput>
    connectOrCreate?: noteCreateOrConnectWithoutTopicInput
    connect?: noteWhereUniqueInput
  }

  export type noteUncheckedCreateNestedOneWithoutTopicInput = {
    create?: XOR<noteCreateWithoutTopicInput, noteUncheckedCreateWithoutTopicInput>
    connectOrCreate?: noteCreateOrConnectWithoutTopicInput
    connect?: noteWhereUniqueInput
  }

  export type formUpdateOneRequiredWithoutTopicNestedInput = {
    create?: XOR<formCreateWithoutTopicInput, formUncheckedCreateWithoutTopicInput>
    connectOrCreate?: formCreateOrConnectWithoutTopicInput
    upsert?: formUpsertWithoutTopicInput
    connect?: formWhereUniqueInput
    update?: XOR<formUpdateWithoutTopicInput, formUncheckedUpdateWithoutTopicInput>
  }

  export type subjectUpdateOneRequiredWithoutTopicNestedInput = {
    create?: XOR<subjectCreateWithoutTopicInput, subjectUncheckedCreateWithoutTopicInput>
    connectOrCreate?: subjectCreateOrConnectWithoutTopicInput
    upsert?: subjectUpsertWithoutTopicInput
    connect?: subjectWhereUniqueInput
    update?: XOR<subjectUpdateWithoutTopicInput, subjectUncheckedUpdateWithoutTopicInput>
  }

  export type usersUpdateOneRequiredWithoutTopicNestedInput = {
    create?: XOR<usersCreateWithoutTopicInput, usersUncheckedCreateWithoutTopicInput>
    connectOrCreate?: usersCreateOrConnectWithoutTopicInput
    upsert?: usersUpsertWithoutTopicInput
    connect?: usersWhereUniqueInput
    update?: XOR<usersUpdateWithoutTopicInput, usersUncheckedUpdateWithoutTopicInput>
  }

  export type noteUpdateOneWithoutTopicNestedInput = {
    create?: XOR<noteCreateWithoutTopicInput, noteUncheckedCreateWithoutTopicInput>
    connectOrCreate?: noteCreateOrConnectWithoutTopicInput
    upsert?: noteUpsertWithoutTopicInput
    disconnect?: boolean
    delete?: boolean
    connect?: noteWhereUniqueInput
    update?: XOR<noteUpdateWithoutTopicInput, noteUncheckedUpdateWithoutTopicInput>
  }

  export type noteUncheckedUpdateOneWithoutTopicNestedInput = {
    create?: XOR<noteCreateWithoutTopicInput, noteUncheckedCreateWithoutTopicInput>
    connectOrCreate?: noteCreateOrConnectWithoutTopicInput
    upsert?: noteUpsertWithoutTopicInput
    disconnect?: boolean
    delete?: boolean
    connect?: noteWhereUniqueInput
    update?: XOR<noteUpdateWithoutTopicInput, noteUncheckedUpdateWithoutTopicInput>
  }

  export type formCreateNestedOneWithoutNoteInput = {
    create?: XOR<formCreateWithoutNoteInput, formUncheckedCreateWithoutNoteInput>
    connectOrCreate?: formCreateOrConnectWithoutNoteInput
    connect?: formWhereUniqueInput
  }

  export type subjectCreateNestedOneWithoutNoteInput = {
    create?: XOR<subjectCreateWithoutNoteInput, subjectUncheckedCreateWithoutNoteInput>
    connectOrCreate?: subjectCreateOrConnectWithoutNoteInput
    connect?: subjectWhereUniqueInput
  }

  export type topicCreateNestedOneWithoutNoteInput = {
    create?: XOR<topicCreateWithoutNoteInput, topicUncheckedCreateWithoutNoteInput>
    connectOrCreate?: topicCreateOrConnectWithoutNoteInput
    connect?: topicWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutNoteInput = {
    create?: XOR<usersCreateWithoutNoteInput, usersUncheckedCreateWithoutNoteInput>
    connectOrCreate?: usersCreateOrConnectWithoutNoteInput
    connect?: usersWhereUniqueInput
  }

  export type formUpdateOneRequiredWithoutNoteNestedInput = {
    create?: XOR<formCreateWithoutNoteInput, formUncheckedCreateWithoutNoteInput>
    connectOrCreate?: formCreateOrConnectWithoutNoteInput
    upsert?: formUpsertWithoutNoteInput
    connect?: formWhereUniqueInput
    update?: XOR<formUpdateWithoutNoteInput, formUncheckedUpdateWithoutNoteInput>
  }

  export type subjectUpdateOneRequiredWithoutNoteNestedInput = {
    create?: XOR<subjectCreateWithoutNoteInput, subjectUncheckedCreateWithoutNoteInput>
    connectOrCreate?: subjectCreateOrConnectWithoutNoteInput
    upsert?: subjectUpsertWithoutNoteInput
    connect?: subjectWhereUniqueInput
    update?: XOR<subjectUpdateWithoutNoteInput, subjectUncheckedUpdateWithoutNoteInput>
  }

  export type topicUpdateOneRequiredWithoutNoteNestedInput = {
    create?: XOR<topicCreateWithoutNoteInput, topicUncheckedCreateWithoutNoteInput>
    connectOrCreate?: topicCreateOrConnectWithoutNoteInput
    upsert?: topicUpsertWithoutNoteInput
    connect?: topicWhereUniqueInput
    update?: XOR<topicUpdateWithoutNoteInput, topicUncheckedUpdateWithoutNoteInput>
  }

  export type usersUpdateOneRequiredWithoutNoteNestedInput = {
    create?: XOR<usersCreateWithoutNoteInput, usersUncheckedCreateWithoutNoteInput>
    connectOrCreate?: usersCreateOrConnectWithoutNoteInput
    upsert?: usersUpsertWithoutNoteInput
    connect?: usersWhereUniqueInput
    update?: XOR<usersUpdateWithoutNoteInput, usersUncheckedUpdateWithoutNoteInput>
  }

  export type formCreateNestedOneWithoutNotesDownloadableInput = {
    create?: XOR<formCreateWithoutNotesDownloadableInput, formUncheckedCreateWithoutNotesDownloadableInput>
    connectOrCreate?: formCreateOrConnectWithoutNotesDownloadableInput
    connect?: formWhereUniqueInput
  }

  export type subjectCreateNestedOneWithoutNotesDownloadableInput = {
    create?: XOR<subjectCreateWithoutNotesDownloadableInput, subjectUncheckedCreateWithoutNotesDownloadableInput>
    connectOrCreate?: subjectCreateOrConnectWithoutNotesDownloadableInput
    connect?: subjectWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutNotesDownloadableInput = {
    create?: XOR<usersCreateWithoutNotesDownloadableInput, usersUncheckedCreateWithoutNotesDownloadableInput>
    connectOrCreate?: usersCreateOrConnectWithoutNotesDownloadableInput
    connect?: usersWhereUniqueInput
  }

  export type formUpdateOneRequiredWithoutNotesDownloadableNestedInput = {
    create?: XOR<formCreateWithoutNotesDownloadableInput, formUncheckedCreateWithoutNotesDownloadableInput>
    connectOrCreate?: formCreateOrConnectWithoutNotesDownloadableInput
    upsert?: formUpsertWithoutNotesDownloadableInput
    connect?: formWhereUniqueInput
    update?: XOR<formUpdateWithoutNotesDownloadableInput, formUncheckedUpdateWithoutNotesDownloadableInput>
  }

  export type subjectUpdateOneRequiredWithoutNotesDownloadableNestedInput = {
    create?: XOR<subjectCreateWithoutNotesDownloadableInput, subjectUncheckedCreateWithoutNotesDownloadableInput>
    connectOrCreate?: subjectCreateOrConnectWithoutNotesDownloadableInput
    upsert?: subjectUpsertWithoutNotesDownloadableInput
    connect?: subjectWhereUniqueInput
    update?: XOR<subjectUpdateWithoutNotesDownloadableInput, subjectUncheckedUpdateWithoutNotesDownloadableInput>
  }

  export type usersUpdateOneRequiredWithoutNotesDownloadableNestedInput = {
    create?: XOR<usersCreateWithoutNotesDownloadableInput, usersUncheckedCreateWithoutNotesDownloadableInput>
    connectOrCreate?: usersCreateOrConnectWithoutNotesDownloadableInput
    upsert?: usersUpsertWithoutNotesDownloadableInput
    connect?: usersWhereUniqueInput
    update?: XOR<usersUpdateWithoutNotesDownloadableInput, usersUncheckedUpdateWithoutNotesDownloadableInput>
  }

  export type usersCreateNestedOneWithoutSubjectReviewInput = {
    create?: XOR<usersCreateWithoutSubjectReviewInput, usersUncheckedCreateWithoutSubjectReviewInput>
    connectOrCreate?: usersCreateOrConnectWithoutSubjectReviewInput
    connect?: usersWhereUniqueInput
  }

  export type reviewCreateNestedManyWithoutSubjectInput = {
    create?: XOR<Enumerable<reviewCreateWithoutSubjectInput>, Enumerable<reviewUncheckedCreateWithoutSubjectInput>>
    connectOrCreate?: Enumerable<reviewCreateOrConnectWithoutSubjectInput>
    createMany?: reviewCreateManySubjectInputEnvelope
    connect?: Enumerable<reviewWhereUniqueInput>
  }

  export type topicReviewCreateNestedManyWithoutSubjectInput = {
    create?: XOR<Enumerable<topicReviewCreateWithoutSubjectInput>, Enumerable<topicReviewUncheckedCreateWithoutSubjectInput>>
    connectOrCreate?: Enumerable<topicReviewCreateOrConnectWithoutSubjectInput>
    createMany?: topicReviewCreateManySubjectInputEnvelope
    connect?: Enumerable<topicReviewWhereUniqueInput>
  }

  export type formReviewCreateNestedManyWithoutSubjectsInput = {
    create?: XOR<Enumerable<formReviewCreateWithoutSubjectsInput>, Enumerable<formReviewUncheckedCreateWithoutSubjectsInput>>
    connectOrCreate?: Enumerable<formReviewCreateOrConnectWithoutSubjectsInput>
    connect?: Enumerable<formReviewWhereUniqueInput>
  }

  export type reviewUncheckedCreateNestedManyWithoutSubjectInput = {
    create?: XOR<Enumerable<reviewCreateWithoutSubjectInput>, Enumerable<reviewUncheckedCreateWithoutSubjectInput>>
    connectOrCreate?: Enumerable<reviewCreateOrConnectWithoutSubjectInput>
    createMany?: reviewCreateManySubjectInputEnvelope
    connect?: Enumerable<reviewWhereUniqueInput>
  }

  export type topicReviewUncheckedCreateNestedManyWithoutSubjectInput = {
    create?: XOR<Enumerable<topicReviewCreateWithoutSubjectInput>, Enumerable<topicReviewUncheckedCreateWithoutSubjectInput>>
    connectOrCreate?: Enumerable<topicReviewCreateOrConnectWithoutSubjectInput>
    createMany?: topicReviewCreateManySubjectInputEnvelope
    connect?: Enumerable<topicReviewWhereUniqueInput>
  }

  export type formReviewUncheckedCreateNestedManyWithoutSubjectsInput = {
    create?: XOR<Enumerable<formReviewCreateWithoutSubjectsInput>, Enumerable<formReviewUncheckedCreateWithoutSubjectsInput>>
    connectOrCreate?: Enumerable<formReviewCreateOrConnectWithoutSubjectsInput>
    connect?: Enumerable<formReviewWhereUniqueInput>
  }

  export type usersUpdateOneRequiredWithoutSubjectReviewNestedInput = {
    create?: XOR<usersCreateWithoutSubjectReviewInput, usersUncheckedCreateWithoutSubjectReviewInput>
    connectOrCreate?: usersCreateOrConnectWithoutSubjectReviewInput
    upsert?: usersUpsertWithoutSubjectReviewInput
    connect?: usersWhereUniqueInput
    update?: XOR<usersUpdateWithoutSubjectReviewInput, usersUncheckedUpdateWithoutSubjectReviewInput>
  }

  export type reviewUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<Enumerable<reviewCreateWithoutSubjectInput>, Enumerable<reviewUncheckedCreateWithoutSubjectInput>>
    connectOrCreate?: Enumerable<reviewCreateOrConnectWithoutSubjectInput>
    upsert?: Enumerable<reviewUpsertWithWhereUniqueWithoutSubjectInput>
    createMany?: reviewCreateManySubjectInputEnvelope
    set?: Enumerable<reviewWhereUniqueInput>
    disconnect?: Enumerable<reviewWhereUniqueInput>
    delete?: Enumerable<reviewWhereUniqueInput>
    connect?: Enumerable<reviewWhereUniqueInput>
    update?: Enumerable<reviewUpdateWithWhereUniqueWithoutSubjectInput>
    updateMany?: Enumerable<reviewUpdateManyWithWhereWithoutSubjectInput>
    deleteMany?: Enumerable<reviewScalarWhereInput>
  }

  export type topicReviewUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<Enumerable<topicReviewCreateWithoutSubjectInput>, Enumerable<topicReviewUncheckedCreateWithoutSubjectInput>>
    connectOrCreate?: Enumerable<topicReviewCreateOrConnectWithoutSubjectInput>
    upsert?: Enumerable<topicReviewUpsertWithWhereUniqueWithoutSubjectInput>
    createMany?: topicReviewCreateManySubjectInputEnvelope
    set?: Enumerable<topicReviewWhereUniqueInput>
    disconnect?: Enumerable<topicReviewWhereUniqueInput>
    delete?: Enumerable<topicReviewWhereUniqueInput>
    connect?: Enumerable<topicReviewWhereUniqueInput>
    update?: Enumerable<topicReviewUpdateWithWhereUniqueWithoutSubjectInput>
    updateMany?: Enumerable<topicReviewUpdateManyWithWhereWithoutSubjectInput>
    deleteMany?: Enumerable<topicReviewScalarWhereInput>
  }

  export type formReviewUpdateManyWithoutSubjectsNestedInput = {
    create?: XOR<Enumerable<formReviewCreateWithoutSubjectsInput>, Enumerable<formReviewUncheckedCreateWithoutSubjectsInput>>
    connectOrCreate?: Enumerable<formReviewCreateOrConnectWithoutSubjectsInput>
    upsert?: Enumerable<formReviewUpsertWithWhereUniqueWithoutSubjectsInput>
    set?: Enumerable<formReviewWhereUniqueInput>
    disconnect?: Enumerable<formReviewWhereUniqueInput>
    delete?: Enumerable<formReviewWhereUniqueInput>
    connect?: Enumerable<formReviewWhereUniqueInput>
    update?: Enumerable<formReviewUpdateWithWhereUniqueWithoutSubjectsInput>
    updateMany?: Enumerable<formReviewUpdateManyWithWhereWithoutSubjectsInput>
    deleteMany?: Enumerable<formReviewScalarWhereInput>
  }

  export type reviewUncheckedUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<Enumerable<reviewCreateWithoutSubjectInput>, Enumerable<reviewUncheckedCreateWithoutSubjectInput>>
    connectOrCreate?: Enumerable<reviewCreateOrConnectWithoutSubjectInput>
    upsert?: Enumerable<reviewUpsertWithWhereUniqueWithoutSubjectInput>
    createMany?: reviewCreateManySubjectInputEnvelope
    set?: Enumerable<reviewWhereUniqueInput>
    disconnect?: Enumerable<reviewWhereUniqueInput>
    delete?: Enumerable<reviewWhereUniqueInput>
    connect?: Enumerable<reviewWhereUniqueInput>
    update?: Enumerable<reviewUpdateWithWhereUniqueWithoutSubjectInput>
    updateMany?: Enumerable<reviewUpdateManyWithWhereWithoutSubjectInput>
    deleteMany?: Enumerable<reviewScalarWhereInput>
  }

  export type topicReviewUncheckedUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<Enumerable<topicReviewCreateWithoutSubjectInput>, Enumerable<topicReviewUncheckedCreateWithoutSubjectInput>>
    connectOrCreate?: Enumerable<topicReviewCreateOrConnectWithoutSubjectInput>
    upsert?: Enumerable<topicReviewUpsertWithWhereUniqueWithoutSubjectInput>
    createMany?: topicReviewCreateManySubjectInputEnvelope
    set?: Enumerable<topicReviewWhereUniqueInput>
    disconnect?: Enumerable<topicReviewWhereUniqueInput>
    delete?: Enumerable<topicReviewWhereUniqueInput>
    connect?: Enumerable<topicReviewWhereUniqueInput>
    update?: Enumerable<topicReviewUpdateWithWhereUniqueWithoutSubjectInput>
    updateMany?: Enumerable<topicReviewUpdateManyWithWhereWithoutSubjectInput>
    deleteMany?: Enumerable<topicReviewScalarWhereInput>
  }

  export type formReviewUncheckedUpdateManyWithoutSubjectsNestedInput = {
    create?: XOR<Enumerable<formReviewCreateWithoutSubjectsInput>, Enumerable<formReviewUncheckedCreateWithoutSubjectsInput>>
    connectOrCreate?: Enumerable<formReviewCreateOrConnectWithoutSubjectsInput>
    upsert?: Enumerable<formReviewUpsertWithWhereUniqueWithoutSubjectsInput>
    set?: Enumerable<formReviewWhereUniqueInput>
    disconnect?: Enumerable<formReviewWhereUniqueInput>
    delete?: Enumerable<formReviewWhereUniqueInput>
    connect?: Enumerable<formReviewWhereUniqueInput>
    update?: Enumerable<formReviewUpdateWithWhereUniqueWithoutSubjectsInput>
    updateMany?: Enumerable<formReviewUpdateManyWithWhereWithoutSubjectsInput>
    deleteMany?: Enumerable<formReviewScalarWhereInput>
  }

  export type usersCreateNestedOneWithoutFormReviewInput = {
    create?: XOR<usersCreateWithoutFormReviewInput, usersUncheckedCreateWithoutFormReviewInput>
    connectOrCreate?: usersCreateOrConnectWithoutFormReviewInput
    connect?: usersWhereUniqueInput
  }

  export type reviewCreateNestedManyWithoutFormInput = {
    create?: XOR<Enumerable<reviewCreateWithoutFormInput>, Enumerable<reviewUncheckedCreateWithoutFormInput>>
    connectOrCreate?: Enumerable<reviewCreateOrConnectWithoutFormInput>
    createMany?: reviewCreateManyFormInputEnvelope
    connect?: Enumerable<reviewWhereUniqueInput>
  }

  export type topicReviewCreateNestedManyWithoutFormInput = {
    create?: XOR<Enumerable<topicReviewCreateWithoutFormInput>, Enumerable<topicReviewUncheckedCreateWithoutFormInput>>
    connectOrCreate?: Enumerable<topicReviewCreateOrConnectWithoutFormInput>
    createMany?: topicReviewCreateManyFormInputEnvelope
    connect?: Enumerable<topicReviewWhereUniqueInput>
  }

  export type subjectReviewCreateNestedManyWithoutFormsInput = {
    create?: XOR<Enumerable<subjectReviewCreateWithoutFormsInput>, Enumerable<subjectReviewUncheckedCreateWithoutFormsInput>>
    connectOrCreate?: Enumerable<subjectReviewCreateOrConnectWithoutFormsInput>
    connect?: Enumerable<subjectReviewWhereUniqueInput>
  }

  export type reviewUncheckedCreateNestedManyWithoutFormInput = {
    create?: XOR<Enumerable<reviewCreateWithoutFormInput>, Enumerable<reviewUncheckedCreateWithoutFormInput>>
    connectOrCreate?: Enumerable<reviewCreateOrConnectWithoutFormInput>
    createMany?: reviewCreateManyFormInputEnvelope
    connect?: Enumerable<reviewWhereUniqueInput>
  }

  export type topicReviewUncheckedCreateNestedManyWithoutFormInput = {
    create?: XOR<Enumerable<topicReviewCreateWithoutFormInput>, Enumerable<topicReviewUncheckedCreateWithoutFormInput>>
    connectOrCreate?: Enumerable<topicReviewCreateOrConnectWithoutFormInput>
    createMany?: topicReviewCreateManyFormInputEnvelope
    connect?: Enumerable<topicReviewWhereUniqueInput>
  }

  export type subjectReviewUncheckedCreateNestedManyWithoutFormsInput = {
    create?: XOR<Enumerable<subjectReviewCreateWithoutFormsInput>, Enumerable<subjectReviewUncheckedCreateWithoutFormsInput>>
    connectOrCreate?: Enumerable<subjectReviewCreateOrConnectWithoutFormsInput>
    connect?: Enumerable<subjectReviewWhereUniqueInput>
  }

  export type usersUpdateOneRequiredWithoutFormReviewNestedInput = {
    create?: XOR<usersCreateWithoutFormReviewInput, usersUncheckedCreateWithoutFormReviewInput>
    connectOrCreate?: usersCreateOrConnectWithoutFormReviewInput
    upsert?: usersUpsertWithoutFormReviewInput
    connect?: usersWhereUniqueInput
    update?: XOR<usersUpdateWithoutFormReviewInput, usersUncheckedUpdateWithoutFormReviewInput>
  }

  export type reviewUpdateManyWithoutFormNestedInput = {
    create?: XOR<Enumerable<reviewCreateWithoutFormInput>, Enumerable<reviewUncheckedCreateWithoutFormInput>>
    connectOrCreate?: Enumerable<reviewCreateOrConnectWithoutFormInput>
    upsert?: Enumerable<reviewUpsertWithWhereUniqueWithoutFormInput>
    createMany?: reviewCreateManyFormInputEnvelope
    set?: Enumerable<reviewWhereUniqueInput>
    disconnect?: Enumerable<reviewWhereUniqueInput>
    delete?: Enumerable<reviewWhereUniqueInput>
    connect?: Enumerable<reviewWhereUniqueInput>
    update?: Enumerable<reviewUpdateWithWhereUniqueWithoutFormInput>
    updateMany?: Enumerable<reviewUpdateManyWithWhereWithoutFormInput>
    deleteMany?: Enumerable<reviewScalarWhereInput>
  }

  export type topicReviewUpdateManyWithoutFormNestedInput = {
    create?: XOR<Enumerable<topicReviewCreateWithoutFormInput>, Enumerable<topicReviewUncheckedCreateWithoutFormInput>>
    connectOrCreate?: Enumerable<topicReviewCreateOrConnectWithoutFormInput>
    upsert?: Enumerable<topicReviewUpsertWithWhereUniqueWithoutFormInput>
    createMany?: topicReviewCreateManyFormInputEnvelope
    set?: Enumerable<topicReviewWhereUniqueInput>
    disconnect?: Enumerable<topicReviewWhereUniqueInput>
    delete?: Enumerable<topicReviewWhereUniqueInput>
    connect?: Enumerable<topicReviewWhereUniqueInput>
    update?: Enumerable<topicReviewUpdateWithWhereUniqueWithoutFormInput>
    updateMany?: Enumerable<topicReviewUpdateManyWithWhereWithoutFormInput>
    deleteMany?: Enumerable<topicReviewScalarWhereInput>
  }

  export type subjectReviewUpdateManyWithoutFormsNestedInput = {
    create?: XOR<Enumerable<subjectReviewCreateWithoutFormsInput>, Enumerable<subjectReviewUncheckedCreateWithoutFormsInput>>
    connectOrCreate?: Enumerable<subjectReviewCreateOrConnectWithoutFormsInput>
    upsert?: Enumerable<subjectReviewUpsertWithWhereUniqueWithoutFormsInput>
    set?: Enumerable<subjectReviewWhereUniqueInput>
    disconnect?: Enumerable<subjectReviewWhereUniqueInput>
    delete?: Enumerable<subjectReviewWhereUniqueInput>
    connect?: Enumerable<subjectReviewWhereUniqueInput>
    update?: Enumerable<subjectReviewUpdateWithWhereUniqueWithoutFormsInput>
    updateMany?: Enumerable<subjectReviewUpdateManyWithWhereWithoutFormsInput>
    deleteMany?: Enumerable<subjectReviewScalarWhereInput>
  }

  export type reviewUncheckedUpdateManyWithoutFormNestedInput = {
    create?: XOR<Enumerable<reviewCreateWithoutFormInput>, Enumerable<reviewUncheckedCreateWithoutFormInput>>
    connectOrCreate?: Enumerable<reviewCreateOrConnectWithoutFormInput>
    upsert?: Enumerable<reviewUpsertWithWhereUniqueWithoutFormInput>
    createMany?: reviewCreateManyFormInputEnvelope
    set?: Enumerable<reviewWhereUniqueInput>
    disconnect?: Enumerable<reviewWhereUniqueInput>
    delete?: Enumerable<reviewWhereUniqueInput>
    connect?: Enumerable<reviewWhereUniqueInput>
    update?: Enumerable<reviewUpdateWithWhereUniqueWithoutFormInput>
    updateMany?: Enumerable<reviewUpdateManyWithWhereWithoutFormInput>
    deleteMany?: Enumerable<reviewScalarWhereInput>
  }

  export type topicReviewUncheckedUpdateManyWithoutFormNestedInput = {
    create?: XOR<Enumerable<topicReviewCreateWithoutFormInput>, Enumerable<topicReviewUncheckedCreateWithoutFormInput>>
    connectOrCreate?: Enumerable<topicReviewCreateOrConnectWithoutFormInput>
    upsert?: Enumerable<topicReviewUpsertWithWhereUniqueWithoutFormInput>
    createMany?: topicReviewCreateManyFormInputEnvelope
    set?: Enumerable<topicReviewWhereUniqueInput>
    disconnect?: Enumerable<topicReviewWhereUniqueInput>
    delete?: Enumerable<topicReviewWhereUniqueInput>
    connect?: Enumerable<topicReviewWhereUniqueInput>
    update?: Enumerable<topicReviewUpdateWithWhereUniqueWithoutFormInput>
    updateMany?: Enumerable<topicReviewUpdateManyWithWhereWithoutFormInput>
    deleteMany?: Enumerable<topicReviewScalarWhereInput>
  }

  export type subjectReviewUncheckedUpdateManyWithoutFormsNestedInput = {
    create?: XOR<Enumerable<subjectReviewCreateWithoutFormsInput>, Enumerable<subjectReviewUncheckedCreateWithoutFormsInput>>
    connectOrCreate?: Enumerable<subjectReviewCreateOrConnectWithoutFormsInput>
    upsert?: Enumerable<subjectReviewUpsertWithWhereUniqueWithoutFormsInput>
    set?: Enumerable<subjectReviewWhereUniqueInput>
    disconnect?: Enumerable<subjectReviewWhereUniqueInput>
    delete?: Enumerable<subjectReviewWhereUniqueInput>
    connect?: Enumerable<subjectReviewWhereUniqueInput>
    update?: Enumerable<subjectReviewUpdateWithWhereUniqueWithoutFormsInput>
    updateMany?: Enumerable<subjectReviewUpdateManyWithWhereWithoutFormsInput>
    deleteMany?: Enumerable<subjectReviewScalarWhereInput>
  }

  export type formReviewCreateNestedOneWithoutTopicInput = {
    create?: XOR<formReviewCreateWithoutTopicInput, formReviewUncheckedCreateWithoutTopicInput>
    connectOrCreate?: formReviewCreateOrConnectWithoutTopicInput
    connect?: formReviewWhereUniqueInput
  }

  export type subjectReviewCreateNestedOneWithoutTopicInput = {
    create?: XOR<subjectReviewCreateWithoutTopicInput, subjectReviewUncheckedCreateWithoutTopicInput>
    connectOrCreate?: subjectReviewCreateOrConnectWithoutTopicInput
    connect?: subjectReviewWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutTopicReviewInput = {
    create?: XOR<usersCreateWithoutTopicReviewInput, usersUncheckedCreateWithoutTopicReviewInput>
    connectOrCreate?: usersCreateOrConnectWithoutTopicReviewInput
    connect?: usersWhereUniqueInput
  }

  export type reviewCreateNestedManyWithoutTopicInput = {
    create?: XOR<Enumerable<reviewCreateWithoutTopicInput>, Enumerable<reviewUncheckedCreateWithoutTopicInput>>
    connectOrCreate?: Enumerable<reviewCreateOrConnectWithoutTopicInput>
    createMany?: reviewCreateManyTopicInputEnvelope
    connect?: Enumerable<reviewWhereUniqueInput>
  }

  export type reviewUncheckedCreateNestedManyWithoutTopicInput = {
    create?: XOR<Enumerable<reviewCreateWithoutTopicInput>, Enumerable<reviewUncheckedCreateWithoutTopicInput>>
    connectOrCreate?: Enumerable<reviewCreateOrConnectWithoutTopicInput>
    createMany?: reviewCreateManyTopicInputEnvelope
    connect?: Enumerable<reviewWhereUniqueInput>
  }

  export type formReviewUpdateOneRequiredWithoutTopicNestedInput = {
    create?: XOR<formReviewCreateWithoutTopicInput, formReviewUncheckedCreateWithoutTopicInput>
    connectOrCreate?: formReviewCreateOrConnectWithoutTopicInput
    upsert?: formReviewUpsertWithoutTopicInput
    connect?: formReviewWhereUniqueInput
    update?: XOR<formReviewUpdateWithoutTopicInput, formReviewUncheckedUpdateWithoutTopicInput>
  }

  export type subjectReviewUpdateOneRequiredWithoutTopicNestedInput = {
    create?: XOR<subjectReviewCreateWithoutTopicInput, subjectReviewUncheckedCreateWithoutTopicInput>
    connectOrCreate?: subjectReviewCreateOrConnectWithoutTopicInput
    upsert?: subjectReviewUpsertWithoutTopicInput
    connect?: subjectReviewWhereUniqueInput
    update?: XOR<subjectReviewUpdateWithoutTopicInput, subjectReviewUncheckedUpdateWithoutTopicInput>
  }

  export type usersUpdateOneRequiredWithoutTopicReviewNestedInput = {
    create?: XOR<usersCreateWithoutTopicReviewInput, usersUncheckedCreateWithoutTopicReviewInput>
    connectOrCreate?: usersCreateOrConnectWithoutTopicReviewInput
    upsert?: usersUpsertWithoutTopicReviewInput
    connect?: usersWhereUniqueInput
    update?: XOR<usersUpdateWithoutTopicReviewInput, usersUncheckedUpdateWithoutTopicReviewInput>
  }

  export type reviewUpdateManyWithoutTopicNestedInput = {
    create?: XOR<Enumerable<reviewCreateWithoutTopicInput>, Enumerable<reviewUncheckedCreateWithoutTopicInput>>
    connectOrCreate?: Enumerable<reviewCreateOrConnectWithoutTopicInput>
    upsert?: Enumerable<reviewUpsertWithWhereUniqueWithoutTopicInput>
    createMany?: reviewCreateManyTopicInputEnvelope
    set?: Enumerable<reviewWhereUniqueInput>
    disconnect?: Enumerable<reviewWhereUniqueInput>
    delete?: Enumerable<reviewWhereUniqueInput>
    connect?: Enumerable<reviewWhereUniqueInput>
    update?: Enumerable<reviewUpdateWithWhereUniqueWithoutTopicInput>
    updateMany?: Enumerable<reviewUpdateManyWithWhereWithoutTopicInput>
    deleteMany?: Enumerable<reviewScalarWhereInput>
  }

  export type reviewUncheckedUpdateManyWithoutTopicNestedInput = {
    create?: XOR<Enumerable<reviewCreateWithoutTopicInput>, Enumerable<reviewUncheckedCreateWithoutTopicInput>>
    connectOrCreate?: Enumerable<reviewCreateOrConnectWithoutTopicInput>
    upsert?: Enumerable<reviewUpsertWithWhereUniqueWithoutTopicInput>
    createMany?: reviewCreateManyTopicInputEnvelope
    set?: Enumerable<reviewWhereUniqueInput>
    disconnect?: Enumerable<reviewWhereUniqueInput>
    delete?: Enumerable<reviewWhereUniqueInput>
    connect?: Enumerable<reviewWhereUniqueInput>
    update?: Enumerable<reviewUpdateWithWhereUniqueWithoutTopicInput>
    updateMany?: Enumerable<reviewUpdateManyWithWhereWithoutTopicInput>
    deleteMany?: Enumerable<reviewScalarWhereInput>
  }

  export type formReviewCreateNestedOneWithoutReviewInput = {
    create?: XOR<formReviewCreateWithoutReviewInput, formReviewUncheckedCreateWithoutReviewInput>
    connectOrCreate?: formReviewCreateOrConnectWithoutReviewInput
    connect?: formReviewWhereUniqueInput
  }

  export type subjectReviewCreateNestedOneWithoutReviewInput = {
    create?: XOR<subjectReviewCreateWithoutReviewInput, subjectReviewUncheckedCreateWithoutReviewInput>
    connectOrCreate?: subjectReviewCreateOrConnectWithoutReviewInput
    connect?: subjectReviewWhereUniqueInput
  }

  export type topicReviewCreateNestedOneWithoutReviewInput = {
    create?: XOR<topicReviewCreateWithoutReviewInput, topicReviewUncheckedCreateWithoutReviewInput>
    connectOrCreate?: topicReviewCreateOrConnectWithoutReviewInput
    connect?: topicReviewWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutReviewInput = {
    create?: XOR<usersCreateWithoutReviewInput, usersUncheckedCreateWithoutReviewInput>
    connectOrCreate?: usersCreateOrConnectWithoutReviewInput
    connect?: usersWhereUniqueInput
  }

  export type questionCreateNestedManyWithoutReviewInput = {
    create?: XOR<Enumerable<questionCreateWithoutReviewInput>, Enumerable<questionUncheckedCreateWithoutReviewInput>>
    connectOrCreate?: Enumerable<questionCreateOrConnectWithoutReviewInput>
    createMany?: questionCreateManyReviewInputEnvelope
    connect?: Enumerable<questionWhereUniqueInput>
  }

  export type questionUncheckedCreateNestedManyWithoutReviewInput = {
    create?: XOR<Enumerable<questionCreateWithoutReviewInput>, Enumerable<questionUncheckedCreateWithoutReviewInput>>
    connectOrCreate?: Enumerable<questionCreateOrConnectWithoutReviewInput>
    createMany?: questionCreateManyReviewInputEnvelope
    connect?: Enumerable<questionWhereUniqueInput>
  }

  export type formReviewUpdateOneRequiredWithoutReviewNestedInput = {
    create?: XOR<formReviewCreateWithoutReviewInput, formReviewUncheckedCreateWithoutReviewInput>
    connectOrCreate?: formReviewCreateOrConnectWithoutReviewInput
    upsert?: formReviewUpsertWithoutReviewInput
    connect?: formReviewWhereUniqueInput
    update?: XOR<formReviewUpdateWithoutReviewInput, formReviewUncheckedUpdateWithoutReviewInput>
  }

  export type subjectReviewUpdateOneRequiredWithoutReviewNestedInput = {
    create?: XOR<subjectReviewCreateWithoutReviewInput, subjectReviewUncheckedCreateWithoutReviewInput>
    connectOrCreate?: subjectReviewCreateOrConnectWithoutReviewInput
    upsert?: subjectReviewUpsertWithoutReviewInput
    connect?: subjectReviewWhereUniqueInput
    update?: XOR<subjectReviewUpdateWithoutReviewInput, subjectReviewUncheckedUpdateWithoutReviewInput>
  }

  export type topicReviewUpdateOneRequiredWithoutReviewNestedInput = {
    create?: XOR<topicReviewCreateWithoutReviewInput, topicReviewUncheckedCreateWithoutReviewInput>
    connectOrCreate?: topicReviewCreateOrConnectWithoutReviewInput
    upsert?: topicReviewUpsertWithoutReviewInput
    connect?: topicReviewWhereUniqueInput
    update?: XOR<topicReviewUpdateWithoutReviewInput, topicReviewUncheckedUpdateWithoutReviewInput>
  }

  export type usersUpdateOneRequiredWithoutReviewNestedInput = {
    create?: XOR<usersCreateWithoutReviewInput, usersUncheckedCreateWithoutReviewInput>
    connectOrCreate?: usersCreateOrConnectWithoutReviewInput
    upsert?: usersUpsertWithoutReviewInput
    connect?: usersWhereUniqueInput
    update?: XOR<usersUpdateWithoutReviewInput, usersUncheckedUpdateWithoutReviewInput>
  }

  export type questionUpdateManyWithoutReviewNestedInput = {
    create?: XOR<Enumerable<questionCreateWithoutReviewInput>, Enumerable<questionUncheckedCreateWithoutReviewInput>>
    connectOrCreate?: Enumerable<questionCreateOrConnectWithoutReviewInput>
    upsert?: Enumerable<questionUpsertWithWhereUniqueWithoutReviewInput>
    createMany?: questionCreateManyReviewInputEnvelope
    set?: Enumerable<questionWhereUniqueInput>
    disconnect?: Enumerable<questionWhereUniqueInput>
    delete?: Enumerable<questionWhereUniqueInput>
    connect?: Enumerable<questionWhereUniqueInput>
    update?: Enumerable<questionUpdateWithWhereUniqueWithoutReviewInput>
    updateMany?: Enumerable<questionUpdateManyWithWhereWithoutReviewInput>
    deleteMany?: Enumerable<questionScalarWhereInput>
  }

  export type questionUncheckedUpdateManyWithoutReviewNestedInput = {
    create?: XOR<Enumerable<questionCreateWithoutReviewInput>, Enumerable<questionUncheckedCreateWithoutReviewInput>>
    connectOrCreate?: Enumerable<questionCreateOrConnectWithoutReviewInput>
    upsert?: Enumerable<questionUpsertWithWhereUniqueWithoutReviewInput>
    createMany?: questionCreateManyReviewInputEnvelope
    set?: Enumerable<questionWhereUniqueInput>
    disconnect?: Enumerable<questionWhereUniqueInput>
    delete?: Enumerable<questionWhereUniqueInput>
    connect?: Enumerable<questionWhereUniqueInput>
    update?: Enumerable<questionUpdateWithWhereUniqueWithoutReviewInput>
    updateMany?: Enumerable<questionUpdateManyWithWhereWithoutReviewInput>
    deleteMany?: Enumerable<questionScalarWhereInput>
  }

  export type questionFormatCreateNestedOneWithoutQuestionInput = {
    create?: XOR<questionFormatCreateWithoutQuestionInput, questionFormatUncheckedCreateWithoutQuestionInput>
    connectOrCreate?: questionFormatCreateOrConnectWithoutQuestionInput
    connect?: questionFormatWhereUniqueInput
  }

  export type reviewCreateNestedOneWithoutQuestionInput = {
    create?: XOR<reviewCreateWithoutQuestionInput, reviewUncheckedCreateWithoutQuestionInput>
    connectOrCreate?: reviewCreateOrConnectWithoutQuestionInput
    connect?: reviewWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutQuestionInput = {
    create?: XOR<usersCreateWithoutQuestionInput, usersUncheckedCreateWithoutQuestionInput>
    connectOrCreate?: usersCreateOrConnectWithoutQuestionInput
    connect?: usersWhereUniqueInput
  }

  export type answerCreateNestedManyWithoutQuestionInput = {
    create?: XOR<Enumerable<answerCreateWithoutQuestionInput>, Enumerable<answerUncheckedCreateWithoutQuestionInput>>
    connectOrCreate?: Enumerable<answerCreateOrConnectWithoutQuestionInput>
    createMany?: answerCreateManyQuestionInputEnvelope
    connect?: Enumerable<answerWhereUniqueInput>
  }

  export type answerUncheckedCreateNestedManyWithoutQuestionInput = {
    create?: XOR<Enumerable<answerCreateWithoutQuestionInput>, Enumerable<answerUncheckedCreateWithoutQuestionInput>>
    connectOrCreate?: Enumerable<answerCreateOrConnectWithoutQuestionInput>
    createMany?: answerCreateManyQuestionInputEnvelope
    connect?: Enumerable<answerWhereUniqueInput>
  }

  export type questionFormatUpdateOneRequiredWithoutQuestionNestedInput = {
    create?: XOR<questionFormatCreateWithoutQuestionInput, questionFormatUncheckedCreateWithoutQuestionInput>
    connectOrCreate?: questionFormatCreateOrConnectWithoutQuestionInput
    upsert?: questionFormatUpsertWithoutQuestionInput
    connect?: questionFormatWhereUniqueInput
    update?: XOR<questionFormatUpdateWithoutQuestionInput, questionFormatUncheckedUpdateWithoutQuestionInput>
  }

  export type reviewUpdateOneRequiredWithoutQuestionNestedInput = {
    create?: XOR<reviewCreateWithoutQuestionInput, reviewUncheckedCreateWithoutQuestionInput>
    connectOrCreate?: reviewCreateOrConnectWithoutQuestionInput
    upsert?: reviewUpsertWithoutQuestionInput
    connect?: reviewWhereUniqueInput
    update?: XOR<reviewUpdateWithoutQuestionInput, reviewUncheckedUpdateWithoutQuestionInput>
  }

  export type usersUpdateOneRequiredWithoutQuestionNestedInput = {
    create?: XOR<usersCreateWithoutQuestionInput, usersUncheckedCreateWithoutQuestionInput>
    connectOrCreate?: usersCreateOrConnectWithoutQuestionInput
    upsert?: usersUpsertWithoutQuestionInput
    connect?: usersWhereUniqueInput
    update?: XOR<usersUpdateWithoutQuestionInput, usersUncheckedUpdateWithoutQuestionInput>
  }

  export type answerUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<Enumerable<answerCreateWithoutQuestionInput>, Enumerable<answerUncheckedCreateWithoutQuestionInput>>
    connectOrCreate?: Enumerable<answerCreateOrConnectWithoutQuestionInput>
    upsert?: Enumerable<answerUpsertWithWhereUniqueWithoutQuestionInput>
    createMany?: answerCreateManyQuestionInputEnvelope
    set?: Enumerable<answerWhereUniqueInput>
    disconnect?: Enumerable<answerWhereUniqueInput>
    delete?: Enumerable<answerWhereUniqueInput>
    connect?: Enumerable<answerWhereUniqueInput>
    update?: Enumerable<answerUpdateWithWhereUniqueWithoutQuestionInput>
    updateMany?: Enumerable<answerUpdateManyWithWhereWithoutQuestionInput>
    deleteMany?: Enumerable<answerScalarWhereInput>
  }

  export type answerUncheckedUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<Enumerable<answerCreateWithoutQuestionInput>, Enumerable<answerUncheckedCreateWithoutQuestionInput>>
    connectOrCreate?: Enumerable<answerCreateOrConnectWithoutQuestionInput>
    upsert?: Enumerable<answerUpsertWithWhereUniqueWithoutQuestionInput>
    createMany?: answerCreateManyQuestionInputEnvelope
    set?: Enumerable<answerWhereUniqueInput>
    disconnect?: Enumerable<answerWhereUniqueInput>
    delete?: Enumerable<answerWhereUniqueInput>
    connect?: Enumerable<answerWhereUniqueInput>
    update?: Enumerable<answerUpdateWithWhereUniqueWithoutQuestionInput>
    updateMany?: Enumerable<answerUpdateManyWithWhereWithoutQuestionInput>
    deleteMany?: Enumerable<answerScalarWhereInput>
  }

  export type questionCreateNestedManyWithoutQuestionFormatInput = {
    create?: XOR<Enumerable<questionCreateWithoutQuestionFormatInput>, Enumerable<questionUncheckedCreateWithoutQuestionFormatInput>>
    connectOrCreate?: Enumerable<questionCreateOrConnectWithoutQuestionFormatInput>
    createMany?: questionCreateManyQuestionFormatInputEnvelope
    connect?: Enumerable<questionWhereUniqueInput>
  }

  export type questionUncheckedCreateNestedManyWithoutQuestionFormatInput = {
    create?: XOR<Enumerable<questionCreateWithoutQuestionFormatInput>, Enumerable<questionUncheckedCreateWithoutQuestionFormatInput>>
    connectOrCreate?: Enumerable<questionCreateOrConnectWithoutQuestionFormatInput>
    createMany?: questionCreateManyQuestionFormatInputEnvelope
    connect?: Enumerable<questionWhereUniqueInput>
  }

  export type questionUpdateManyWithoutQuestionFormatNestedInput = {
    create?: XOR<Enumerable<questionCreateWithoutQuestionFormatInput>, Enumerable<questionUncheckedCreateWithoutQuestionFormatInput>>
    connectOrCreate?: Enumerable<questionCreateOrConnectWithoutQuestionFormatInput>
    upsert?: Enumerable<questionUpsertWithWhereUniqueWithoutQuestionFormatInput>
    createMany?: questionCreateManyQuestionFormatInputEnvelope
    set?: Enumerable<questionWhereUniqueInput>
    disconnect?: Enumerable<questionWhereUniqueInput>
    delete?: Enumerable<questionWhereUniqueInput>
    connect?: Enumerable<questionWhereUniqueInput>
    update?: Enumerable<questionUpdateWithWhereUniqueWithoutQuestionFormatInput>
    updateMany?: Enumerable<questionUpdateManyWithWhereWithoutQuestionFormatInput>
    deleteMany?: Enumerable<questionScalarWhereInput>
  }

  export type questionUncheckedUpdateManyWithoutQuestionFormatNestedInput = {
    create?: XOR<Enumerable<questionCreateWithoutQuestionFormatInput>, Enumerable<questionUncheckedCreateWithoutQuestionFormatInput>>
    connectOrCreate?: Enumerable<questionCreateOrConnectWithoutQuestionFormatInput>
    upsert?: Enumerable<questionUpsertWithWhereUniqueWithoutQuestionFormatInput>
    createMany?: questionCreateManyQuestionFormatInputEnvelope
    set?: Enumerable<questionWhereUniqueInput>
    disconnect?: Enumerable<questionWhereUniqueInput>
    delete?: Enumerable<questionWhereUniqueInput>
    connect?: Enumerable<questionWhereUniqueInput>
    update?: Enumerable<questionUpdateWithWhereUniqueWithoutQuestionFormatInput>
    updateMany?: Enumerable<questionUpdateManyWithWhereWithoutQuestionFormatInput>
    deleteMany?: Enumerable<questionScalarWhereInput>
  }

  export type questionCreateNestedOneWithoutAnswerInput = {
    create?: XOR<questionCreateWithoutAnswerInput, questionUncheckedCreateWithoutAnswerInput>
    connectOrCreate?: questionCreateOrConnectWithoutAnswerInput
    connect?: questionWhereUniqueInput
  }

  export type questionUpdateOneRequiredWithoutAnswerNestedInput = {
    create?: XOR<questionCreateWithoutAnswerInput, questionUncheckedCreateWithoutAnswerInput>
    connectOrCreate?: questionCreateOrConnectWithoutAnswerInput
    upsert?: questionUpsertWithoutAnswerInput
    connect?: questionWhereUniqueInput
    update?: XOR<questionUpdateWithoutAnswerInput, questionUncheckedUpdateWithoutAnswerInput>
  }

  export type usersCreateNestedOneWithoutSubjectExamsInput = {
    create?: XOR<usersCreateWithoutSubjectExamsInput, usersUncheckedCreateWithoutSubjectExamsInput>
    connectOrCreate?: usersCreateOrConnectWithoutSubjectExamsInput
    connect?: usersWhereUniqueInput
  }

  export type examTypeCreateNestedManyWithoutSubjectExamsInput = {
    create?: XOR<Enumerable<examTypeCreateWithoutSubjectExamsInput>, Enumerable<examTypeUncheckedCreateWithoutSubjectExamsInput>>
    connectOrCreate?: Enumerable<examTypeCreateOrConnectWithoutSubjectExamsInput>
    createMany?: examTypeCreateManySubjectExamsInputEnvelope
    connect?: Enumerable<examTypeWhereUniqueInput>
  }

  export type formExamsCreateNestedManyWithoutSubjectsInput = {
    create?: XOR<Enumerable<formExamsCreateWithoutSubjectsInput>, Enumerable<formExamsUncheckedCreateWithoutSubjectsInput>>
    connectOrCreate?: Enumerable<formExamsCreateOrConnectWithoutSubjectsInput>
    connect?: Enumerable<formExamsWhereUniqueInput>
  }

  export type examTypeUncheckedCreateNestedManyWithoutSubjectExamsInput = {
    create?: XOR<Enumerable<examTypeCreateWithoutSubjectExamsInput>, Enumerable<examTypeUncheckedCreateWithoutSubjectExamsInput>>
    connectOrCreate?: Enumerable<examTypeCreateOrConnectWithoutSubjectExamsInput>
    createMany?: examTypeCreateManySubjectExamsInputEnvelope
    connect?: Enumerable<examTypeWhereUniqueInput>
  }

  export type formExamsUncheckedCreateNestedManyWithoutSubjectsInput = {
    create?: XOR<Enumerable<formExamsCreateWithoutSubjectsInput>, Enumerable<formExamsUncheckedCreateWithoutSubjectsInput>>
    connectOrCreate?: Enumerable<formExamsCreateOrConnectWithoutSubjectsInput>
    connect?: Enumerable<formExamsWhereUniqueInput>
  }

  export type usersUpdateOneRequiredWithoutSubjectExamsNestedInput = {
    create?: XOR<usersCreateWithoutSubjectExamsInput, usersUncheckedCreateWithoutSubjectExamsInput>
    connectOrCreate?: usersCreateOrConnectWithoutSubjectExamsInput
    upsert?: usersUpsertWithoutSubjectExamsInput
    connect?: usersWhereUniqueInput
    update?: XOR<usersUpdateWithoutSubjectExamsInput, usersUncheckedUpdateWithoutSubjectExamsInput>
  }

  export type examTypeUpdateManyWithoutSubjectExamsNestedInput = {
    create?: XOR<Enumerable<examTypeCreateWithoutSubjectExamsInput>, Enumerable<examTypeUncheckedCreateWithoutSubjectExamsInput>>
    connectOrCreate?: Enumerable<examTypeCreateOrConnectWithoutSubjectExamsInput>
    upsert?: Enumerable<examTypeUpsertWithWhereUniqueWithoutSubjectExamsInput>
    createMany?: examTypeCreateManySubjectExamsInputEnvelope
    set?: Enumerable<examTypeWhereUniqueInput>
    disconnect?: Enumerable<examTypeWhereUniqueInput>
    delete?: Enumerable<examTypeWhereUniqueInput>
    connect?: Enumerable<examTypeWhereUniqueInput>
    update?: Enumerable<examTypeUpdateWithWhereUniqueWithoutSubjectExamsInput>
    updateMany?: Enumerable<examTypeUpdateManyWithWhereWithoutSubjectExamsInput>
    deleteMany?: Enumerable<examTypeScalarWhereInput>
  }

  export type formExamsUpdateManyWithoutSubjectsNestedInput = {
    create?: XOR<Enumerable<formExamsCreateWithoutSubjectsInput>, Enumerable<formExamsUncheckedCreateWithoutSubjectsInput>>
    connectOrCreate?: Enumerable<formExamsCreateOrConnectWithoutSubjectsInput>
    upsert?: Enumerable<formExamsUpsertWithWhereUniqueWithoutSubjectsInput>
    set?: Enumerable<formExamsWhereUniqueInput>
    disconnect?: Enumerable<formExamsWhereUniqueInput>
    delete?: Enumerable<formExamsWhereUniqueInput>
    connect?: Enumerable<formExamsWhereUniqueInput>
    update?: Enumerable<formExamsUpdateWithWhereUniqueWithoutSubjectsInput>
    updateMany?: Enumerable<formExamsUpdateManyWithWhereWithoutSubjectsInput>
    deleteMany?: Enumerable<formExamsScalarWhereInput>
  }

  export type examTypeUncheckedUpdateManyWithoutSubjectExamsNestedInput = {
    create?: XOR<Enumerable<examTypeCreateWithoutSubjectExamsInput>, Enumerable<examTypeUncheckedCreateWithoutSubjectExamsInput>>
    connectOrCreate?: Enumerable<examTypeCreateOrConnectWithoutSubjectExamsInput>
    upsert?: Enumerable<examTypeUpsertWithWhereUniqueWithoutSubjectExamsInput>
    createMany?: examTypeCreateManySubjectExamsInputEnvelope
    set?: Enumerable<examTypeWhereUniqueInput>
    disconnect?: Enumerable<examTypeWhereUniqueInput>
    delete?: Enumerable<examTypeWhereUniqueInput>
    connect?: Enumerable<examTypeWhereUniqueInput>
    update?: Enumerable<examTypeUpdateWithWhereUniqueWithoutSubjectExamsInput>
    updateMany?: Enumerable<examTypeUpdateManyWithWhereWithoutSubjectExamsInput>
    deleteMany?: Enumerable<examTypeScalarWhereInput>
  }

  export type formExamsUncheckedUpdateManyWithoutSubjectsNestedInput = {
    create?: XOR<Enumerable<formExamsCreateWithoutSubjectsInput>, Enumerable<formExamsUncheckedCreateWithoutSubjectsInput>>
    connectOrCreate?: Enumerable<formExamsCreateOrConnectWithoutSubjectsInput>
    upsert?: Enumerable<formExamsUpsertWithWhereUniqueWithoutSubjectsInput>
    set?: Enumerable<formExamsWhereUniqueInput>
    disconnect?: Enumerable<formExamsWhereUniqueInput>
    delete?: Enumerable<formExamsWhereUniqueInput>
    connect?: Enumerable<formExamsWhereUniqueInput>
    update?: Enumerable<formExamsUpdateWithWhereUniqueWithoutSubjectsInput>
    updateMany?: Enumerable<formExamsUpdateManyWithWhereWithoutSubjectsInput>
    deleteMany?: Enumerable<formExamsScalarWhereInput>
  }

  export type usersCreateNestedOneWithoutFormExamsInput = {
    create?: XOR<usersCreateWithoutFormExamsInput, usersUncheckedCreateWithoutFormExamsInput>
    connectOrCreate?: usersCreateOrConnectWithoutFormExamsInput
    connect?: usersWhereUniqueInput
  }

  export type examTypeCreateNestedManyWithoutFormExamsInput = {
    create?: XOR<Enumerable<examTypeCreateWithoutFormExamsInput>, Enumerable<examTypeUncheckedCreateWithoutFormExamsInput>>
    connectOrCreate?: Enumerable<examTypeCreateOrConnectWithoutFormExamsInput>
    createMany?: examTypeCreateManyFormExamsInputEnvelope
    connect?: Enumerable<examTypeWhereUniqueInput>
  }

  export type subjectExamsCreateNestedManyWithoutFormsInput = {
    create?: XOR<Enumerable<subjectExamsCreateWithoutFormsInput>, Enumerable<subjectExamsUncheckedCreateWithoutFormsInput>>
    connectOrCreate?: Enumerable<subjectExamsCreateOrConnectWithoutFormsInput>
    connect?: Enumerable<subjectExamsWhereUniqueInput>
  }

  export type examTypeUncheckedCreateNestedManyWithoutFormExamsInput = {
    create?: XOR<Enumerable<examTypeCreateWithoutFormExamsInput>, Enumerable<examTypeUncheckedCreateWithoutFormExamsInput>>
    connectOrCreate?: Enumerable<examTypeCreateOrConnectWithoutFormExamsInput>
    createMany?: examTypeCreateManyFormExamsInputEnvelope
    connect?: Enumerable<examTypeWhereUniqueInput>
  }

  export type subjectExamsUncheckedCreateNestedManyWithoutFormsInput = {
    create?: XOR<Enumerable<subjectExamsCreateWithoutFormsInput>, Enumerable<subjectExamsUncheckedCreateWithoutFormsInput>>
    connectOrCreate?: Enumerable<subjectExamsCreateOrConnectWithoutFormsInput>
    connect?: Enumerable<subjectExamsWhereUniqueInput>
  }

  export type usersUpdateOneRequiredWithoutFormExamsNestedInput = {
    create?: XOR<usersCreateWithoutFormExamsInput, usersUncheckedCreateWithoutFormExamsInput>
    connectOrCreate?: usersCreateOrConnectWithoutFormExamsInput
    upsert?: usersUpsertWithoutFormExamsInput
    connect?: usersWhereUniqueInput
    update?: XOR<usersUpdateWithoutFormExamsInput, usersUncheckedUpdateWithoutFormExamsInput>
  }

  export type examTypeUpdateManyWithoutFormExamsNestedInput = {
    create?: XOR<Enumerable<examTypeCreateWithoutFormExamsInput>, Enumerable<examTypeUncheckedCreateWithoutFormExamsInput>>
    connectOrCreate?: Enumerable<examTypeCreateOrConnectWithoutFormExamsInput>
    upsert?: Enumerable<examTypeUpsertWithWhereUniqueWithoutFormExamsInput>
    createMany?: examTypeCreateManyFormExamsInputEnvelope
    set?: Enumerable<examTypeWhereUniqueInput>
    disconnect?: Enumerable<examTypeWhereUniqueInput>
    delete?: Enumerable<examTypeWhereUniqueInput>
    connect?: Enumerable<examTypeWhereUniqueInput>
    update?: Enumerable<examTypeUpdateWithWhereUniqueWithoutFormExamsInput>
    updateMany?: Enumerable<examTypeUpdateManyWithWhereWithoutFormExamsInput>
    deleteMany?: Enumerable<examTypeScalarWhereInput>
  }

  export type subjectExamsUpdateManyWithoutFormsNestedInput = {
    create?: XOR<Enumerable<subjectExamsCreateWithoutFormsInput>, Enumerable<subjectExamsUncheckedCreateWithoutFormsInput>>
    connectOrCreate?: Enumerable<subjectExamsCreateOrConnectWithoutFormsInput>
    upsert?: Enumerable<subjectExamsUpsertWithWhereUniqueWithoutFormsInput>
    set?: Enumerable<subjectExamsWhereUniqueInput>
    disconnect?: Enumerable<subjectExamsWhereUniqueInput>
    delete?: Enumerable<subjectExamsWhereUniqueInput>
    connect?: Enumerable<subjectExamsWhereUniqueInput>
    update?: Enumerable<subjectExamsUpdateWithWhereUniqueWithoutFormsInput>
    updateMany?: Enumerable<subjectExamsUpdateManyWithWhereWithoutFormsInput>
    deleteMany?: Enumerable<subjectExamsScalarWhereInput>
  }

  export type examTypeUncheckedUpdateManyWithoutFormExamsNestedInput = {
    create?: XOR<Enumerable<examTypeCreateWithoutFormExamsInput>, Enumerable<examTypeUncheckedCreateWithoutFormExamsInput>>
    connectOrCreate?: Enumerable<examTypeCreateOrConnectWithoutFormExamsInput>
    upsert?: Enumerable<examTypeUpsertWithWhereUniqueWithoutFormExamsInput>
    createMany?: examTypeCreateManyFormExamsInputEnvelope
    set?: Enumerable<examTypeWhereUniqueInput>
    disconnect?: Enumerable<examTypeWhereUniqueInput>
    delete?: Enumerable<examTypeWhereUniqueInput>
    connect?: Enumerable<examTypeWhereUniqueInput>
    update?: Enumerable<examTypeUpdateWithWhereUniqueWithoutFormExamsInput>
    updateMany?: Enumerable<examTypeUpdateManyWithWhereWithoutFormExamsInput>
    deleteMany?: Enumerable<examTypeScalarWhereInput>
  }

  export type subjectExamsUncheckedUpdateManyWithoutFormsNestedInput = {
    create?: XOR<Enumerable<subjectExamsCreateWithoutFormsInput>, Enumerable<subjectExamsUncheckedCreateWithoutFormsInput>>
    connectOrCreate?: Enumerable<subjectExamsCreateOrConnectWithoutFormsInput>
    upsert?: Enumerable<subjectExamsUpsertWithWhereUniqueWithoutFormsInput>
    set?: Enumerable<subjectExamsWhereUniqueInput>
    disconnect?: Enumerable<subjectExamsWhereUniqueInput>
    delete?: Enumerable<subjectExamsWhereUniqueInput>
    connect?: Enumerable<subjectExamsWhereUniqueInput>
    update?: Enumerable<subjectExamsUpdateWithWhereUniqueWithoutFormsInput>
    updateMany?: Enumerable<subjectExamsUpdateManyWithWhereWithoutFormsInput>
    deleteMany?: Enumerable<subjectExamsScalarWhereInput>
  }

  export type formExamsCreateNestedOneWithoutExamTypeInput = {
    create?: XOR<formExamsCreateWithoutExamTypeInput, formExamsUncheckedCreateWithoutExamTypeInput>
    connectOrCreate?: formExamsCreateOrConnectWithoutExamTypeInput
    connect?: formExamsWhereUniqueInput
  }

  export type subjectExamsCreateNestedOneWithoutExamTypeInput = {
    create?: XOR<subjectExamsCreateWithoutExamTypeInput, subjectExamsUncheckedCreateWithoutExamTypeInput>
    connectOrCreate?: subjectExamsCreateOrConnectWithoutExamTypeInput
    connect?: subjectExamsWhereUniqueInput
  }

  export type examCreateNestedManyWithoutExamTypeInput = {
    create?: XOR<Enumerable<examCreateWithoutExamTypeInput>, Enumerable<examUncheckedCreateWithoutExamTypeInput>>
    connectOrCreate?: Enumerable<examCreateOrConnectWithoutExamTypeInput>
    createMany?: examCreateManyExamTypeInputEnvelope
    connect?: Enumerable<examWhereUniqueInput>
  }

  export type examUncheckedCreateNestedManyWithoutExamTypeInput = {
    create?: XOR<Enumerable<examCreateWithoutExamTypeInput>, Enumerable<examUncheckedCreateWithoutExamTypeInput>>
    connectOrCreate?: Enumerable<examCreateOrConnectWithoutExamTypeInput>
    createMany?: examCreateManyExamTypeInputEnvelope
    connect?: Enumerable<examWhereUniqueInput>
  }

  export type formExamsUpdateOneRequiredWithoutExamTypeNestedInput = {
    create?: XOR<formExamsCreateWithoutExamTypeInput, formExamsUncheckedCreateWithoutExamTypeInput>
    connectOrCreate?: formExamsCreateOrConnectWithoutExamTypeInput
    upsert?: formExamsUpsertWithoutExamTypeInput
    connect?: formExamsWhereUniqueInput
    update?: XOR<formExamsUpdateWithoutExamTypeInput, formExamsUncheckedUpdateWithoutExamTypeInput>
  }

  export type subjectExamsUpdateOneRequiredWithoutExamTypeNestedInput = {
    create?: XOR<subjectExamsCreateWithoutExamTypeInput, subjectExamsUncheckedCreateWithoutExamTypeInput>
    connectOrCreate?: subjectExamsCreateOrConnectWithoutExamTypeInput
    upsert?: subjectExamsUpsertWithoutExamTypeInput
    connect?: subjectExamsWhereUniqueInput
    update?: XOR<subjectExamsUpdateWithoutExamTypeInput, subjectExamsUncheckedUpdateWithoutExamTypeInput>
  }

  export type examUpdateManyWithoutExamTypeNestedInput = {
    create?: XOR<Enumerable<examCreateWithoutExamTypeInput>, Enumerable<examUncheckedCreateWithoutExamTypeInput>>
    connectOrCreate?: Enumerable<examCreateOrConnectWithoutExamTypeInput>
    upsert?: Enumerable<examUpsertWithWhereUniqueWithoutExamTypeInput>
    createMany?: examCreateManyExamTypeInputEnvelope
    set?: Enumerable<examWhereUniqueInput>
    disconnect?: Enumerable<examWhereUniqueInput>
    delete?: Enumerable<examWhereUniqueInput>
    connect?: Enumerable<examWhereUniqueInput>
    update?: Enumerable<examUpdateWithWhereUniqueWithoutExamTypeInput>
    updateMany?: Enumerable<examUpdateManyWithWhereWithoutExamTypeInput>
    deleteMany?: Enumerable<examScalarWhereInput>
  }

  export type examUncheckedUpdateManyWithoutExamTypeNestedInput = {
    create?: XOR<Enumerable<examCreateWithoutExamTypeInput>, Enumerable<examUncheckedCreateWithoutExamTypeInput>>
    connectOrCreate?: Enumerable<examCreateOrConnectWithoutExamTypeInput>
    upsert?: Enumerable<examUpsertWithWhereUniqueWithoutExamTypeInput>
    createMany?: examCreateManyExamTypeInputEnvelope
    set?: Enumerable<examWhereUniqueInput>
    disconnect?: Enumerable<examWhereUniqueInput>
    delete?: Enumerable<examWhereUniqueInput>
    connect?: Enumerable<examWhereUniqueInput>
    update?: Enumerable<examUpdateWithWhereUniqueWithoutExamTypeInput>
    updateMany?: Enumerable<examUpdateManyWithWhereWithoutExamTypeInput>
    deleteMany?: Enumerable<examScalarWhereInput>
  }

  export type examTypeCreateNestedOneWithoutExamInput = {
    create?: XOR<examTypeCreateWithoutExamInput, examTypeUncheckedCreateWithoutExamInput>
    connectOrCreate?: examTypeCreateOrConnectWithoutExamInput
    connect?: examTypeWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutExamInput = {
    create?: XOR<usersCreateWithoutExamInput, usersUncheckedCreateWithoutExamInput>
    connectOrCreate?: usersCreateOrConnectWithoutExamInput
    connect?: usersWhereUniqueInput
  }

  export type examDownloadableCreateNestedManyWithoutExamInput = {
    create?: XOR<Enumerable<examDownloadableCreateWithoutExamInput>, Enumerable<examDownloadableUncheckedCreateWithoutExamInput>>
    connectOrCreate?: Enumerable<examDownloadableCreateOrConnectWithoutExamInput>
    createMany?: examDownloadableCreateManyExamInputEnvelope
    connect?: Enumerable<examDownloadableWhereUniqueInput>
  }

  export type examDownloadableUncheckedCreateNestedManyWithoutExamInput = {
    create?: XOR<Enumerable<examDownloadableCreateWithoutExamInput>, Enumerable<examDownloadableUncheckedCreateWithoutExamInput>>
    connectOrCreate?: Enumerable<examDownloadableCreateOrConnectWithoutExamInput>
    createMany?: examDownloadableCreateManyExamInputEnvelope
    connect?: Enumerable<examDownloadableWhereUniqueInput>
  }

  export type examTypeUpdateOneRequiredWithoutExamNestedInput = {
    create?: XOR<examTypeCreateWithoutExamInput, examTypeUncheckedCreateWithoutExamInput>
    connectOrCreate?: examTypeCreateOrConnectWithoutExamInput
    upsert?: examTypeUpsertWithoutExamInput
    connect?: examTypeWhereUniqueInput
    update?: XOR<examTypeUpdateWithoutExamInput, examTypeUncheckedUpdateWithoutExamInput>
  }

  export type usersUpdateOneRequiredWithoutExamNestedInput = {
    create?: XOR<usersCreateWithoutExamInput, usersUncheckedCreateWithoutExamInput>
    connectOrCreate?: usersCreateOrConnectWithoutExamInput
    upsert?: usersUpsertWithoutExamInput
    connect?: usersWhereUniqueInput
    update?: XOR<usersUpdateWithoutExamInput, usersUncheckedUpdateWithoutExamInput>
  }

  export type examDownloadableUpdateManyWithoutExamNestedInput = {
    create?: XOR<Enumerable<examDownloadableCreateWithoutExamInput>, Enumerable<examDownloadableUncheckedCreateWithoutExamInput>>
    connectOrCreate?: Enumerable<examDownloadableCreateOrConnectWithoutExamInput>
    upsert?: Enumerable<examDownloadableUpsertWithWhereUniqueWithoutExamInput>
    createMany?: examDownloadableCreateManyExamInputEnvelope
    set?: Enumerable<examDownloadableWhereUniqueInput>
    disconnect?: Enumerable<examDownloadableWhereUniqueInput>
    delete?: Enumerable<examDownloadableWhereUniqueInput>
    connect?: Enumerable<examDownloadableWhereUniqueInput>
    update?: Enumerable<examDownloadableUpdateWithWhereUniqueWithoutExamInput>
    updateMany?: Enumerable<examDownloadableUpdateManyWithWhereWithoutExamInput>
    deleteMany?: Enumerable<examDownloadableScalarWhereInput>
  }

  export type examDownloadableUncheckedUpdateManyWithoutExamNestedInput = {
    create?: XOR<Enumerable<examDownloadableCreateWithoutExamInput>, Enumerable<examDownloadableUncheckedCreateWithoutExamInput>>
    connectOrCreate?: Enumerable<examDownloadableCreateOrConnectWithoutExamInput>
    upsert?: Enumerable<examDownloadableUpsertWithWhereUniqueWithoutExamInput>
    createMany?: examDownloadableCreateManyExamInputEnvelope
    set?: Enumerable<examDownloadableWhereUniqueInput>
    disconnect?: Enumerable<examDownloadableWhereUniqueInput>
    delete?: Enumerable<examDownloadableWhereUniqueInput>
    connect?: Enumerable<examDownloadableWhereUniqueInput>
    update?: Enumerable<examDownloadableUpdateWithWhereUniqueWithoutExamInput>
    updateMany?: Enumerable<examDownloadableUpdateManyWithWhereWithoutExamInput>
    deleteMany?: Enumerable<examDownloadableScalarWhereInput>
  }

  export type examCreateNestedOneWithoutExamDownloadableInput = {
    create?: XOR<examCreateWithoutExamDownloadableInput, examUncheckedCreateWithoutExamDownloadableInput>
    connectOrCreate?: examCreateOrConnectWithoutExamDownloadableInput
    connect?: examWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutExamDownloadableInput = {
    create?: XOR<usersCreateWithoutExamDownloadableInput, usersUncheckedCreateWithoutExamDownloadableInput>
    connectOrCreate?: usersCreateOrConnectWithoutExamDownloadableInput
    connect?: usersWhereUniqueInput
  }

  export type examUpdateOneRequiredWithoutExamDownloadableNestedInput = {
    create?: XOR<examCreateWithoutExamDownloadableInput, examUncheckedCreateWithoutExamDownloadableInput>
    connectOrCreate?: examCreateOrConnectWithoutExamDownloadableInput
    upsert?: examUpsertWithoutExamDownloadableInput
    connect?: examWhereUniqueInput
    update?: XOR<examUpdateWithoutExamDownloadableInput, examUncheckedUpdateWithoutExamDownloadableInput>
  }

  export type usersUpdateOneRequiredWithoutExamDownloadableNestedInput = {
    create?: XOR<usersCreateWithoutExamDownloadableInput, usersUncheckedCreateWithoutExamDownloadableInput>
    connectOrCreate?: usersCreateOrConnectWithoutExamDownloadableInput
    upsert?: usersUpsertWithoutExamDownloadableInput
    connect?: usersWhereUniqueInput
    update?: XOR<usersUpdateWithoutExamDownloadableInput, usersUncheckedUpdateWithoutExamDownloadableInput>
  }

  export type usersCreateNestedOneWithoutSubjectReferenceInput = {
    create?: XOR<usersCreateWithoutSubjectReferenceInput, usersUncheckedCreateWithoutSubjectReferenceInput>
    connectOrCreate?: usersCreateOrConnectWithoutSubjectReferenceInput
    connect?: usersWhereUniqueInput
  }

  export type referenceCreateNestedManyWithoutSubjectReferenceInput = {
    create?: XOR<Enumerable<referenceCreateWithoutSubjectReferenceInput>, Enumerable<referenceUncheckedCreateWithoutSubjectReferenceInput>>
    connectOrCreate?: Enumerable<referenceCreateOrConnectWithoutSubjectReferenceInput>
    createMany?: referenceCreateManySubjectReferenceInputEnvelope
    connect?: Enumerable<referenceWhereUniqueInput>
  }

  export type formReferenceCreateNestedManyWithoutSubjectsInput = {
    create?: XOR<Enumerable<formReferenceCreateWithoutSubjectsInput>, Enumerable<formReferenceUncheckedCreateWithoutSubjectsInput>>
    connectOrCreate?: Enumerable<formReferenceCreateOrConnectWithoutSubjectsInput>
    connect?: Enumerable<formReferenceWhereUniqueInput>
  }

  export type referenceUncheckedCreateNestedManyWithoutSubjectReferenceInput = {
    create?: XOR<Enumerable<referenceCreateWithoutSubjectReferenceInput>, Enumerable<referenceUncheckedCreateWithoutSubjectReferenceInput>>
    connectOrCreate?: Enumerable<referenceCreateOrConnectWithoutSubjectReferenceInput>
    createMany?: referenceCreateManySubjectReferenceInputEnvelope
    connect?: Enumerable<referenceWhereUniqueInput>
  }

  export type formReferenceUncheckedCreateNestedManyWithoutSubjectsInput = {
    create?: XOR<Enumerable<formReferenceCreateWithoutSubjectsInput>, Enumerable<formReferenceUncheckedCreateWithoutSubjectsInput>>
    connectOrCreate?: Enumerable<formReferenceCreateOrConnectWithoutSubjectsInput>
    connect?: Enumerable<formReferenceWhereUniqueInput>
  }

  export type usersUpdateOneRequiredWithoutSubjectReferenceNestedInput = {
    create?: XOR<usersCreateWithoutSubjectReferenceInput, usersUncheckedCreateWithoutSubjectReferenceInput>
    connectOrCreate?: usersCreateOrConnectWithoutSubjectReferenceInput
    upsert?: usersUpsertWithoutSubjectReferenceInput
    connect?: usersWhereUniqueInput
    update?: XOR<usersUpdateWithoutSubjectReferenceInput, usersUncheckedUpdateWithoutSubjectReferenceInput>
  }

  export type referenceUpdateManyWithoutSubjectReferenceNestedInput = {
    create?: XOR<Enumerable<referenceCreateWithoutSubjectReferenceInput>, Enumerable<referenceUncheckedCreateWithoutSubjectReferenceInput>>
    connectOrCreate?: Enumerable<referenceCreateOrConnectWithoutSubjectReferenceInput>
    upsert?: Enumerable<referenceUpsertWithWhereUniqueWithoutSubjectReferenceInput>
    createMany?: referenceCreateManySubjectReferenceInputEnvelope
    set?: Enumerable<referenceWhereUniqueInput>
    disconnect?: Enumerable<referenceWhereUniqueInput>
    delete?: Enumerable<referenceWhereUniqueInput>
    connect?: Enumerable<referenceWhereUniqueInput>
    update?: Enumerable<referenceUpdateWithWhereUniqueWithoutSubjectReferenceInput>
    updateMany?: Enumerable<referenceUpdateManyWithWhereWithoutSubjectReferenceInput>
    deleteMany?: Enumerable<referenceScalarWhereInput>
  }

  export type formReferenceUpdateManyWithoutSubjectsNestedInput = {
    create?: XOR<Enumerable<formReferenceCreateWithoutSubjectsInput>, Enumerable<formReferenceUncheckedCreateWithoutSubjectsInput>>
    connectOrCreate?: Enumerable<formReferenceCreateOrConnectWithoutSubjectsInput>
    upsert?: Enumerable<formReferenceUpsertWithWhereUniqueWithoutSubjectsInput>
    set?: Enumerable<formReferenceWhereUniqueInput>
    disconnect?: Enumerable<formReferenceWhereUniqueInput>
    delete?: Enumerable<formReferenceWhereUniqueInput>
    connect?: Enumerable<formReferenceWhereUniqueInput>
    update?: Enumerable<formReferenceUpdateWithWhereUniqueWithoutSubjectsInput>
    updateMany?: Enumerable<formReferenceUpdateManyWithWhereWithoutSubjectsInput>
    deleteMany?: Enumerable<formReferenceScalarWhereInput>
  }

  export type referenceUncheckedUpdateManyWithoutSubjectReferenceNestedInput = {
    create?: XOR<Enumerable<referenceCreateWithoutSubjectReferenceInput>, Enumerable<referenceUncheckedCreateWithoutSubjectReferenceInput>>
    connectOrCreate?: Enumerable<referenceCreateOrConnectWithoutSubjectReferenceInput>
    upsert?: Enumerable<referenceUpsertWithWhereUniqueWithoutSubjectReferenceInput>
    createMany?: referenceCreateManySubjectReferenceInputEnvelope
    set?: Enumerable<referenceWhereUniqueInput>
    disconnect?: Enumerable<referenceWhereUniqueInput>
    delete?: Enumerable<referenceWhereUniqueInput>
    connect?: Enumerable<referenceWhereUniqueInput>
    update?: Enumerable<referenceUpdateWithWhereUniqueWithoutSubjectReferenceInput>
    updateMany?: Enumerable<referenceUpdateManyWithWhereWithoutSubjectReferenceInput>
    deleteMany?: Enumerable<referenceScalarWhereInput>
  }

  export type formReferenceUncheckedUpdateManyWithoutSubjectsNestedInput = {
    create?: XOR<Enumerable<formReferenceCreateWithoutSubjectsInput>, Enumerable<formReferenceUncheckedCreateWithoutSubjectsInput>>
    connectOrCreate?: Enumerable<formReferenceCreateOrConnectWithoutSubjectsInput>
    upsert?: Enumerable<formReferenceUpsertWithWhereUniqueWithoutSubjectsInput>
    set?: Enumerable<formReferenceWhereUniqueInput>
    disconnect?: Enumerable<formReferenceWhereUniqueInput>
    delete?: Enumerable<formReferenceWhereUniqueInput>
    connect?: Enumerable<formReferenceWhereUniqueInput>
    update?: Enumerable<formReferenceUpdateWithWhereUniqueWithoutSubjectsInput>
    updateMany?: Enumerable<formReferenceUpdateManyWithWhereWithoutSubjectsInput>
    deleteMany?: Enumerable<formReferenceScalarWhereInput>
  }

  export type usersCreateNestedOneWithoutFormReferenceInput = {
    create?: XOR<usersCreateWithoutFormReferenceInput, usersUncheckedCreateWithoutFormReferenceInput>
    connectOrCreate?: usersCreateOrConnectWithoutFormReferenceInput
    connect?: usersWhereUniqueInput
  }

  export type referenceCreateNestedManyWithoutFormReferenceInput = {
    create?: XOR<Enumerable<referenceCreateWithoutFormReferenceInput>, Enumerable<referenceUncheckedCreateWithoutFormReferenceInput>>
    connectOrCreate?: Enumerable<referenceCreateOrConnectWithoutFormReferenceInput>
    connect?: Enumerable<referenceWhereUniqueInput>
  }

  export type subjectReferenceCreateNestedManyWithoutFormsInput = {
    create?: XOR<Enumerable<subjectReferenceCreateWithoutFormsInput>, Enumerable<subjectReferenceUncheckedCreateWithoutFormsInput>>
    connectOrCreate?: Enumerable<subjectReferenceCreateOrConnectWithoutFormsInput>
    connect?: Enumerable<subjectReferenceWhereUniqueInput>
  }

  export type referenceUncheckedCreateNestedManyWithoutFormReferenceInput = {
    create?: XOR<Enumerable<referenceCreateWithoutFormReferenceInput>, Enumerable<referenceUncheckedCreateWithoutFormReferenceInput>>
    connectOrCreate?: Enumerable<referenceCreateOrConnectWithoutFormReferenceInput>
    connect?: Enumerable<referenceWhereUniqueInput>
  }

  export type subjectReferenceUncheckedCreateNestedManyWithoutFormsInput = {
    create?: XOR<Enumerable<subjectReferenceCreateWithoutFormsInput>, Enumerable<subjectReferenceUncheckedCreateWithoutFormsInput>>
    connectOrCreate?: Enumerable<subjectReferenceCreateOrConnectWithoutFormsInput>
    connect?: Enumerable<subjectReferenceWhereUniqueInput>
  }

  export type usersUpdateOneRequiredWithoutFormReferenceNestedInput = {
    create?: XOR<usersCreateWithoutFormReferenceInput, usersUncheckedCreateWithoutFormReferenceInput>
    connectOrCreate?: usersCreateOrConnectWithoutFormReferenceInput
    upsert?: usersUpsertWithoutFormReferenceInput
    connect?: usersWhereUniqueInput
    update?: XOR<usersUpdateWithoutFormReferenceInput, usersUncheckedUpdateWithoutFormReferenceInput>
  }

  export type referenceUpdateManyWithoutFormReferenceNestedInput = {
    create?: XOR<Enumerable<referenceCreateWithoutFormReferenceInput>, Enumerable<referenceUncheckedCreateWithoutFormReferenceInput>>
    connectOrCreate?: Enumerable<referenceCreateOrConnectWithoutFormReferenceInput>
    upsert?: Enumerable<referenceUpsertWithWhereUniqueWithoutFormReferenceInput>
    set?: Enumerable<referenceWhereUniqueInput>
    disconnect?: Enumerable<referenceWhereUniqueInput>
    delete?: Enumerable<referenceWhereUniqueInput>
    connect?: Enumerable<referenceWhereUniqueInput>
    update?: Enumerable<referenceUpdateWithWhereUniqueWithoutFormReferenceInput>
    updateMany?: Enumerable<referenceUpdateManyWithWhereWithoutFormReferenceInput>
    deleteMany?: Enumerable<referenceScalarWhereInput>
  }

  export type subjectReferenceUpdateManyWithoutFormsNestedInput = {
    create?: XOR<Enumerable<subjectReferenceCreateWithoutFormsInput>, Enumerable<subjectReferenceUncheckedCreateWithoutFormsInput>>
    connectOrCreate?: Enumerable<subjectReferenceCreateOrConnectWithoutFormsInput>
    upsert?: Enumerable<subjectReferenceUpsertWithWhereUniqueWithoutFormsInput>
    set?: Enumerable<subjectReferenceWhereUniqueInput>
    disconnect?: Enumerable<subjectReferenceWhereUniqueInput>
    delete?: Enumerable<subjectReferenceWhereUniqueInput>
    connect?: Enumerable<subjectReferenceWhereUniqueInput>
    update?: Enumerable<subjectReferenceUpdateWithWhereUniqueWithoutFormsInput>
    updateMany?: Enumerable<subjectReferenceUpdateManyWithWhereWithoutFormsInput>
    deleteMany?: Enumerable<subjectReferenceScalarWhereInput>
  }

  export type referenceUncheckedUpdateManyWithoutFormReferenceNestedInput = {
    create?: XOR<Enumerable<referenceCreateWithoutFormReferenceInput>, Enumerable<referenceUncheckedCreateWithoutFormReferenceInput>>
    connectOrCreate?: Enumerable<referenceCreateOrConnectWithoutFormReferenceInput>
    upsert?: Enumerable<referenceUpsertWithWhereUniqueWithoutFormReferenceInput>
    set?: Enumerable<referenceWhereUniqueInput>
    disconnect?: Enumerable<referenceWhereUniqueInput>
    delete?: Enumerable<referenceWhereUniqueInput>
    connect?: Enumerable<referenceWhereUniqueInput>
    update?: Enumerable<referenceUpdateWithWhereUniqueWithoutFormReferenceInput>
    updateMany?: Enumerable<referenceUpdateManyWithWhereWithoutFormReferenceInput>
    deleteMany?: Enumerable<referenceScalarWhereInput>
  }

  export type subjectReferenceUncheckedUpdateManyWithoutFormsNestedInput = {
    create?: XOR<Enumerable<subjectReferenceCreateWithoutFormsInput>, Enumerable<subjectReferenceUncheckedCreateWithoutFormsInput>>
    connectOrCreate?: Enumerable<subjectReferenceCreateOrConnectWithoutFormsInput>
    upsert?: Enumerable<subjectReferenceUpsertWithWhereUniqueWithoutFormsInput>
    set?: Enumerable<subjectReferenceWhereUniqueInput>
    disconnect?: Enumerable<subjectReferenceWhereUniqueInput>
    delete?: Enumerable<subjectReferenceWhereUniqueInput>
    connect?: Enumerable<subjectReferenceWhereUniqueInput>
    update?: Enumerable<subjectReferenceUpdateWithWhereUniqueWithoutFormsInput>
    updateMany?: Enumerable<subjectReferenceUpdateManyWithWhereWithoutFormsInput>
    deleteMany?: Enumerable<subjectReferenceScalarWhereInput>
  }

  export type subjectReferenceCreateNestedOneWithoutReferenceInput = {
    create?: XOR<subjectReferenceCreateWithoutReferenceInput, subjectReferenceUncheckedCreateWithoutReferenceInput>
    connectOrCreate?: subjectReferenceCreateOrConnectWithoutReferenceInput
    connect?: subjectReferenceWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutReferenceInput = {
    create?: XOR<usersCreateWithoutReferenceInput, usersUncheckedCreateWithoutReferenceInput>
    connectOrCreate?: usersCreateOrConnectWithoutReferenceInput
    connect?: usersWhereUniqueInput
  }

  export type formReferenceCreateNestedManyWithoutReferenceInput = {
    create?: XOR<Enumerable<formReferenceCreateWithoutReferenceInput>, Enumerable<formReferenceUncheckedCreateWithoutReferenceInput>>
    connectOrCreate?: Enumerable<formReferenceCreateOrConnectWithoutReferenceInput>
    connect?: Enumerable<formReferenceWhereUniqueInput>
  }

  export type formReferenceUncheckedCreateNestedManyWithoutReferenceInput = {
    create?: XOR<Enumerable<formReferenceCreateWithoutReferenceInput>, Enumerable<formReferenceUncheckedCreateWithoutReferenceInput>>
    connectOrCreate?: Enumerable<formReferenceCreateOrConnectWithoutReferenceInput>
    connect?: Enumerable<formReferenceWhereUniqueInput>
  }

  export type subjectReferenceUpdateOneRequiredWithoutReferenceNestedInput = {
    create?: XOR<subjectReferenceCreateWithoutReferenceInput, subjectReferenceUncheckedCreateWithoutReferenceInput>
    connectOrCreate?: subjectReferenceCreateOrConnectWithoutReferenceInput
    upsert?: subjectReferenceUpsertWithoutReferenceInput
    connect?: subjectReferenceWhereUniqueInput
    update?: XOR<subjectReferenceUpdateWithoutReferenceInput, subjectReferenceUncheckedUpdateWithoutReferenceInput>
  }

  export type usersUpdateOneRequiredWithoutReferenceNestedInput = {
    create?: XOR<usersCreateWithoutReferenceInput, usersUncheckedCreateWithoutReferenceInput>
    connectOrCreate?: usersCreateOrConnectWithoutReferenceInput
    upsert?: usersUpsertWithoutReferenceInput
    connect?: usersWhereUniqueInput
    update?: XOR<usersUpdateWithoutReferenceInput, usersUncheckedUpdateWithoutReferenceInput>
  }

  export type formReferenceUpdateManyWithoutReferenceNestedInput = {
    create?: XOR<Enumerable<formReferenceCreateWithoutReferenceInput>, Enumerable<formReferenceUncheckedCreateWithoutReferenceInput>>
    connectOrCreate?: Enumerable<formReferenceCreateOrConnectWithoutReferenceInput>
    upsert?: Enumerable<formReferenceUpsertWithWhereUniqueWithoutReferenceInput>
    set?: Enumerable<formReferenceWhereUniqueInput>
    disconnect?: Enumerable<formReferenceWhereUniqueInput>
    delete?: Enumerable<formReferenceWhereUniqueInput>
    connect?: Enumerable<formReferenceWhereUniqueInput>
    update?: Enumerable<formReferenceUpdateWithWhereUniqueWithoutReferenceInput>
    updateMany?: Enumerable<formReferenceUpdateManyWithWhereWithoutReferenceInput>
    deleteMany?: Enumerable<formReferenceScalarWhereInput>
  }

  export type formReferenceUncheckedUpdateManyWithoutReferenceNestedInput = {
    create?: XOR<Enumerable<formReferenceCreateWithoutReferenceInput>, Enumerable<formReferenceUncheckedCreateWithoutReferenceInput>>
    connectOrCreate?: Enumerable<formReferenceCreateOrConnectWithoutReferenceInput>
    upsert?: Enumerable<formReferenceUpsertWithWhereUniqueWithoutReferenceInput>
    set?: Enumerable<formReferenceWhereUniqueInput>
    disconnect?: Enumerable<formReferenceWhereUniqueInput>
    delete?: Enumerable<formReferenceWhereUniqueInput>
    connect?: Enumerable<formReferenceWhereUniqueInput>
    update?: Enumerable<formReferenceUpdateWithWhereUniqueWithoutReferenceInput>
    updateMany?: Enumerable<formReferenceUpdateManyWithWhereWithoutReferenceInput>
    deleteMany?: Enumerable<formReferenceScalarWhereInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    search?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    search?: string
    not?: NestedStringFilter | string
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    search?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    search?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type examCreateWithoutUsersInput = {
    description: string
    year: number
    hasAnswers?: boolean
    published?: boolean
    exam: string
    createdAt?: Date | string
    updatedAt?: Date | string
    examType: examTypeCreateNestedOneWithoutExamInput
    examDownloadable?: examDownloadableCreateNestedManyWithoutExamInput
  }

  export type examUncheckedCreateWithoutUsersInput = {
    id?: number
    description: string
    year: number
    hasAnswers?: boolean
    published?: boolean
    examTypeId: number
    exam: string
    createdAt?: Date | string
    updatedAt?: Date | string
    examDownloadable?: examDownloadableUncheckedCreateNestedManyWithoutExamInput
  }

  export type examCreateOrConnectWithoutUsersInput = {
    where: examWhereUniqueInput
    create: XOR<examCreateWithoutUsersInput, examUncheckedCreateWithoutUsersInput>
  }

  export type examCreateManyUsersInputEnvelope = {
    data: Enumerable<examCreateManyUsersInput>
    skipDuplicates?: boolean
  }

  export type examDownloadableCreateWithoutUsersInput = {
    link: string
    fileExtension: string
    published?: boolean
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    exam: examCreateNestedOneWithoutExamDownloadableInput
  }

  export type examDownloadableUncheckedCreateWithoutUsersInput = {
    id?: number
    link: string
    fileExtension: string
    published?: boolean
    examId: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type examDownloadableCreateOrConnectWithoutUsersInput = {
    where: examDownloadableWhereUniqueInput
    create: XOR<examDownloadableCreateWithoutUsersInput, examDownloadableUncheckedCreateWithoutUsersInput>
  }

  export type examDownloadableCreateManyUsersInputEnvelope = {
    data: Enumerable<examDownloadableCreateManyUsersInput>
    skipDuplicates?: boolean
  }

  export type formCreateWithoutUsersInput = {
    formName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    note?: noteCreateNestedManyWithoutFormInput
    notesDownloadable?: notesDownloadableCreateNestedManyWithoutFormInput
    topic?: topicCreateNestedManyWithoutFormInput
    subjects?: subjectCreateNestedManyWithoutFormsInput
  }

  export type formUncheckedCreateWithoutUsersInput = {
    id?: number
    formName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    note?: noteUncheckedCreateNestedManyWithoutFormInput
    notesDownloadable?: notesDownloadableUncheckedCreateNestedManyWithoutFormInput
    topic?: topicUncheckedCreateNestedManyWithoutFormInput
    subjects?: subjectUncheckedCreateNestedManyWithoutFormsInput
  }

  export type formCreateOrConnectWithoutUsersInput = {
    where: formWhereUniqueInput
    create: XOR<formCreateWithoutUsersInput, formUncheckedCreateWithoutUsersInput>
  }

  export type formCreateManyUsersInputEnvelope = {
    data: Enumerable<formCreateManyUsersInput>
    skipDuplicates?: boolean
  }

  export type formExamsCreateWithoutUsersInput = {
    formName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    examType?: examTypeCreateNestedManyWithoutFormExamsInput
    subjects?: subjectExamsCreateNestedManyWithoutFormsInput
  }

  export type formExamsUncheckedCreateWithoutUsersInput = {
    id?: number
    formName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    examType?: examTypeUncheckedCreateNestedManyWithoutFormExamsInput
    subjects?: subjectExamsUncheckedCreateNestedManyWithoutFormsInput
  }

  export type formExamsCreateOrConnectWithoutUsersInput = {
    where: formExamsWhereUniqueInput
    create: XOR<formExamsCreateWithoutUsersInput, formExamsUncheckedCreateWithoutUsersInput>
  }

  export type formExamsCreateManyUsersInputEnvelope = {
    data: Enumerable<formExamsCreateManyUsersInput>
    skipDuplicates?: boolean
  }

  export type formReferenceCreateWithoutUsersInput = {
    formName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    reference?: referenceCreateNestedManyWithoutFormReferenceInput
    subjects?: subjectReferenceCreateNestedManyWithoutFormsInput
  }

  export type formReferenceUncheckedCreateWithoutUsersInput = {
    id?: number
    formName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    reference?: referenceUncheckedCreateNestedManyWithoutFormReferenceInput
    subjects?: subjectReferenceUncheckedCreateNestedManyWithoutFormsInput
  }

  export type formReferenceCreateOrConnectWithoutUsersInput = {
    where: formReferenceWhereUniqueInput
    create: XOR<formReferenceCreateWithoutUsersInput, formReferenceUncheckedCreateWithoutUsersInput>
  }

  export type formReferenceCreateManyUsersInputEnvelope = {
    data: Enumerable<formReferenceCreateManyUsersInput>
    skipDuplicates?: boolean
  }

  export type formReviewCreateWithoutUsersInput = {
    formName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    review?: reviewCreateNestedManyWithoutFormInput
    topic?: topicReviewCreateNestedManyWithoutFormInput
    subjects?: subjectReviewCreateNestedManyWithoutFormsInput
  }

  export type formReviewUncheckedCreateWithoutUsersInput = {
    id?: number
    formName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    review?: reviewUncheckedCreateNestedManyWithoutFormInput
    topic?: topicReviewUncheckedCreateNestedManyWithoutFormInput
    subjects?: subjectReviewUncheckedCreateNestedManyWithoutFormsInput
  }

  export type formReviewCreateOrConnectWithoutUsersInput = {
    where: formReviewWhereUniqueInput
    create: XOR<formReviewCreateWithoutUsersInput, formReviewUncheckedCreateWithoutUsersInput>
  }

  export type formReviewCreateManyUsersInputEnvelope = {
    data: Enumerable<formReviewCreateManyUsersInput>
    skipDuplicates?: boolean
  }

  export type noteCreateWithoutUsersInput = {
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    published?: boolean
    form: formCreateNestedOneWithoutNoteInput
    subject: subjectCreateNestedOneWithoutNoteInput
    topic: topicCreateNestedOneWithoutNoteInput
  }

  export type noteUncheckedCreateWithoutUsersInput = {
    id?: number
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    published?: boolean
    subjectId: number
    formId: number
    topicId: number
  }

  export type noteCreateOrConnectWithoutUsersInput = {
    where: noteWhereUniqueInput
    create: XOR<noteCreateWithoutUsersInput, noteUncheckedCreateWithoutUsersInput>
  }

  export type noteCreateManyUsersInputEnvelope = {
    data: Enumerable<noteCreateManyUsersInput>
    skipDuplicates?: boolean
  }

  export type notesDownloadableCreateWithoutUsersInput = {
    link: string
    fileExtension: string
    published?: boolean
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    form: formCreateNestedOneWithoutNotesDownloadableInput
    subject: subjectCreateNestedOneWithoutNotesDownloadableInput
  }

  export type notesDownloadableUncheckedCreateWithoutUsersInput = {
    id?: number
    link: string
    fileExtension: string
    published?: boolean
    formId: number
    subjectId: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type notesDownloadableCreateOrConnectWithoutUsersInput = {
    where: notesDownloadableWhereUniqueInput
    create: XOR<notesDownloadableCreateWithoutUsersInput, notesDownloadableUncheckedCreateWithoutUsersInput>
  }

  export type notesDownloadableCreateManyUsersInputEnvelope = {
    data: Enumerable<notesDownloadableCreateManyUsersInput>
    skipDuplicates?: boolean
  }

  export type purchaseCreateWithoutUsersInput = {
    name: string
    value: number
  }

  export type purchaseUncheckedCreateWithoutUsersInput = {
    id?: number
    name: string
    value: number
  }

  export type purchaseCreateOrConnectWithoutUsersInput = {
    where: purchaseWhereUniqueInput
    create: XOR<purchaseCreateWithoutUsersInput, purchaseUncheckedCreateWithoutUsersInput>
  }

  export type purchaseCreateManyUsersInputEnvelope = {
    data: Enumerable<purchaseCreateManyUsersInput>
    skipDuplicates?: boolean
  }

  export type questionCreateWithoutUsersInput = {
    question: string
    published?: boolean
    answerDetails?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    questionFormat: questionFormatCreateNestedOneWithoutQuestionInput
    review: reviewCreateNestedOneWithoutQuestionInput
    answer?: answerCreateNestedManyWithoutQuestionInput
  }

  export type questionUncheckedCreateWithoutUsersInput = {
    id?: number
    question: string
    published?: boolean
    answerDetails?: string
    questionFormatId: number
    reviewId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    answer?: answerUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type questionCreateOrConnectWithoutUsersInput = {
    where: questionWhereUniqueInput
    create: XOR<questionCreateWithoutUsersInput, questionUncheckedCreateWithoutUsersInput>
  }

  export type questionCreateManyUsersInputEnvelope = {
    data: Enumerable<questionCreateManyUsersInput>
    skipDuplicates?: boolean
  }

  export type referenceCreateWithoutUsersInput = {
    name: string
    description: string
    data: string
    isPdf: boolean
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    subjectReference: subjectReferenceCreateNestedOneWithoutReferenceInput
    formReference?: formReferenceCreateNestedManyWithoutReferenceInput
  }

  export type referenceUncheckedCreateWithoutUsersInput = {
    id?: number
    name: string
    description: string
    data: string
    isPdf: boolean
    published?: boolean
    subjectId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    formReference?: formReferenceUncheckedCreateNestedManyWithoutReferenceInput
  }

  export type referenceCreateOrConnectWithoutUsersInput = {
    where: referenceWhereUniqueInput
    create: XOR<referenceCreateWithoutUsersInput, referenceUncheckedCreateWithoutUsersInput>
  }

  export type referenceCreateManyUsersInputEnvelope = {
    data: Enumerable<referenceCreateManyUsersInput>
    skipDuplicates?: boolean
  }

  export type reviewCreateWithoutUsersInput = {
    name: string
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    form: formReviewCreateNestedOneWithoutReviewInput
    subject: subjectReviewCreateNestedOneWithoutReviewInput
    topic: topicReviewCreateNestedOneWithoutReviewInput
    question?: questionCreateNestedManyWithoutReviewInput
  }

  export type reviewUncheckedCreateWithoutUsersInput = {
    id?: number
    name: string
    published?: boolean
    topicId: number
    subjectId: number
    formId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    question?: questionUncheckedCreateNestedManyWithoutReviewInput
  }

  export type reviewCreateOrConnectWithoutUsersInput = {
    where: reviewWhereUniqueInput
    create: XOR<reviewCreateWithoutUsersInput, reviewUncheckedCreateWithoutUsersInput>
  }

  export type reviewCreateManyUsersInputEnvelope = {
    data: Enumerable<reviewCreateManyUsersInput>
    skipDuplicates?: boolean
  }

  export type subjectCreateWithoutUsersInput = {
    subjectName: string
    subjectDefinition: string
    imageLocation?: string | null
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    note?: noteCreateNestedManyWithoutSubjectInput
    notesDownloadable?: notesDownloadableCreateNestedManyWithoutSubjectInput
    topic?: topicCreateNestedManyWithoutSubjectInput
    forms?: formCreateNestedManyWithoutSubjectsInput
  }

  export type subjectUncheckedCreateWithoutUsersInput = {
    id?: number
    subjectName: string
    subjectDefinition: string
    imageLocation?: string | null
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    note?: noteUncheckedCreateNestedManyWithoutSubjectInput
    notesDownloadable?: notesDownloadableUncheckedCreateNestedManyWithoutSubjectInput
    topic?: topicUncheckedCreateNestedManyWithoutSubjectInput
    forms?: formUncheckedCreateNestedManyWithoutSubjectsInput
  }

  export type subjectCreateOrConnectWithoutUsersInput = {
    where: subjectWhereUniqueInput
    create: XOR<subjectCreateWithoutUsersInput, subjectUncheckedCreateWithoutUsersInput>
  }

  export type subjectCreateManyUsersInputEnvelope = {
    data: Enumerable<subjectCreateManyUsersInput>
    skipDuplicates?: boolean
  }

  export type subjectExamsCreateWithoutUsersInput = {
    subjectName: string
    subjectDefinition: string
    imageLocation?: string | null
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    examType?: examTypeCreateNestedManyWithoutSubjectExamsInput
    forms?: formExamsCreateNestedManyWithoutSubjectsInput
  }

  export type subjectExamsUncheckedCreateWithoutUsersInput = {
    id?: number
    subjectName: string
    subjectDefinition: string
    imageLocation?: string | null
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    examType?: examTypeUncheckedCreateNestedManyWithoutSubjectExamsInput
    forms?: formExamsUncheckedCreateNestedManyWithoutSubjectsInput
  }

  export type subjectExamsCreateOrConnectWithoutUsersInput = {
    where: subjectExamsWhereUniqueInput
    create: XOR<subjectExamsCreateWithoutUsersInput, subjectExamsUncheckedCreateWithoutUsersInput>
  }

  export type subjectExamsCreateManyUsersInputEnvelope = {
    data: Enumerable<subjectExamsCreateManyUsersInput>
    skipDuplicates?: boolean
  }

  export type subjectReferenceCreateWithoutUsersInput = {
    subjectName: string
    subjectDefinition: string
    imageLocation?: string | null
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    reference?: referenceCreateNestedManyWithoutSubjectReferenceInput
    forms?: formReferenceCreateNestedManyWithoutSubjectsInput
  }

  export type subjectReferenceUncheckedCreateWithoutUsersInput = {
    id?: number
    subjectName: string
    subjectDefinition: string
    imageLocation?: string | null
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    reference?: referenceUncheckedCreateNestedManyWithoutSubjectReferenceInput
    forms?: formReferenceUncheckedCreateNestedManyWithoutSubjectsInput
  }

  export type subjectReferenceCreateOrConnectWithoutUsersInput = {
    where: subjectReferenceWhereUniqueInput
    create: XOR<subjectReferenceCreateWithoutUsersInput, subjectReferenceUncheckedCreateWithoutUsersInput>
  }

  export type subjectReferenceCreateManyUsersInputEnvelope = {
    data: Enumerable<subjectReferenceCreateManyUsersInput>
    skipDuplicates?: boolean
  }

  export type subjectReviewCreateWithoutUsersInput = {
    subjectName: string
    subjectDefinition: string
    imageLocation?: string | null
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    review?: reviewCreateNestedManyWithoutSubjectInput
    topic?: topicReviewCreateNestedManyWithoutSubjectInput
    forms?: formReviewCreateNestedManyWithoutSubjectsInput
  }

  export type subjectReviewUncheckedCreateWithoutUsersInput = {
    id?: number
    subjectName: string
    subjectDefinition: string
    imageLocation?: string | null
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    review?: reviewUncheckedCreateNestedManyWithoutSubjectInput
    topic?: topicReviewUncheckedCreateNestedManyWithoutSubjectInput
    forms?: formReviewUncheckedCreateNestedManyWithoutSubjectsInput
  }

  export type subjectReviewCreateOrConnectWithoutUsersInput = {
    where: subjectReviewWhereUniqueInput
    create: XOR<subjectReviewCreateWithoutUsersInput, subjectReviewUncheckedCreateWithoutUsersInput>
  }

  export type subjectReviewCreateManyUsersInputEnvelope = {
    data: Enumerable<subjectReviewCreateManyUsersInput>
    skipDuplicates?: boolean
  }

  export type topicCreateWithoutUsersInput = {
    topicName: string
    topicDefinition?: string | null
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    form: formCreateNestedOneWithoutTopicInput
    subject: subjectCreateNestedOneWithoutTopicInput
    note?: noteCreateNestedOneWithoutTopicInput
  }

  export type topicUncheckedCreateWithoutUsersInput = {
    id?: number
    topicName: string
    topicDefinition?: string | null
    published?: boolean
    subjectId: number
    formId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    note?: noteUncheckedCreateNestedOneWithoutTopicInput
  }

  export type topicCreateOrConnectWithoutUsersInput = {
    where: topicWhereUniqueInput
    create: XOR<topicCreateWithoutUsersInput, topicUncheckedCreateWithoutUsersInput>
  }

  export type topicCreateManyUsersInputEnvelope = {
    data: Enumerable<topicCreateManyUsersInput>
    skipDuplicates?: boolean
  }

  export type topicReviewCreateWithoutUsersInput = {
    topicName: string
    topicDefinition?: string | null
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    form: formReviewCreateNestedOneWithoutTopicInput
    subject: subjectReviewCreateNestedOneWithoutTopicInput
    review?: reviewCreateNestedManyWithoutTopicInput
  }

  export type topicReviewUncheckedCreateWithoutUsersInput = {
    id?: number
    topicName: string
    topicDefinition?: string | null
    published?: boolean
    subjectId: number
    formId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    review?: reviewUncheckedCreateNestedManyWithoutTopicInput
  }

  export type topicReviewCreateOrConnectWithoutUsersInput = {
    where: topicReviewWhereUniqueInput
    create: XOR<topicReviewCreateWithoutUsersInput, topicReviewUncheckedCreateWithoutUsersInput>
  }

  export type topicReviewCreateManyUsersInputEnvelope = {
    data: Enumerable<topicReviewCreateManyUsersInput>
    skipDuplicates?: boolean
  }

  export type vifurushiCreateWithoutUsersInput = {
    name: string
    value: number
  }

  export type vifurushiUncheckedCreateWithoutUsersInput = {
    id?: number
    name: string
    value: number
  }

  export type vifurushiCreateOrConnectWithoutUsersInput = {
    where: vifurushiWhereUniqueInput
    create: XOR<vifurushiCreateWithoutUsersInput, vifurushiUncheckedCreateWithoutUsersInput>
  }

  export type vifurushiCreateManyUsersInputEnvelope = {
    data: Enumerable<vifurushiCreateManyUsersInput>
    skipDuplicates?: boolean
  }

  export type examUpsertWithWhereUniqueWithoutUsersInput = {
    where: examWhereUniqueInput
    update: XOR<examUpdateWithoutUsersInput, examUncheckedUpdateWithoutUsersInput>
    create: XOR<examCreateWithoutUsersInput, examUncheckedCreateWithoutUsersInput>
  }

  export type examUpdateWithWhereUniqueWithoutUsersInput = {
    where: examWhereUniqueInput
    data: XOR<examUpdateWithoutUsersInput, examUncheckedUpdateWithoutUsersInput>
  }

  export type examUpdateManyWithWhereWithoutUsersInput = {
    where: examScalarWhereInput
    data: XOR<examUpdateManyMutationInput, examUncheckedUpdateManyWithoutExamInput>
  }

  export type examScalarWhereInput = {
    AND?: Enumerable<examScalarWhereInput>
    OR?: Enumerable<examScalarWhereInput>
    NOT?: Enumerable<examScalarWhereInput>
    id?: IntFilter | number
    description?: StringFilter | string
    year?: IntFilter | number
    hasAnswers?: BoolFilter | boolean
    published?: BoolFilter | boolean
    examTypeId?: IntFilter | number
    exam?: StringFilter | string
    usersId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type examDownloadableUpsertWithWhereUniqueWithoutUsersInput = {
    where: examDownloadableWhereUniqueInput
    update: XOR<examDownloadableUpdateWithoutUsersInput, examDownloadableUncheckedUpdateWithoutUsersInput>
    create: XOR<examDownloadableCreateWithoutUsersInput, examDownloadableUncheckedCreateWithoutUsersInput>
  }

  export type examDownloadableUpdateWithWhereUniqueWithoutUsersInput = {
    where: examDownloadableWhereUniqueInput
    data: XOR<examDownloadableUpdateWithoutUsersInput, examDownloadableUncheckedUpdateWithoutUsersInput>
  }

  export type examDownloadableUpdateManyWithWhereWithoutUsersInput = {
    where: examDownloadableScalarWhereInput
    data: XOR<examDownloadableUpdateManyMutationInput, examDownloadableUncheckedUpdateManyWithoutExamDownloadableInput>
  }

  export type examDownloadableScalarWhereInput = {
    AND?: Enumerable<examDownloadableScalarWhereInput>
    OR?: Enumerable<examDownloadableScalarWhereInput>
    NOT?: Enumerable<examDownloadableScalarWhereInput>
    id?: IntFilter | number
    link?: StringFilter | string
    fileExtension?: StringFilter | string
    published?: BoolFilter | boolean
    examId?: IntFilter | number
    usersId?: IntFilter | number
    name?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type formUpsertWithWhereUniqueWithoutUsersInput = {
    where: formWhereUniqueInput
    update: XOR<formUpdateWithoutUsersInput, formUncheckedUpdateWithoutUsersInput>
    create: XOR<formCreateWithoutUsersInput, formUncheckedCreateWithoutUsersInput>
  }

  export type formUpdateWithWhereUniqueWithoutUsersInput = {
    where: formWhereUniqueInput
    data: XOR<formUpdateWithoutUsersInput, formUncheckedUpdateWithoutUsersInput>
  }

  export type formUpdateManyWithWhereWithoutUsersInput = {
    where: formScalarWhereInput
    data: XOR<formUpdateManyMutationInput, formUncheckedUpdateManyWithoutFormInput>
  }

  export type formScalarWhereInput = {
    AND?: Enumerable<formScalarWhereInput>
    OR?: Enumerable<formScalarWhereInput>
    NOT?: Enumerable<formScalarWhereInput>
    id?: IntFilter | number
    formName?: StringFilter | string
    usersId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type formExamsUpsertWithWhereUniqueWithoutUsersInput = {
    where: formExamsWhereUniqueInput
    update: XOR<formExamsUpdateWithoutUsersInput, formExamsUncheckedUpdateWithoutUsersInput>
    create: XOR<formExamsCreateWithoutUsersInput, formExamsUncheckedCreateWithoutUsersInput>
  }

  export type formExamsUpdateWithWhereUniqueWithoutUsersInput = {
    where: formExamsWhereUniqueInput
    data: XOR<formExamsUpdateWithoutUsersInput, formExamsUncheckedUpdateWithoutUsersInput>
  }

  export type formExamsUpdateManyWithWhereWithoutUsersInput = {
    where: formExamsScalarWhereInput
    data: XOR<formExamsUpdateManyMutationInput, formExamsUncheckedUpdateManyWithoutFormExamsInput>
  }

  export type formExamsScalarWhereInput = {
    AND?: Enumerable<formExamsScalarWhereInput>
    OR?: Enumerable<formExamsScalarWhereInput>
    NOT?: Enumerable<formExamsScalarWhereInput>
    id?: IntFilter | number
    formName?: StringFilter | string
    usersId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type formReferenceUpsertWithWhereUniqueWithoutUsersInput = {
    where: formReferenceWhereUniqueInput
    update: XOR<formReferenceUpdateWithoutUsersInput, formReferenceUncheckedUpdateWithoutUsersInput>
    create: XOR<formReferenceCreateWithoutUsersInput, formReferenceUncheckedCreateWithoutUsersInput>
  }

  export type formReferenceUpdateWithWhereUniqueWithoutUsersInput = {
    where: formReferenceWhereUniqueInput
    data: XOR<formReferenceUpdateWithoutUsersInput, formReferenceUncheckedUpdateWithoutUsersInput>
  }

  export type formReferenceUpdateManyWithWhereWithoutUsersInput = {
    where: formReferenceScalarWhereInput
    data: XOR<formReferenceUpdateManyMutationInput, formReferenceUncheckedUpdateManyWithoutFormReferenceInput>
  }

  export type formReferenceScalarWhereInput = {
    AND?: Enumerable<formReferenceScalarWhereInput>
    OR?: Enumerable<formReferenceScalarWhereInput>
    NOT?: Enumerable<formReferenceScalarWhereInput>
    id?: IntFilter | number
    formName?: StringFilter | string
    usersId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type formReviewUpsertWithWhereUniqueWithoutUsersInput = {
    where: formReviewWhereUniqueInput
    update: XOR<formReviewUpdateWithoutUsersInput, formReviewUncheckedUpdateWithoutUsersInput>
    create: XOR<formReviewCreateWithoutUsersInput, formReviewUncheckedCreateWithoutUsersInput>
  }

  export type formReviewUpdateWithWhereUniqueWithoutUsersInput = {
    where: formReviewWhereUniqueInput
    data: XOR<formReviewUpdateWithoutUsersInput, formReviewUncheckedUpdateWithoutUsersInput>
  }

  export type formReviewUpdateManyWithWhereWithoutUsersInput = {
    where: formReviewScalarWhereInput
    data: XOR<formReviewUpdateManyMutationInput, formReviewUncheckedUpdateManyWithoutFormReviewInput>
  }

  export type formReviewScalarWhereInput = {
    AND?: Enumerable<formReviewScalarWhereInput>
    OR?: Enumerable<formReviewScalarWhereInput>
    NOT?: Enumerable<formReviewScalarWhereInput>
    id?: IntFilter | number
    formName?: StringFilter | string
    usersId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type noteUpsertWithWhereUniqueWithoutUsersInput = {
    where: noteWhereUniqueInput
    update: XOR<noteUpdateWithoutUsersInput, noteUncheckedUpdateWithoutUsersInput>
    create: XOR<noteCreateWithoutUsersInput, noteUncheckedCreateWithoutUsersInput>
  }

  export type noteUpdateWithWhereUniqueWithoutUsersInput = {
    where: noteWhereUniqueInput
    data: XOR<noteUpdateWithoutUsersInput, noteUncheckedUpdateWithoutUsersInput>
  }

  export type noteUpdateManyWithWhereWithoutUsersInput = {
    where: noteScalarWhereInput
    data: XOR<noteUpdateManyMutationInput, noteUncheckedUpdateManyWithoutNoteInput>
  }

  export type noteScalarWhereInput = {
    AND?: Enumerable<noteScalarWhereInput>
    OR?: Enumerable<noteScalarWhereInput>
    NOT?: Enumerable<noteScalarWhereInput>
    id?: IntFilter | number
    content?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    published?: BoolFilter | boolean
    subjectId?: IntFilter | number
    formId?: IntFilter | number
    usersId?: IntFilter | number
    topicId?: IntFilter | number
  }

  export type notesDownloadableUpsertWithWhereUniqueWithoutUsersInput = {
    where: notesDownloadableWhereUniqueInput
    update: XOR<notesDownloadableUpdateWithoutUsersInput, notesDownloadableUncheckedUpdateWithoutUsersInput>
    create: XOR<notesDownloadableCreateWithoutUsersInput, notesDownloadableUncheckedCreateWithoutUsersInput>
  }

  export type notesDownloadableUpdateWithWhereUniqueWithoutUsersInput = {
    where: notesDownloadableWhereUniqueInput
    data: XOR<notesDownloadableUpdateWithoutUsersInput, notesDownloadableUncheckedUpdateWithoutUsersInput>
  }

  export type notesDownloadableUpdateManyWithWhereWithoutUsersInput = {
    where: notesDownloadableScalarWhereInput
    data: XOR<notesDownloadableUpdateManyMutationInput, notesDownloadableUncheckedUpdateManyWithoutNotesDownloadableInput>
  }

  export type notesDownloadableScalarWhereInput = {
    AND?: Enumerable<notesDownloadableScalarWhereInput>
    OR?: Enumerable<notesDownloadableScalarWhereInput>
    NOT?: Enumerable<notesDownloadableScalarWhereInput>
    id?: IntFilter | number
    link?: StringFilter | string
    fileExtension?: StringFilter | string
    published?: BoolFilter | boolean
    formId?: IntFilter | number
    subjectId?: IntFilter | number
    usersId?: IntFilter | number
    name?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type purchaseUpsertWithWhereUniqueWithoutUsersInput = {
    where: purchaseWhereUniqueInput
    update: XOR<purchaseUpdateWithoutUsersInput, purchaseUncheckedUpdateWithoutUsersInput>
    create: XOR<purchaseCreateWithoutUsersInput, purchaseUncheckedCreateWithoutUsersInput>
  }

  export type purchaseUpdateWithWhereUniqueWithoutUsersInput = {
    where: purchaseWhereUniqueInput
    data: XOR<purchaseUpdateWithoutUsersInput, purchaseUncheckedUpdateWithoutUsersInput>
  }

  export type purchaseUpdateManyWithWhereWithoutUsersInput = {
    where: purchaseScalarWhereInput
    data: XOR<purchaseUpdateManyMutationInput, purchaseUncheckedUpdateManyWithoutPurchaseInput>
  }

  export type purchaseScalarWhereInput = {
    AND?: Enumerable<purchaseScalarWhereInput>
    OR?: Enumerable<purchaseScalarWhereInput>
    NOT?: Enumerable<purchaseScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    value?: IntFilter | number
    usersId?: IntFilter | number
  }

  export type questionUpsertWithWhereUniqueWithoutUsersInput = {
    where: questionWhereUniqueInput
    update: XOR<questionUpdateWithoutUsersInput, questionUncheckedUpdateWithoutUsersInput>
    create: XOR<questionCreateWithoutUsersInput, questionUncheckedCreateWithoutUsersInput>
  }

  export type questionUpdateWithWhereUniqueWithoutUsersInput = {
    where: questionWhereUniqueInput
    data: XOR<questionUpdateWithoutUsersInput, questionUncheckedUpdateWithoutUsersInput>
  }

  export type questionUpdateManyWithWhereWithoutUsersInput = {
    where: questionScalarWhereInput
    data: XOR<questionUpdateManyMutationInput, questionUncheckedUpdateManyWithoutQuestionInput>
  }

  export type questionScalarWhereInput = {
    AND?: Enumerable<questionScalarWhereInput>
    OR?: Enumerable<questionScalarWhereInput>
    NOT?: Enumerable<questionScalarWhereInput>
    id?: IntFilter | number
    question?: StringFilter | string
    published?: BoolFilter | boolean
    answerDetails?: StringFilter | string
    questionFormatId?: IntFilter | number
    reviewId?: IntFilter | number
    usersId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type referenceUpsertWithWhereUniqueWithoutUsersInput = {
    where: referenceWhereUniqueInput
    update: XOR<referenceUpdateWithoutUsersInput, referenceUncheckedUpdateWithoutUsersInput>
    create: XOR<referenceCreateWithoutUsersInput, referenceUncheckedCreateWithoutUsersInput>
  }

  export type referenceUpdateWithWhereUniqueWithoutUsersInput = {
    where: referenceWhereUniqueInput
    data: XOR<referenceUpdateWithoutUsersInput, referenceUncheckedUpdateWithoutUsersInput>
  }

  export type referenceUpdateManyWithWhereWithoutUsersInput = {
    where: referenceScalarWhereInput
    data: XOR<referenceUpdateManyMutationInput, referenceUncheckedUpdateManyWithoutReferenceInput>
  }

  export type referenceScalarWhereInput = {
    AND?: Enumerable<referenceScalarWhereInput>
    OR?: Enumerable<referenceScalarWhereInput>
    NOT?: Enumerable<referenceScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    description?: StringFilter | string
    data?: StringFilter | string
    isPdf?: BoolFilter | boolean
    published?: BoolFilter | boolean
    subjectId?: IntFilter | number
    usersId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type reviewUpsertWithWhereUniqueWithoutUsersInput = {
    where: reviewWhereUniqueInput
    update: XOR<reviewUpdateWithoutUsersInput, reviewUncheckedUpdateWithoutUsersInput>
    create: XOR<reviewCreateWithoutUsersInput, reviewUncheckedCreateWithoutUsersInput>
  }

  export type reviewUpdateWithWhereUniqueWithoutUsersInput = {
    where: reviewWhereUniqueInput
    data: XOR<reviewUpdateWithoutUsersInput, reviewUncheckedUpdateWithoutUsersInput>
  }

  export type reviewUpdateManyWithWhereWithoutUsersInput = {
    where: reviewScalarWhereInput
    data: XOR<reviewUpdateManyMutationInput, reviewUncheckedUpdateManyWithoutReviewInput>
  }

  export type reviewScalarWhereInput = {
    AND?: Enumerable<reviewScalarWhereInput>
    OR?: Enumerable<reviewScalarWhereInput>
    NOT?: Enumerable<reviewScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    published?: BoolFilter | boolean
    topicId?: IntFilter | number
    subjectId?: IntFilter | number
    formId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    usersId?: IntFilter | number
  }

  export type subjectUpsertWithWhereUniqueWithoutUsersInput = {
    where: subjectWhereUniqueInput
    update: XOR<subjectUpdateWithoutUsersInput, subjectUncheckedUpdateWithoutUsersInput>
    create: XOR<subjectCreateWithoutUsersInput, subjectUncheckedCreateWithoutUsersInput>
  }

  export type subjectUpdateWithWhereUniqueWithoutUsersInput = {
    where: subjectWhereUniqueInput
    data: XOR<subjectUpdateWithoutUsersInput, subjectUncheckedUpdateWithoutUsersInput>
  }

  export type subjectUpdateManyWithWhereWithoutUsersInput = {
    where: subjectScalarWhereInput
    data: XOR<subjectUpdateManyMutationInput, subjectUncheckedUpdateManyWithoutSubjectInput>
  }

  export type subjectScalarWhereInput = {
    AND?: Enumerable<subjectScalarWhereInput>
    OR?: Enumerable<subjectScalarWhereInput>
    NOT?: Enumerable<subjectScalarWhereInput>
    id?: IntFilter | number
    subjectName?: StringFilter | string
    subjectDefinition?: StringFilter | string
    imageLocation?: StringNullableFilter | string | null
    published?: BoolFilter | boolean
    usersId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type subjectExamsUpsertWithWhereUniqueWithoutUsersInput = {
    where: subjectExamsWhereUniqueInput
    update: XOR<subjectExamsUpdateWithoutUsersInput, subjectExamsUncheckedUpdateWithoutUsersInput>
    create: XOR<subjectExamsCreateWithoutUsersInput, subjectExamsUncheckedCreateWithoutUsersInput>
  }

  export type subjectExamsUpdateWithWhereUniqueWithoutUsersInput = {
    where: subjectExamsWhereUniqueInput
    data: XOR<subjectExamsUpdateWithoutUsersInput, subjectExamsUncheckedUpdateWithoutUsersInput>
  }

  export type subjectExamsUpdateManyWithWhereWithoutUsersInput = {
    where: subjectExamsScalarWhereInput
    data: XOR<subjectExamsUpdateManyMutationInput, subjectExamsUncheckedUpdateManyWithoutSubjectExamsInput>
  }

  export type subjectExamsScalarWhereInput = {
    AND?: Enumerable<subjectExamsScalarWhereInput>
    OR?: Enumerable<subjectExamsScalarWhereInput>
    NOT?: Enumerable<subjectExamsScalarWhereInput>
    id?: IntFilter | number
    subjectName?: StringFilter | string
    subjectDefinition?: StringFilter | string
    imageLocation?: StringNullableFilter | string | null
    published?: BoolFilter | boolean
    usersId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type subjectReferenceUpsertWithWhereUniqueWithoutUsersInput = {
    where: subjectReferenceWhereUniqueInput
    update: XOR<subjectReferenceUpdateWithoutUsersInput, subjectReferenceUncheckedUpdateWithoutUsersInput>
    create: XOR<subjectReferenceCreateWithoutUsersInput, subjectReferenceUncheckedCreateWithoutUsersInput>
  }

  export type subjectReferenceUpdateWithWhereUniqueWithoutUsersInput = {
    where: subjectReferenceWhereUniqueInput
    data: XOR<subjectReferenceUpdateWithoutUsersInput, subjectReferenceUncheckedUpdateWithoutUsersInput>
  }

  export type subjectReferenceUpdateManyWithWhereWithoutUsersInput = {
    where: subjectReferenceScalarWhereInput
    data: XOR<subjectReferenceUpdateManyMutationInput, subjectReferenceUncheckedUpdateManyWithoutSubjectReferenceInput>
  }

  export type subjectReferenceScalarWhereInput = {
    AND?: Enumerable<subjectReferenceScalarWhereInput>
    OR?: Enumerable<subjectReferenceScalarWhereInput>
    NOT?: Enumerable<subjectReferenceScalarWhereInput>
    id?: IntFilter | number
    subjectName?: StringFilter | string
    subjectDefinition?: StringFilter | string
    imageLocation?: StringNullableFilter | string | null
    published?: BoolFilter | boolean
    usersId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type subjectReviewUpsertWithWhereUniqueWithoutUsersInput = {
    where: subjectReviewWhereUniqueInput
    update: XOR<subjectReviewUpdateWithoutUsersInput, subjectReviewUncheckedUpdateWithoutUsersInput>
    create: XOR<subjectReviewCreateWithoutUsersInput, subjectReviewUncheckedCreateWithoutUsersInput>
  }

  export type subjectReviewUpdateWithWhereUniqueWithoutUsersInput = {
    where: subjectReviewWhereUniqueInput
    data: XOR<subjectReviewUpdateWithoutUsersInput, subjectReviewUncheckedUpdateWithoutUsersInput>
  }

  export type subjectReviewUpdateManyWithWhereWithoutUsersInput = {
    where: subjectReviewScalarWhereInput
    data: XOR<subjectReviewUpdateManyMutationInput, subjectReviewUncheckedUpdateManyWithoutSubjectReviewInput>
  }

  export type subjectReviewScalarWhereInput = {
    AND?: Enumerable<subjectReviewScalarWhereInput>
    OR?: Enumerable<subjectReviewScalarWhereInput>
    NOT?: Enumerable<subjectReviewScalarWhereInput>
    id?: IntFilter | number
    subjectName?: StringFilter | string
    subjectDefinition?: StringFilter | string
    imageLocation?: StringNullableFilter | string | null
    published?: BoolFilter | boolean
    usersId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type topicUpsertWithWhereUniqueWithoutUsersInput = {
    where: topicWhereUniqueInput
    update: XOR<topicUpdateWithoutUsersInput, topicUncheckedUpdateWithoutUsersInput>
    create: XOR<topicCreateWithoutUsersInput, topicUncheckedCreateWithoutUsersInput>
  }

  export type topicUpdateWithWhereUniqueWithoutUsersInput = {
    where: topicWhereUniqueInput
    data: XOR<topicUpdateWithoutUsersInput, topicUncheckedUpdateWithoutUsersInput>
  }

  export type topicUpdateManyWithWhereWithoutUsersInput = {
    where: topicScalarWhereInput
    data: XOR<topicUpdateManyMutationInput, topicUncheckedUpdateManyWithoutTopicInput>
  }

  export type topicScalarWhereInput = {
    AND?: Enumerable<topicScalarWhereInput>
    OR?: Enumerable<topicScalarWhereInput>
    NOT?: Enumerable<topicScalarWhereInput>
    id?: IntFilter | number
    topicName?: StringFilter | string
    topicDefinition?: StringNullableFilter | string | null
    published?: BoolFilter | boolean
    subjectId?: IntFilter | number
    formId?: IntFilter | number
    usersId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type topicReviewUpsertWithWhereUniqueWithoutUsersInput = {
    where: topicReviewWhereUniqueInput
    update: XOR<topicReviewUpdateWithoutUsersInput, topicReviewUncheckedUpdateWithoutUsersInput>
    create: XOR<topicReviewCreateWithoutUsersInput, topicReviewUncheckedCreateWithoutUsersInput>
  }

  export type topicReviewUpdateWithWhereUniqueWithoutUsersInput = {
    where: topicReviewWhereUniqueInput
    data: XOR<topicReviewUpdateWithoutUsersInput, topicReviewUncheckedUpdateWithoutUsersInput>
  }

  export type topicReviewUpdateManyWithWhereWithoutUsersInput = {
    where: topicReviewScalarWhereInput
    data: XOR<topicReviewUpdateManyMutationInput, topicReviewUncheckedUpdateManyWithoutTopicReviewInput>
  }

  export type topicReviewScalarWhereInput = {
    AND?: Enumerable<topicReviewScalarWhereInput>
    OR?: Enumerable<topicReviewScalarWhereInput>
    NOT?: Enumerable<topicReviewScalarWhereInput>
    id?: IntFilter | number
    topicName?: StringFilter | string
    topicDefinition?: StringNullableFilter | string | null
    published?: BoolFilter | boolean
    subjectId?: IntFilter | number
    formId?: IntFilter | number
    usersId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type vifurushiUpsertWithWhereUniqueWithoutUsersInput = {
    where: vifurushiWhereUniqueInput
    update: XOR<vifurushiUpdateWithoutUsersInput, vifurushiUncheckedUpdateWithoutUsersInput>
    create: XOR<vifurushiCreateWithoutUsersInput, vifurushiUncheckedCreateWithoutUsersInput>
  }

  export type vifurushiUpdateWithWhereUniqueWithoutUsersInput = {
    where: vifurushiWhereUniqueInput
    data: XOR<vifurushiUpdateWithoutUsersInput, vifurushiUncheckedUpdateWithoutUsersInput>
  }

  export type vifurushiUpdateManyWithWhereWithoutUsersInput = {
    where: vifurushiScalarWhereInput
    data: XOR<vifurushiUpdateManyMutationInput, vifurushiUncheckedUpdateManyWithoutVifurushiInput>
  }

  export type vifurushiScalarWhereInput = {
    AND?: Enumerable<vifurushiScalarWhereInput>
    OR?: Enumerable<vifurushiScalarWhereInput>
    NOT?: Enumerable<vifurushiScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    value?: IntFilter | number
    usersId?: IntFilter | number
  }

  export type usersCreateWithoutVifurushiInput = {
    image?: string | null
    username: string
    password: string
    isAdmin?: boolean
    isSuperUser?: boolean
    dateJoined?: Date | string
    name: string
    updatedAt?: Date | string
    isOnline?: boolean
    exam?: examCreateNestedManyWithoutUsersInput
    examDownloadable?: examDownloadableCreateNestedManyWithoutUsersInput
    form?: formCreateNestedManyWithoutUsersInput
    formExams?: formExamsCreateNestedManyWithoutUsersInput
    formReference?: formReferenceCreateNestedManyWithoutUsersInput
    formReview?: formReviewCreateNestedManyWithoutUsersInput
    note?: noteCreateNestedManyWithoutUsersInput
    notesDownloadable?: notesDownloadableCreateNestedManyWithoutUsersInput
    purchase?: purchaseCreateNestedManyWithoutUsersInput
    question?: questionCreateNestedManyWithoutUsersInput
    reference?: referenceCreateNestedManyWithoutUsersInput
    review?: reviewCreateNestedManyWithoutUsersInput
    subject?: subjectCreateNestedManyWithoutUsersInput
    subjectExams?: subjectExamsCreateNestedManyWithoutUsersInput
    subjectReference?: subjectReferenceCreateNestedManyWithoutUsersInput
    subjectReview?: subjectReviewCreateNestedManyWithoutUsersInput
    topic?: topicCreateNestedManyWithoutUsersInput
    topicReview?: topicReviewCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutVifurushiInput = {
    id?: number
    image?: string | null
    username: string
    password: string
    isAdmin?: boolean
    isSuperUser?: boolean
    dateJoined?: Date | string
    name: string
    updatedAt?: Date | string
    isOnline?: boolean
    exam?: examUncheckedCreateNestedManyWithoutUsersInput
    examDownloadable?: examDownloadableUncheckedCreateNestedManyWithoutUsersInput
    form?: formUncheckedCreateNestedManyWithoutUsersInput
    formExams?: formExamsUncheckedCreateNestedManyWithoutUsersInput
    formReference?: formReferenceUncheckedCreateNestedManyWithoutUsersInput
    formReview?: formReviewUncheckedCreateNestedManyWithoutUsersInput
    note?: noteUncheckedCreateNestedManyWithoutUsersInput
    notesDownloadable?: notesDownloadableUncheckedCreateNestedManyWithoutUsersInput
    purchase?: purchaseUncheckedCreateNestedManyWithoutUsersInput
    question?: questionUncheckedCreateNestedManyWithoutUsersInput
    reference?: referenceUncheckedCreateNestedManyWithoutUsersInput
    review?: reviewUncheckedCreateNestedManyWithoutUsersInput
    subject?: subjectUncheckedCreateNestedManyWithoutUsersInput
    subjectExams?: subjectExamsUncheckedCreateNestedManyWithoutUsersInput
    subjectReference?: subjectReferenceUncheckedCreateNestedManyWithoutUsersInput
    subjectReview?: subjectReviewUncheckedCreateNestedManyWithoutUsersInput
    topic?: topicUncheckedCreateNestedManyWithoutUsersInput
    topicReview?: topicReviewUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutVifurushiInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutVifurushiInput, usersUncheckedCreateWithoutVifurushiInput>
  }

  export type usersUpsertWithoutVifurushiInput = {
    update: XOR<usersUpdateWithoutVifurushiInput, usersUncheckedUpdateWithoutVifurushiInput>
    create: XOR<usersCreateWithoutVifurushiInput, usersUncheckedCreateWithoutVifurushiInput>
  }

  export type usersUpdateWithoutVifurushiInput = {
    image?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isSuperUser?: BoolFieldUpdateOperationsInput | boolean
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    exam?: examUpdateManyWithoutUsersNestedInput
    examDownloadable?: examDownloadableUpdateManyWithoutUsersNestedInput
    form?: formUpdateManyWithoutUsersNestedInput
    formExams?: formExamsUpdateManyWithoutUsersNestedInput
    formReference?: formReferenceUpdateManyWithoutUsersNestedInput
    formReview?: formReviewUpdateManyWithoutUsersNestedInput
    note?: noteUpdateManyWithoutUsersNestedInput
    notesDownloadable?: notesDownloadableUpdateManyWithoutUsersNestedInput
    purchase?: purchaseUpdateManyWithoutUsersNestedInput
    question?: questionUpdateManyWithoutUsersNestedInput
    reference?: referenceUpdateManyWithoutUsersNestedInput
    review?: reviewUpdateManyWithoutUsersNestedInput
    subject?: subjectUpdateManyWithoutUsersNestedInput
    subjectExams?: subjectExamsUpdateManyWithoutUsersNestedInput
    subjectReference?: subjectReferenceUpdateManyWithoutUsersNestedInput
    subjectReview?: subjectReviewUpdateManyWithoutUsersNestedInput
    topic?: topicUpdateManyWithoutUsersNestedInput
    topicReview?: topicReviewUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutVifurushiInput = {
    id?: IntFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isSuperUser?: BoolFieldUpdateOperationsInput | boolean
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    exam?: examUncheckedUpdateManyWithoutUsersNestedInput
    examDownloadable?: examDownloadableUncheckedUpdateManyWithoutUsersNestedInput
    form?: formUncheckedUpdateManyWithoutUsersNestedInput
    formExams?: formExamsUncheckedUpdateManyWithoutUsersNestedInput
    formReference?: formReferenceUncheckedUpdateManyWithoutUsersNestedInput
    formReview?: formReviewUncheckedUpdateManyWithoutUsersNestedInput
    note?: noteUncheckedUpdateManyWithoutUsersNestedInput
    notesDownloadable?: notesDownloadableUncheckedUpdateManyWithoutUsersNestedInput
    purchase?: purchaseUncheckedUpdateManyWithoutUsersNestedInput
    question?: questionUncheckedUpdateManyWithoutUsersNestedInput
    reference?: referenceUncheckedUpdateManyWithoutUsersNestedInput
    review?: reviewUncheckedUpdateManyWithoutUsersNestedInput
    subject?: subjectUncheckedUpdateManyWithoutUsersNestedInput
    subjectExams?: subjectExamsUncheckedUpdateManyWithoutUsersNestedInput
    subjectReference?: subjectReferenceUncheckedUpdateManyWithoutUsersNestedInput
    subjectReview?: subjectReviewUncheckedUpdateManyWithoutUsersNestedInput
    topic?: topicUncheckedUpdateManyWithoutUsersNestedInput
    topicReview?: topicReviewUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type booksDownloadCreateWithoutVifurushiPackageInput = {
    name: string
    value: number
  }

  export type booksDownloadUncheckedCreateWithoutVifurushiPackageInput = {
    id?: number
    name: string
    value: number
  }

  export type booksDownloadCreateOrConnectWithoutVifurushiPackageInput = {
    where: booksDownloadWhereUniqueInput
    create: XOR<booksDownloadCreateWithoutVifurushiPackageInput, booksDownloadUncheckedCreateWithoutVifurushiPackageInput>
  }

  export type examAccessCreateWithoutVifurushiPackageInput = {
    name: string
    value: number
  }

  export type examAccessUncheckedCreateWithoutVifurushiPackageInput = {
    id?: number
    name: string
    value: number
  }

  export type examAccessCreateOrConnectWithoutVifurushiPackageInput = {
    where: examAccessWhereUniqueInput
    create: XOR<examAccessCreateWithoutVifurushiPackageInput, examAccessUncheckedCreateWithoutVifurushiPackageInput>
  }

  export type examsSolvedDownloadCreateWithoutVifurushiPackageInput = {
    name: string
    value: number
  }

  export type examsSolvedDownloadUncheckedCreateWithoutVifurushiPackageInput = {
    id?: number
    name: string
    value: number
  }

  export type examsSolvedDownloadCreateOrConnectWithoutVifurushiPackageInput = {
    where: examsSolvedDownloadWhereUniqueInput
    create: XOR<examsSolvedDownloadCreateWithoutVifurushiPackageInput, examsSolvedDownloadUncheckedCreateWithoutVifurushiPackageInput>
  }

  export type examsUnsolvedDownloadCreateWithoutVifurushiPackageInput = {
    name: string
    value: number
  }

  export type examsUnsolvedDownloadUncheckedCreateWithoutVifurushiPackageInput = {
    id?: number
    name: string
    value: number
  }

  export type examsUnsolvedDownloadCreateOrConnectWithoutVifurushiPackageInput = {
    where: examsUnsolvedDownloadWhereUniqueInput
    create: XOR<examsUnsolvedDownloadCreateWithoutVifurushiPackageInput, examsUnsolvedDownloadUncheckedCreateWithoutVifurushiPackageInput>
  }

  export type notesDownloadCreateWithoutVifurushiPackageInput = {
    name: string
    value: number
  }

  export type notesDownloadUncheckedCreateWithoutVifurushiPackageInput = {
    id?: number
    name: string
    value: number
  }

  export type notesDownloadCreateOrConnectWithoutVifurushiPackageInput = {
    where: notesDownloadWhereUniqueInput
    create: XOR<notesDownloadCreateWithoutVifurushiPackageInput, notesDownloadUncheckedCreateWithoutVifurushiPackageInput>
  }

  export type quizExcercisesCreateWithoutVifurushiPackageInput = {
    name: string
    value: number
  }

  export type quizExcercisesUncheckedCreateWithoutVifurushiPackageInput = {
    id?: number
    name: string
    value: number
  }

  export type quizExcercisesCreateOrConnectWithoutVifurushiPackageInput = {
    where: quizExcercisesWhereUniqueInput
    create: XOR<quizExcercisesCreateWithoutVifurushiPackageInput, quizExcercisesUncheckedCreateWithoutVifurushiPackageInput>
  }

  export type booksDownloadUpsertWithoutVifurushiPackageInput = {
    update: XOR<booksDownloadUpdateWithoutVifurushiPackageInput, booksDownloadUncheckedUpdateWithoutVifurushiPackageInput>
    create: XOR<booksDownloadCreateWithoutVifurushiPackageInput, booksDownloadUncheckedCreateWithoutVifurushiPackageInput>
  }

  export type booksDownloadUpdateWithoutVifurushiPackageInput = {
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
  }

  export type booksDownloadUncheckedUpdateWithoutVifurushiPackageInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
  }

  export type examAccessUpsertWithoutVifurushiPackageInput = {
    update: XOR<examAccessUpdateWithoutVifurushiPackageInput, examAccessUncheckedUpdateWithoutVifurushiPackageInput>
    create: XOR<examAccessCreateWithoutVifurushiPackageInput, examAccessUncheckedCreateWithoutVifurushiPackageInput>
  }

  export type examAccessUpdateWithoutVifurushiPackageInput = {
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
  }

  export type examAccessUncheckedUpdateWithoutVifurushiPackageInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
  }

  export type examsSolvedDownloadUpsertWithoutVifurushiPackageInput = {
    update: XOR<examsSolvedDownloadUpdateWithoutVifurushiPackageInput, examsSolvedDownloadUncheckedUpdateWithoutVifurushiPackageInput>
    create: XOR<examsSolvedDownloadCreateWithoutVifurushiPackageInput, examsSolvedDownloadUncheckedCreateWithoutVifurushiPackageInput>
  }

  export type examsSolvedDownloadUpdateWithoutVifurushiPackageInput = {
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
  }

  export type examsSolvedDownloadUncheckedUpdateWithoutVifurushiPackageInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
  }

  export type examsUnsolvedDownloadUpsertWithoutVifurushiPackageInput = {
    update: XOR<examsUnsolvedDownloadUpdateWithoutVifurushiPackageInput, examsUnsolvedDownloadUncheckedUpdateWithoutVifurushiPackageInput>
    create: XOR<examsUnsolvedDownloadCreateWithoutVifurushiPackageInput, examsUnsolvedDownloadUncheckedCreateWithoutVifurushiPackageInput>
  }

  export type examsUnsolvedDownloadUpdateWithoutVifurushiPackageInput = {
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
  }

  export type examsUnsolvedDownloadUncheckedUpdateWithoutVifurushiPackageInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
  }

  export type notesDownloadUpsertWithoutVifurushiPackageInput = {
    update: XOR<notesDownloadUpdateWithoutVifurushiPackageInput, notesDownloadUncheckedUpdateWithoutVifurushiPackageInput>
    create: XOR<notesDownloadCreateWithoutVifurushiPackageInput, notesDownloadUncheckedCreateWithoutVifurushiPackageInput>
  }

  export type notesDownloadUpdateWithoutVifurushiPackageInput = {
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
  }

  export type notesDownloadUncheckedUpdateWithoutVifurushiPackageInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
  }

  export type quizExcercisesUpsertWithoutVifurushiPackageInput = {
    update: XOR<quizExcercisesUpdateWithoutVifurushiPackageInput, quizExcercisesUncheckedUpdateWithoutVifurushiPackageInput>
    create: XOR<quizExcercisesCreateWithoutVifurushiPackageInput, quizExcercisesUncheckedCreateWithoutVifurushiPackageInput>
  }

  export type quizExcercisesUpdateWithoutVifurushiPackageInput = {
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
  }

  export type quizExcercisesUncheckedUpdateWithoutVifurushiPackageInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
  }

  export type vifurushiPackageCreateWithoutNotesDownloadInput = {
    name: string
    value: number
    booksDownload?: booksDownloadCreateNestedOneWithoutVifurushiPackageInput
    examAccess?: examAccessCreateNestedOneWithoutVifurushiPackageInput
    examsSolvedDownload?: examsSolvedDownloadCreateNestedOneWithoutVifurushiPackageInput
    examsUnsolvedDownload?: examsUnsolvedDownloadCreateNestedOneWithoutVifurushiPackageInput
    quizExcercises?: quizExcercisesCreateNestedOneWithoutVifurushiPackageInput
  }

  export type vifurushiPackageUncheckedCreateWithoutNotesDownloadInput = {
    id?: number
    name: string
    value: number
    booksDownload?: booksDownloadUncheckedCreateNestedOneWithoutVifurushiPackageInput
    examAccess?: examAccessUncheckedCreateNestedOneWithoutVifurushiPackageInput
    examsSolvedDownload?: examsSolvedDownloadUncheckedCreateNestedOneWithoutVifurushiPackageInput
    examsUnsolvedDownload?: examsUnsolvedDownloadUncheckedCreateNestedOneWithoutVifurushiPackageInput
    quizExcercises?: quizExcercisesUncheckedCreateNestedOneWithoutVifurushiPackageInput
  }

  export type vifurushiPackageCreateOrConnectWithoutNotesDownloadInput = {
    where: vifurushiPackageWhereUniqueInput
    create: XOR<vifurushiPackageCreateWithoutNotesDownloadInput, vifurushiPackageUncheckedCreateWithoutNotesDownloadInput>
  }

  export type vifurushiPackageUpsertWithoutNotesDownloadInput = {
    update: XOR<vifurushiPackageUpdateWithoutNotesDownloadInput, vifurushiPackageUncheckedUpdateWithoutNotesDownloadInput>
    create: XOR<vifurushiPackageCreateWithoutNotesDownloadInput, vifurushiPackageUncheckedCreateWithoutNotesDownloadInput>
  }

  export type vifurushiPackageUpdateWithoutNotesDownloadInput = {
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    booksDownload?: booksDownloadUpdateOneWithoutVifurushiPackageNestedInput
    examAccess?: examAccessUpdateOneWithoutVifurushiPackageNestedInput
    examsSolvedDownload?: examsSolvedDownloadUpdateOneWithoutVifurushiPackageNestedInput
    examsUnsolvedDownload?: examsUnsolvedDownloadUpdateOneWithoutVifurushiPackageNestedInput
    quizExcercises?: quizExcercisesUpdateOneWithoutVifurushiPackageNestedInput
  }

  export type vifurushiPackageUncheckedUpdateWithoutNotesDownloadInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    booksDownload?: booksDownloadUncheckedUpdateOneWithoutVifurushiPackageNestedInput
    examAccess?: examAccessUncheckedUpdateOneWithoutVifurushiPackageNestedInput
    examsSolvedDownload?: examsSolvedDownloadUncheckedUpdateOneWithoutVifurushiPackageNestedInput
    examsUnsolvedDownload?: examsUnsolvedDownloadUncheckedUpdateOneWithoutVifurushiPackageNestedInput
    quizExcercises?: quizExcercisesUncheckedUpdateOneWithoutVifurushiPackageNestedInput
  }

  export type vifurushiPackageCreateWithoutQuizExcercisesInput = {
    name: string
    value: number
    booksDownload?: booksDownloadCreateNestedOneWithoutVifurushiPackageInput
    examAccess?: examAccessCreateNestedOneWithoutVifurushiPackageInput
    examsSolvedDownload?: examsSolvedDownloadCreateNestedOneWithoutVifurushiPackageInput
    examsUnsolvedDownload?: examsUnsolvedDownloadCreateNestedOneWithoutVifurushiPackageInput
    notesDownload?: notesDownloadCreateNestedOneWithoutVifurushiPackageInput
  }

  export type vifurushiPackageUncheckedCreateWithoutQuizExcercisesInput = {
    id?: number
    name: string
    value: number
    booksDownload?: booksDownloadUncheckedCreateNestedOneWithoutVifurushiPackageInput
    examAccess?: examAccessUncheckedCreateNestedOneWithoutVifurushiPackageInput
    examsSolvedDownload?: examsSolvedDownloadUncheckedCreateNestedOneWithoutVifurushiPackageInput
    examsUnsolvedDownload?: examsUnsolvedDownloadUncheckedCreateNestedOneWithoutVifurushiPackageInput
    notesDownload?: notesDownloadUncheckedCreateNestedOneWithoutVifurushiPackageInput
  }

  export type vifurushiPackageCreateOrConnectWithoutQuizExcercisesInput = {
    where: vifurushiPackageWhereUniqueInput
    create: XOR<vifurushiPackageCreateWithoutQuizExcercisesInput, vifurushiPackageUncheckedCreateWithoutQuizExcercisesInput>
  }

  export type vifurushiPackageUpsertWithoutQuizExcercisesInput = {
    update: XOR<vifurushiPackageUpdateWithoutQuizExcercisesInput, vifurushiPackageUncheckedUpdateWithoutQuizExcercisesInput>
    create: XOR<vifurushiPackageCreateWithoutQuizExcercisesInput, vifurushiPackageUncheckedCreateWithoutQuizExcercisesInput>
  }

  export type vifurushiPackageUpdateWithoutQuizExcercisesInput = {
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    booksDownload?: booksDownloadUpdateOneWithoutVifurushiPackageNestedInput
    examAccess?: examAccessUpdateOneWithoutVifurushiPackageNestedInput
    examsSolvedDownload?: examsSolvedDownloadUpdateOneWithoutVifurushiPackageNestedInput
    examsUnsolvedDownload?: examsUnsolvedDownloadUpdateOneWithoutVifurushiPackageNestedInput
    notesDownload?: notesDownloadUpdateOneWithoutVifurushiPackageNestedInput
  }

  export type vifurushiPackageUncheckedUpdateWithoutQuizExcercisesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    booksDownload?: booksDownloadUncheckedUpdateOneWithoutVifurushiPackageNestedInput
    examAccess?: examAccessUncheckedUpdateOneWithoutVifurushiPackageNestedInput
    examsSolvedDownload?: examsSolvedDownloadUncheckedUpdateOneWithoutVifurushiPackageNestedInput
    examsUnsolvedDownload?: examsUnsolvedDownloadUncheckedUpdateOneWithoutVifurushiPackageNestedInput
    notesDownload?: notesDownloadUncheckedUpdateOneWithoutVifurushiPackageNestedInput
  }

  export type vifurushiPackageCreateWithoutExamsUnsolvedDownloadInput = {
    name: string
    value: number
    booksDownload?: booksDownloadCreateNestedOneWithoutVifurushiPackageInput
    examAccess?: examAccessCreateNestedOneWithoutVifurushiPackageInput
    examsSolvedDownload?: examsSolvedDownloadCreateNestedOneWithoutVifurushiPackageInput
    notesDownload?: notesDownloadCreateNestedOneWithoutVifurushiPackageInput
    quizExcercises?: quizExcercisesCreateNestedOneWithoutVifurushiPackageInput
  }

  export type vifurushiPackageUncheckedCreateWithoutExamsUnsolvedDownloadInput = {
    id?: number
    name: string
    value: number
    booksDownload?: booksDownloadUncheckedCreateNestedOneWithoutVifurushiPackageInput
    examAccess?: examAccessUncheckedCreateNestedOneWithoutVifurushiPackageInput
    examsSolvedDownload?: examsSolvedDownloadUncheckedCreateNestedOneWithoutVifurushiPackageInput
    notesDownload?: notesDownloadUncheckedCreateNestedOneWithoutVifurushiPackageInput
    quizExcercises?: quizExcercisesUncheckedCreateNestedOneWithoutVifurushiPackageInput
  }

  export type vifurushiPackageCreateOrConnectWithoutExamsUnsolvedDownloadInput = {
    where: vifurushiPackageWhereUniqueInput
    create: XOR<vifurushiPackageCreateWithoutExamsUnsolvedDownloadInput, vifurushiPackageUncheckedCreateWithoutExamsUnsolvedDownloadInput>
  }

  export type vifurushiPackageUpsertWithoutExamsUnsolvedDownloadInput = {
    update: XOR<vifurushiPackageUpdateWithoutExamsUnsolvedDownloadInput, vifurushiPackageUncheckedUpdateWithoutExamsUnsolvedDownloadInput>
    create: XOR<vifurushiPackageCreateWithoutExamsUnsolvedDownloadInput, vifurushiPackageUncheckedCreateWithoutExamsUnsolvedDownloadInput>
  }

  export type vifurushiPackageUpdateWithoutExamsUnsolvedDownloadInput = {
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    booksDownload?: booksDownloadUpdateOneWithoutVifurushiPackageNestedInput
    examAccess?: examAccessUpdateOneWithoutVifurushiPackageNestedInput
    examsSolvedDownload?: examsSolvedDownloadUpdateOneWithoutVifurushiPackageNestedInput
    notesDownload?: notesDownloadUpdateOneWithoutVifurushiPackageNestedInput
    quizExcercises?: quizExcercisesUpdateOneWithoutVifurushiPackageNestedInput
  }

  export type vifurushiPackageUncheckedUpdateWithoutExamsUnsolvedDownloadInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    booksDownload?: booksDownloadUncheckedUpdateOneWithoutVifurushiPackageNestedInput
    examAccess?: examAccessUncheckedUpdateOneWithoutVifurushiPackageNestedInput
    examsSolvedDownload?: examsSolvedDownloadUncheckedUpdateOneWithoutVifurushiPackageNestedInput
    notesDownload?: notesDownloadUncheckedUpdateOneWithoutVifurushiPackageNestedInput
    quizExcercises?: quizExcercisesUncheckedUpdateOneWithoutVifurushiPackageNestedInput
  }

  export type vifurushiPackageCreateWithoutExamsSolvedDownloadInput = {
    name: string
    value: number
    booksDownload?: booksDownloadCreateNestedOneWithoutVifurushiPackageInput
    examAccess?: examAccessCreateNestedOneWithoutVifurushiPackageInput
    examsUnsolvedDownload?: examsUnsolvedDownloadCreateNestedOneWithoutVifurushiPackageInput
    notesDownload?: notesDownloadCreateNestedOneWithoutVifurushiPackageInput
    quizExcercises?: quizExcercisesCreateNestedOneWithoutVifurushiPackageInput
  }

  export type vifurushiPackageUncheckedCreateWithoutExamsSolvedDownloadInput = {
    id?: number
    name: string
    value: number
    booksDownload?: booksDownloadUncheckedCreateNestedOneWithoutVifurushiPackageInput
    examAccess?: examAccessUncheckedCreateNestedOneWithoutVifurushiPackageInput
    examsUnsolvedDownload?: examsUnsolvedDownloadUncheckedCreateNestedOneWithoutVifurushiPackageInput
    notesDownload?: notesDownloadUncheckedCreateNestedOneWithoutVifurushiPackageInput
    quizExcercises?: quizExcercisesUncheckedCreateNestedOneWithoutVifurushiPackageInput
  }

  export type vifurushiPackageCreateOrConnectWithoutExamsSolvedDownloadInput = {
    where: vifurushiPackageWhereUniqueInput
    create: XOR<vifurushiPackageCreateWithoutExamsSolvedDownloadInput, vifurushiPackageUncheckedCreateWithoutExamsSolvedDownloadInput>
  }

  export type vifurushiPackageUpsertWithoutExamsSolvedDownloadInput = {
    update: XOR<vifurushiPackageUpdateWithoutExamsSolvedDownloadInput, vifurushiPackageUncheckedUpdateWithoutExamsSolvedDownloadInput>
    create: XOR<vifurushiPackageCreateWithoutExamsSolvedDownloadInput, vifurushiPackageUncheckedCreateWithoutExamsSolvedDownloadInput>
  }

  export type vifurushiPackageUpdateWithoutExamsSolvedDownloadInput = {
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    booksDownload?: booksDownloadUpdateOneWithoutVifurushiPackageNestedInput
    examAccess?: examAccessUpdateOneWithoutVifurushiPackageNestedInput
    examsUnsolvedDownload?: examsUnsolvedDownloadUpdateOneWithoutVifurushiPackageNestedInput
    notesDownload?: notesDownloadUpdateOneWithoutVifurushiPackageNestedInput
    quizExcercises?: quizExcercisesUpdateOneWithoutVifurushiPackageNestedInput
  }

  export type vifurushiPackageUncheckedUpdateWithoutExamsSolvedDownloadInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    booksDownload?: booksDownloadUncheckedUpdateOneWithoutVifurushiPackageNestedInput
    examAccess?: examAccessUncheckedUpdateOneWithoutVifurushiPackageNestedInput
    examsUnsolvedDownload?: examsUnsolvedDownloadUncheckedUpdateOneWithoutVifurushiPackageNestedInput
    notesDownload?: notesDownloadUncheckedUpdateOneWithoutVifurushiPackageNestedInput
    quizExcercises?: quizExcercisesUncheckedUpdateOneWithoutVifurushiPackageNestedInput
  }

  export type vifurushiPackageCreateWithoutExamAccessInput = {
    name: string
    value: number
    booksDownload?: booksDownloadCreateNestedOneWithoutVifurushiPackageInput
    examsSolvedDownload?: examsSolvedDownloadCreateNestedOneWithoutVifurushiPackageInput
    examsUnsolvedDownload?: examsUnsolvedDownloadCreateNestedOneWithoutVifurushiPackageInput
    notesDownload?: notesDownloadCreateNestedOneWithoutVifurushiPackageInput
    quizExcercises?: quizExcercisesCreateNestedOneWithoutVifurushiPackageInput
  }

  export type vifurushiPackageUncheckedCreateWithoutExamAccessInput = {
    id?: number
    name: string
    value: number
    booksDownload?: booksDownloadUncheckedCreateNestedOneWithoutVifurushiPackageInput
    examsSolvedDownload?: examsSolvedDownloadUncheckedCreateNestedOneWithoutVifurushiPackageInput
    examsUnsolvedDownload?: examsUnsolvedDownloadUncheckedCreateNestedOneWithoutVifurushiPackageInput
    notesDownload?: notesDownloadUncheckedCreateNestedOneWithoutVifurushiPackageInput
    quizExcercises?: quizExcercisesUncheckedCreateNestedOneWithoutVifurushiPackageInput
  }

  export type vifurushiPackageCreateOrConnectWithoutExamAccessInput = {
    where: vifurushiPackageWhereUniqueInput
    create: XOR<vifurushiPackageCreateWithoutExamAccessInput, vifurushiPackageUncheckedCreateWithoutExamAccessInput>
  }

  export type vifurushiPackageUpsertWithoutExamAccessInput = {
    update: XOR<vifurushiPackageUpdateWithoutExamAccessInput, vifurushiPackageUncheckedUpdateWithoutExamAccessInput>
    create: XOR<vifurushiPackageCreateWithoutExamAccessInput, vifurushiPackageUncheckedCreateWithoutExamAccessInput>
  }

  export type vifurushiPackageUpdateWithoutExamAccessInput = {
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    booksDownload?: booksDownloadUpdateOneWithoutVifurushiPackageNestedInput
    examsSolvedDownload?: examsSolvedDownloadUpdateOneWithoutVifurushiPackageNestedInput
    examsUnsolvedDownload?: examsUnsolvedDownloadUpdateOneWithoutVifurushiPackageNestedInput
    notesDownload?: notesDownloadUpdateOneWithoutVifurushiPackageNestedInput
    quizExcercises?: quizExcercisesUpdateOneWithoutVifurushiPackageNestedInput
  }

  export type vifurushiPackageUncheckedUpdateWithoutExamAccessInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    booksDownload?: booksDownloadUncheckedUpdateOneWithoutVifurushiPackageNestedInput
    examsSolvedDownload?: examsSolvedDownloadUncheckedUpdateOneWithoutVifurushiPackageNestedInput
    examsUnsolvedDownload?: examsUnsolvedDownloadUncheckedUpdateOneWithoutVifurushiPackageNestedInput
    notesDownload?: notesDownloadUncheckedUpdateOneWithoutVifurushiPackageNestedInput
    quizExcercises?: quizExcercisesUncheckedUpdateOneWithoutVifurushiPackageNestedInput
  }

  export type vifurushiPackageCreateWithoutBooksDownloadInput = {
    name: string
    value: number
    examAccess?: examAccessCreateNestedOneWithoutVifurushiPackageInput
    examsSolvedDownload?: examsSolvedDownloadCreateNestedOneWithoutVifurushiPackageInput
    examsUnsolvedDownload?: examsUnsolvedDownloadCreateNestedOneWithoutVifurushiPackageInput
    notesDownload?: notesDownloadCreateNestedOneWithoutVifurushiPackageInput
    quizExcercises?: quizExcercisesCreateNestedOneWithoutVifurushiPackageInput
  }

  export type vifurushiPackageUncheckedCreateWithoutBooksDownloadInput = {
    id?: number
    name: string
    value: number
    examAccess?: examAccessUncheckedCreateNestedOneWithoutVifurushiPackageInput
    examsSolvedDownload?: examsSolvedDownloadUncheckedCreateNestedOneWithoutVifurushiPackageInput
    examsUnsolvedDownload?: examsUnsolvedDownloadUncheckedCreateNestedOneWithoutVifurushiPackageInput
    notesDownload?: notesDownloadUncheckedCreateNestedOneWithoutVifurushiPackageInput
    quizExcercises?: quizExcercisesUncheckedCreateNestedOneWithoutVifurushiPackageInput
  }

  export type vifurushiPackageCreateOrConnectWithoutBooksDownloadInput = {
    where: vifurushiPackageWhereUniqueInput
    create: XOR<vifurushiPackageCreateWithoutBooksDownloadInput, vifurushiPackageUncheckedCreateWithoutBooksDownloadInput>
  }

  export type vifurushiPackageUpsertWithoutBooksDownloadInput = {
    update: XOR<vifurushiPackageUpdateWithoutBooksDownloadInput, vifurushiPackageUncheckedUpdateWithoutBooksDownloadInput>
    create: XOR<vifurushiPackageCreateWithoutBooksDownloadInput, vifurushiPackageUncheckedCreateWithoutBooksDownloadInput>
  }

  export type vifurushiPackageUpdateWithoutBooksDownloadInput = {
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    examAccess?: examAccessUpdateOneWithoutVifurushiPackageNestedInput
    examsSolvedDownload?: examsSolvedDownloadUpdateOneWithoutVifurushiPackageNestedInput
    examsUnsolvedDownload?: examsUnsolvedDownloadUpdateOneWithoutVifurushiPackageNestedInput
    notesDownload?: notesDownloadUpdateOneWithoutVifurushiPackageNestedInput
    quizExcercises?: quizExcercisesUpdateOneWithoutVifurushiPackageNestedInput
  }

  export type vifurushiPackageUncheckedUpdateWithoutBooksDownloadInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    examAccess?: examAccessUncheckedUpdateOneWithoutVifurushiPackageNestedInput
    examsSolvedDownload?: examsSolvedDownloadUncheckedUpdateOneWithoutVifurushiPackageNestedInput
    examsUnsolvedDownload?: examsUnsolvedDownloadUncheckedUpdateOneWithoutVifurushiPackageNestedInput
    notesDownload?: notesDownloadUncheckedUpdateOneWithoutVifurushiPackageNestedInput
    quizExcercises?: quizExcercisesUncheckedUpdateOneWithoutVifurushiPackageNestedInput
  }

  export type usersCreateWithoutPurchaseInput = {
    image?: string | null
    username: string
    password: string
    isAdmin?: boolean
    isSuperUser?: boolean
    dateJoined?: Date | string
    name: string
    updatedAt?: Date | string
    isOnline?: boolean
    exam?: examCreateNestedManyWithoutUsersInput
    examDownloadable?: examDownloadableCreateNestedManyWithoutUsersInput
    form?: formCreateNestedManyWithoutUsersInput
    formExams?: formExamsCreateNestedManyWithoutUsersInput
    formReference?: formReferenceCreateNestedManyWithoutUsersInput
    formReview?: formReviewCreateNestedManyWithoutUsersInput
    note?: noteCreateNestedManyWithoutUsersInput
    notesDownloadable?: notesDownloadableCreateNestedManyWithoutUsersInput
    question?: questionCreateNestedManyWithoutUsersInput
    reference?: referenceCreateNestedManyWithoutUsersInput
    review?: reviewCreateNestedManyWithoutUsersInput
    subject?: subjectCreateNestedManyWithoutUsersInput
    subjectExams?: subjectExamsCreateNestedManyWithoutUsersInput
    subjectReference?: subjectReferenceCreateNestedManyWithoutUsersInput
    subjectReview?: subjectReviewCreateNestedManyWithoutUsersInput
    topic?: topicCreateNestedManyWithoutUsersInput
    topicReview?: topicReviewCreateNestedManyWithoutUsersInput
    vifurushi?: vifurushiCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutPurchaseInput = {
    id?: number
    image?: string | null
    username: string
    password: string
    isAdmin?: boolean
    isSuperUser?: boolean
    dateJoined?: Date | string
    name: string
    updatedAt?: Date | string
    isOnline?: boolean
    exam?: examUncheckedCreateNestedManyWithoutUsersInput
    examDownloadable?: examDownloadableUncheckedCreateNestedManyWithoutUsersInput
    form?: formUncheckedCreateNestedManyWithoutUsersInput
    formExams?: formExamsUncheckedCreateNestedManyWithoutUsersInput
    formReference?: formReferenceUncheckedCreateNestedManyWithoutUsersInput
    formReview?: formReviewUncheckedCreateNestedManyWithoutUsersInput
    note?: noteUncheckedCreateNestedManyWithoutUsersInput
    notesDownloadable?: notesDownloadableUncheckedCreateNestedManyWithoutUsersInput
    question?: questionUncheckedCreateNestedManyWithoutUsersInput
    reference?: referenceUncheckedCreateNestedManyWithoutUsersInput
    review?: reviewUncheckedCreateNestedManyWithoutUsersInput
    subject?: subjectUncheckedCreateNestedManyWithoutUsersInput
    subjectExams?: subjectExamsUncheckedCreateNestedManyWithoutUsersInput
    subjectReference?: subjectReferenceUncheckedCreateNestedManyWithoutUsersInput
    subjectReview?: subjectReviewUncheckedCreateNestedManyWithoutUsersInput
    topic?: topicUncheckedCreateNestedManyWithoutUsersInput
    topicReview?: topicReviewUncheckedCreateNestedManyWithoutUsersInput
    vifurushi?: vifurushiUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutPurchaseInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutPurchaseInput, usersUncheckedCreateWithoutPurchaseInput>
  }

  export type usersUpsertWithoutPurchaseInput = {
    update: XOR<usersUpdateWithoutPurchaseInput, usersUncheckedUpdateWithoutPurchaseInput>
    create: XOR<usersCreateWithoutPurchaseInput, usersUncheckedCreateWithoutPurchaseInput>
  }

  export type usersUpdateWithoutPurchaseInput = {
    image?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isSuperUser?: BoolFieldUpdateOperationsInput | boolean
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    exam?: examUpdateManyWithoutUsersNestedInput
    examDownloadable?: examDownloadableUpdateManyWithoutUsersNestedInput
    form?: formUpdateManyWithoutUsersNestedInput
    formExams?: formExamsUpdateManyWithoutUsersNestedInput
    formReference?: formReferenceUpdateManyWithoutUsersNestedInput
    formReview?: formReviewUpdateManyWithoutUsersNestedInput
    note?: noteUpdateManyWithoutUsersNestedInput
    notesDownloadable?: notesDownloadableUpdateManyWithoutUsersNestedInput
    question?: questionUpdateManyWithoutUsersNestedInput
    reference?: referenceUpdateManyWithoutUsersNestedInput
    review?: reviewUpdateManyWithoutUsersNestedInput
    subject?: subjectUpdateManyWithoutUsersNestedInput
    subjectExams?: subjectExamsUpdateManyWithoutUsersNestedInput
    subjectReference?: subjectReferenceUpdateManyWithoutUsersNestedInput
    subjectReview?: subjectReviewUpdateManyWithoutUsersNestedInput
    topic?: topicUpdateManyWithoutUsersNestedInput
    topicReview?: topicReviewUpdateManyWithoutUsersNestedInput
    vifurushi?: vifurushiUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutPurchaseInput = {
    id?: IntFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isSuperUser?: BoolFieldUpdateOperationsInput | boolean
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    exam?: examUncheckedUpdateManyWithoutUsersNestedInput
    examDownloadable?: examDownloadableUncheckedUpdateManyWithoutUsersNestedInput
    form?: formUncheckedUpdateManyWithoutUsersNestedInput
    formExams?: formExamsUncheckedUpdateManyWithoutUsersNestedInput
    formReference?: formReferenceUncheckedUpdateManyWithoutUsersNestedInput
    formReview?: formReviewUncheckedUpdateManyWithoutUsersNestedInput
    note?: noteUncheckedUpdateManyWithoutUsersNestedInput
    notesDownloadable?: notesDownloadableUncheckedUpdateManyWithoutUsersNestedInput
    question?: questionUncheckedUpdateManyWithoutUsersNestedInput
    reference?: referenceUncheckedUpdateManyWithoutUsersNestedInput
    review?: reviewUncheckedUpdateManyWithoutUsersNestedInput
    subject?: subjectUncheckedUpdateManyWithoutUsersNestedInput
    subjectExams?: subjectExamsUncheckedUpdateManyWithoutUsersNestedInput
    subjectReference?: subjectReferenceUncheckedUpdateManyWithoutUsersNestedInput
    subjectReview?: subjectReviewUncheckedUpdateManyWithoutUsersNestedInput
    topic?: topicUncheckedUpdateManyWithoutUsersNestedInput
    topicReview?: topicReviewUncheckedUpdateManyWithoutUsersNestedInput
    vifurushi?: vifurushiUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersCreateWithoutSubjectInput = {
    image?: string | null
    username: string
    password: string
    isAdmin?: boolean
    isSuperUser?: boolean
    dateJoined?: Date | string
    name: string
    updatedAt?: Date | string
    isOnline?: boolean
    exam?: examCreateNestedManyWithoutUsersInput
    examDownloadable?: examDownloadableCreateNestedManyWithoutUsersInput
    form?: formCreateNestedManyWithoutUsersInput
    formExams?: formExamsCreateNestedManyWithoutUsersInput
    formReference?: formReferenceCreateNestedManyWithoutUsersInput
    formReview?: formReviewCreateNestedManyWithoutUsersInput
    note?: noteCreateNestedManyWithoutUsersInput
    notesDownloadable?: notesDownloadableCreateNestedManyWithoutUsersInput
    purchase?: purchaseCreateNestedManyWithoutUsersInput
    question?: questionCreateNestedManyWithoutUsersInput
    reference?: referenceCreateNestedManyWithoutUsersInput
    review?: reviewCreateNestedManyWithoutUsersInput
    subjectExams?: subjectExamsCreateNestedManyWithoutUsersInput
    subjectReference?: subjectReferenceCreateNestedManyWithoutUsersInput
    subjectReview?: subjectReviewCreateNestedManyWithoutUsersInput
    topic?: topicCreateNestedManyWithoutUsersInput
    topicReview?: topicReviewCreateNestedManyWithoutUsersInput
    vifurushi?: vifurushiCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutSubjectInput = {
    id?: number
    image?: string | null
    username: string
    password: string
    isAdmin?: boolean
    isSuperUser?: boolean
    dateJoined?: Date | string
    name: string
    updatedAt?: Date | string
    isOnline?: boolean
    exam?: examUncheckedCreateNestedManyWithoutUsersInput
    examDownloadable?: examDownloadableUncheckedCreateNestedManyWithoutUsersInput
    form?: formUncheckedCreateNestedManyWithoutUsersInput
    formExams?: formExamsUncheckedCreateNestedManyWithoutUsersInput
    formReference?: formReferenceUncheckedCreateNestedManyWithoutUsersInput
    formReview?: formReviewUncheckedCreateNestedManyWithoutUsersInput
    note?: noteUncheckedCreateNestedManyWithoutUsersInput
    notesDownloadable?: notesDownloadableUncheckedCreateNestedManyWithoutUsersInput
    purchase?: purchaseUncheckedCreateNestedManyWithoutUsersInput
    question?: questionUncheckedCreateNestedManyWithoutUsersInput
    reference?: referenceUncheckedCreateNestedManyWithoutUsersInput
    review?: reviewUncheckedCreateNestedManyWithoutUsersInput
    subjectExams?: subjectExamsUncheckedCreateNestedManyWithoutUsersInput
    subjectReference?: subjectReferenceUncheckedCreateNestedManyWithoutUsersInput
    subjectReview?: subjectReviewUncheckedCreateNestedManyWithoutUsersInput
    topic?: topicUncheckedCreateNestedManyWithoutUsersInput
    topicReview?: topicReviewUncheckedCreateNestedManyWithoutUsersInput
    vifurushi?: vifurushiUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutSubjectInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutSubjectInput, usersUncheckedCreateWithoutSubjectInput>
  }

  export type noteCreateWithoutSubjectInput = {
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    published?: boolean
    form: formCreateNestedOneWithoutNoteInput
    topic: topicCreateNestedOneWithoutNoteInput
    users: usersCreateNestedOneWithoutNoteInput
  }

  export type noteUncheckedCreateWithoutSubjectInput = {
    id?: number
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    published?: boolean
    formId: number
    usersId: number
    topicId: number
  }

  export type noteCreateOrConnectWithoutSubjectInput = {
    where: noteWhereUniqueInput
    create: XOR<noteCreateWithoutSubjectInput, noteUncheckedCreateWithoutSubjectInput>
  }

  export type noteCreateManySubjectInputEnvelope = {
    data: Enumerable<noteCreateManySubjectInput>
    skipDuplicates?: boolean
  }

  export type notesDownloadableCreateWithoutSubjectInput = {
    link: string
    fileExtension: string
    published?: boolean
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    form: formCreateNestedOneWithoutNotesDownloadableInput
    users: usersCreateNestedOneWithoutNotesDownloadableInput
  }

  export type notesDownloadableUncheckedCreateWithoutSubjectInput = {
    id?: number
    link: string
    fileExtension: string
    published?: boolean
    formId: number
    usersId: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type notesDownloadableCreateOrConnectWithoutSubjectInput = {
    where: notesDownloadableWhereUniqueInput
    create: XOR<notesDownloadableCreateWithoutSubjectInput, notesDownloadableUncheckedCreateWithoutSubjectInput>
  }

  export type notesDownloadableCreateManySubjectInputEnvelope = {
    data: Enumerable<notesDownloadableCreateManySubjectInput>
    skipDuplicates?: boolean
  }

  export type topicCreateWithoutSubjectInput = {
    topicName: string
    topicDefinition?: string | null
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    form: formCreateNestedOneWithoutTopicInput
    users: usersCreateNestedOneWithoutTopicInput
    note?: noteCreateNestedOneWithoutTopicInput
  }

  export type topicUncheckedCreateWithoutSubjectInput = {
    id?: number
    topicName: string
    topicDefinition?: string | null
    published?: boolean
    formId: number
    usersId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    note?: noteUncheckedCreateNestedOneWithoutTopicInput
  }

  export type topicCreateOrConnectWithoutSubjectInput = {
    where: topicWhereUniqueInput
    create: XOR<topicCreateWithoutSubjectInput, topicUncheckedCreateWithoutSubjectInput>
  }

  export type topicCreateManySubjectInputEnvelope = {
    data: Enumerable<topicCreateManySubjectInput>
    skipDuplicates?: boolean
  }

  export type formCreateWithoutSubjectsInput = {
    formName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users: usersCreateNestedOneWithoutFormInput
    note?: noteCreateNestedManyWithoutFormInput
    notesDownloadable?: notesDownloadableCreateNestedManyWithoutFormInput
    topic?: topicCreateNestedManyWithoutFormInput
  }

  export type formUncheckedCreateWithoutSubjectsInput = {
    id?: number
    formName: string
    usersId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    note?: noteUncheckedCreateNestedManyWithoutFormInput
    notesDownloadable?: notesDownloadableUncheckedCreateNestedManyWithoutFormInput
    topic?: topicUncheckedCreateNestedManyWithoutFormInput
  }

  export type formCreateOrConnectWithoutSubjectsInput = {
    where: formWhereUniqueInput
    create: XOR<formCreateWithoutSubjectsInput, formUncheckedCreateWithoutSubjectsInput>
  }

  export type usersUpsertWithoutSubjectInput = {
    update: XOR<usersUpdateWithoutSubjectInput, usersUncheckedUpdateWithoutSubjectInput>
    create: XOR<usersCreateWithoutSubjectInput, usersUncheckedCreateWithoutSubjectInput>
  }

  export type usersUpdateWithoutSubjectInput = {
    image?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isSuperUser?: BoolFieldUpdateOperationsInput | boolean
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    exam?: examUpdateManyWithoutUsersNestedInput
    examDownloadable?: examDownloadableUpdateManyWithoutUsersNestedInput
    form?: formUpdateManyWithoutUsersNestedInput
    formExams?: formExamsUpdateManyWithoutUsersNestedInput
    formReference?: formReferenceUpdateManyWithoutUsersNestedInput
    formReview?: formReviewUpdateManyWithoutUsersNestedInput
    note?: noteUpdateManyWithoutUsersNestedInput
    notesDownloadable?: notesDownloadableUpdateManyWithoutUsersNestedInput
    purchase?: purchaseUpdateManyWithoutUsersNestedInput
    question?: questionUpdateManyWithoutUsersNestedInput
    reference?: referenceUpdateManyWithoutUsersNestedInput
    review?: reviewUpdateManyWithoutUsersNestedInput
    subjectExams?: subjectExamsUpdateManyWithoutUsersNestedInput
    subjectReference?: subjectReferenceUpdateManyWithoutUsersNestedInput
    subjectReview?: subjectReviewUpdateManyWithoutUsersNestedInput
    topic?: topicUpdateManyWithoutUsersNestedInput
    topicReview?: topicReviewUpdateManyWithoutUsersNestedInput
    vifurushi?: vifurushiUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutSubjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isSuperUser?: BoolFieldUpdateOperationsInput | boolean
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    exam?: examUncheckedUpdateManyWithoutUsersNestedInput
    examDownloadable?: examDownloadableUncheckedUpdateManyWithoutUsersNestedInput
    form?: formUncheckedUpdateManyWithoutUsersNestedInput
    formExams?: formExamsUncheckedUpdateManyWithoutUsersNestedInput
    formReference?: formReferenceUncheckedUpdateManyWithoutUsersNestedInput
    formReview?: formReviewUncheckedUpdateManyWithoutUsersNestedInput
    note?: noteUncheckedUpdateManyWithoutUsersNestedInput
    notesDownloadable?: notesDownloadableUncheckedUpdateManyWithoutUsersNestedInput
    purchase?: purchaseUncheckedUpdateManyWithoutUsersNestedInput
    question?: questionUncheckedUpdateManyWithoutUsersNestedInput
    reference?: referenceUncheckedUpdateManyWithoutUsersNestedInput
    review?: reviewUncheckedUpdateManyWithoutUsersNestedInput
    subjectExams?: subjectExamsUncheckedUpdateManyWithoutUsersNestedInput
    subjectReference?: subjectReferenceUncheckedUpdateManyWithoutUsersNestedInput
    subjectReview?: subjectReviewUncheckedUpdateManyWithoutUsersNestedInput
    topic?: topicUncheckedUpdateManyWithoutUsersNestedInput
    topicReview?: topicReviewUncheckedUpdateManyWithoutUsersNestedInput
    vifurushi?: vifurushiUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type noteUpsertWithWhereUniqueWithoutSubjectInput = {
    where: noteWhereUniqueInput
    update: XOR<noteUpdateWithoutSubjectInput, noteUncheckedUpdateWithoutSubjectInput>
    create: XOR<noteCreateWithoutSubjectInput, noteUncheckedCreateWithoutSubjectInput>
  }

  export type noteUpdateWithWhereUniqueWithoutSubjectInput = {
    where: noteWhereUniqueInput
    data: XOR<noteUpdateWithoutSubjectInput, noteUncheckedUpdateWithoutSubjectInput>
  }

  export type noteUpdateManyWithWhereWithoutSubjectInput = {
    where: noteScalarWhereInput
    data: XOR<noteUpdateManyMutationInput, noteUncheckedUpdateManyWithoutNoteInput>
  }

  export type notesDownloadableUpsertWithWhereUniqueWithoutSubjectInput = {
    where: notesDownloadableWhereUniqueInput
    update: XOR<notesDownloadableUpdateWithoutSubjectInput, notesDownloadableUncheckedUpdateWithoutSubjectInput>
    create: XOR<notesDownloadableCreateWithoutSubjectInput, notesDownloadableUncheckedCreateWithoutSubjectInput>
  }

  export type notesDownloadableUpdateWithWhereUniqueWithoutSubjectInput = {
    where: notesDownloadableWhereUniqueInput
    data: XOR<notesDownloadableUpdateWithoutSubjectInput, notesDownloadableUncheckedUpdateWithoutSubjectInput>
  }

  export type notesDownloadableUpdateManyWithWhereWithoutSubjectInput = {
    where: notesDownloadableScalarWhereInput
    data: XOR<notesDownloadableUpdateManyMutationInput, notesDownloadableUncheckedUpdateManyWithoutNotesDownloadableInput>
  }

  export type topicUpsertWithWhereUniqueWithoutSubjectInput = {
    where: topicWhereUniqueInput
    update: XOR<topicUpdateWithoutSubjectInput, topicUncheckedUpdateWithoutSubjectInput>
    create: XOR<topicCreateWithoutSubjectInput, topicUncheckedCreateWithoutSubjectInput>
  }

  export type topicUpdateWithWhereUniqueWithoutSubjectInput = {
    where: topicWhereUniqueInput
    data: XOR<topicUpdateWithoutSubjectInput, topicUncheckedUpdateWithoutSubjectInput>
  }

  export type topicUpdateManyWithWhereWithoutSubjectInput = {
    where: topicScalarWhereInput
    data: XOR<topicUpdateManyMutationInput, topicUncheckedUpdateManyWithoutTopicInput>
  }

  export type formUpsertWithWhereUniqueWithoutSubjectsInput = {
    where: formWhereUniqueInput
    update: XOR<formUpdateWithoutSubjectsInput, formUncheckedUpdateWithoutSubjectsInput>
    create: XOR<formCreateWithoutSubjectsInput, formUncheckedCreateWithoutSubjectsInput>
  }

  export type formUpdateWithWhereUniqueWithoutSubjectsInput = {
    where: formWhereUniqueInput
    data: XOR<formUpdateWithoutSubjectsInput, formUncheckedUpdateWithoutSubjectsInput>
  }

  export type formUpdateManyWithWhereWithoutSubjectsInput = {
    where: formScalarWhereInput
    data: XOR<formUpdateManyMutationInput, formUncheckedUpdateManyWithoutFormsInput>
  }

  export type usersCreateWithoutFormInput = {
    image?: string | null
    username: string
    password: string
    isAdmin?: boolean
    isSuperUser?: boolean
    dateJoined?: Date | string
    name: string
    updatedAt?: Date | string
    isOnline?: boolean
    exam?: examCreateNestedManyWithoutUsersInput
    examDownloadable?: examDownloadableCreateNestedManyWithoutUsersInput
    formExams?: formExamsCreateNestedManyWithoutUsersInput
    formReference?: formReferenceCreateNestedManyWithoutUsersInput
    formReview?: formReviewCreateNestedManyWithoutUsersInput
    note?: noteCreateNestedManyWithoutUsersInput
    notesDownloadable?: notesDownloadableCreateNestedManyWithoutUsersInput
    purchase?: purchaseCreateNestedManyWithoutUsersInput
    question?: questionCreateNestedManyWithoutUsersInput
    reference?: referenceCreateNestedManyWithoutUsersInput
    review?: reviewCreateNestedManyWithoutUsersInput
    subject?: subjectCreateNestedManyWithoutUsersInput
    subjectExams?: subjectExamsCreateNestedManyWithoutUsersInput
    subjectReference?: subjectReferenceCreateNestedManyWithoutUsersInput
    subjectReview?: subjectReviewCreateNestedManyWithoutUsersInput
    topic?: topicCreateNestedManyWithoutUsersInput
    topicReview?: topicReviewCreateNestedManyWithoutUsersInput
    vifurushi?: vifurushiCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutFormInput = {
    id?: number
    image?: string | null
    username: string
    password: string
    isAdmin?: boolean
    isSuperUser?: boolean
    dateJoined?: Date | string
    name: string
    updatedAt?: Date | string
    isOnline?: boolean
    exam?: examUncheckedCreateNestedManyWithoutUsersInput
    examDownloadable?: examDownloadableUncheckedCreateNestedManyWithoutUsersInput
    formExams?: formExamsUncheckedCreateNestedManyWithoutUsersInput
    formReference?: formReferenceUncheckedCreateNestedManyWithoutUsersInput
    formReview?: formReviewUncheckedCreateNestedManyWithoutUsersInput
    note?: noteUncheckedCreateNestedManyWithoutUsersInput
    notesDownloadable?: notesDownloadableUncheckedCreateNestedManyWithoutUsersInput
    purchase?: purchaseUncheckedCreateNestedManyWithoutUsersInput
    question?: questionUncheckedCreateNestedManyWithoutUsersInput
    reference?: referenceUncheckedCreateNestedManyWithoutUsersInput
    review?: reviewUncheckedCreateNestedManyWithoutUsersInput
    subject?: subjectUncheckedCreateNestedManyWithoutUsersInput
    subjectExams?: subjectExamsUncheckedCreateNestedManyWithoutUsersInput
    subjectReference?: subjectReferenceUncheckedCreateNestedManyWithoutUsersInput
    subjectReview?: subjectReviewUncheckedCreateNestedManyWithoutUsersInput
    topic?: topicUncheckedCreateNestedManyWithoutUsersInput
    topicReview?: topicReviewUncheckedCreateNestedManyWithoutUsersInput
    vifurushi?: vifurushiUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutFormInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutFormInput, usersUncheckedCreateWithoutFormInput>
  }

  export type noteCreateWithoutFormInput = {
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    published?: boolean
    subject: subjectCreateNestedOneWithoutNoteInput
    topic: topicCreateNestedOneWithoutNoteInput
    users: usersCreateNestedOneWithoutNoteInput
  }

  export type noteUncheckedCreateWithoutFormInput = {
    id?: number
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    published?: boolean
    subjectId: number
    usersId: number
    topicId: number
  }

  export type noteCreateOrConnectWithoutFormInput = {
    where: noteWhereUniqueInput
    create: XOR<noteCreateWithoutFormInput, noteUncheckedCreateWithoutFormInput>
  }

  export type noteCreateManyFormInputEnvelope = {
    data: Enumerable<noteCreateManyFormInput>
    skipDuplicates?: boolean
  }

  export type notesDownloadableCreateWithoutFormInput = {
    link: string
    fileExtension: string
    published?: boolean
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subject: subjectCreateNestedOneWithoutNotesDownloadableInput
    users: usersCreateNestedOneWithoutNotesDownloadableInput
  }

  export type notesDownloadableUncheckedCreateWithoutFormInput = {
    id?: number
    link: string
    fileExtension: string
    published?: boolean
    subjectId: number
    usersId: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type notesDownloadableCreateOrConnectWithoutFormInput = {
    where: notesDownloadableWhereUniqueInput
    create: XOR<notesDownloadableCreateWithoutFormInput, notesDownloadableUncheckedCreateWithoutFormInput>
  }

  export type notesDownloadableCreateManyFormInputEnvelope = {
    data: Enumerable<notesDownloadableCreateManyFormInput>
    skipDuplicates?: boolean
  }

  export type topicCreateWithoutFormInput = {
    topicName: string
    topicDefinition?: string | null
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    subject: subjectCreateNestedOneWithoutTopicInput
    users: usersCreateNestedOneWithoutTopicInput
    note?: noteCreateNestedOneWithoutTopicInput
  }

  export type topicUncheckedCreateWithoutFormInput = {
    id?: number
    topicName: string
    topicDefinition?: string | null
    published?: boolean
    subjectId: number
    usersId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    note?: noteUncheckedCreateNestedOneWithoutTopicInput
  }

  export type topicCreateOrConnectWithoutFormInput = {
    where: topicWhereUniqueInput
    create: XOR<topicCreateWithoutFormInput, topicUncheckedCreateWithoutFormInput>
  }

  export type topicCreateManyFormInputEnvelope = {
    data: Enumerable<topicCreateManyFormInput>
    skipDuplicates?: boolean
  }

  export type subjectCreateWithoutFormsInput = {
    subjectName: string
    subjectDefinition: string
    imageLocation?: string | null
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users: usersCreateNestedOneWithoutSubjectInput
    note?: noteCreateNestedManyWithoutSubjectInput
    notesDownloadable?: notesDownloadableCreateNestedManyWithoutSubjectInput
    topic?: topicCreateNestedManyWithoutSubjectInput
  }

  export type subjectUncheckedCreateWithoutFormsInput = {
    id?: number
    subjectName: string
    subjectDefinition: string
    imageLocation?: string | null
    published?: boolean
    usersId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    note?: noteUncheckedCreateNestedManyWithoutSubjectInput
    notesDownloadable?: notesDownloadableUncheckedCreateNestedManyWithoutSubjectInput
    topic?: topicUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type subjectCreateOrConnectWithoutFormsInput = {
    where: subjectWhereUniqueInput
    create: XOR<subjectCreateWithoutFormsInput, subjectUncheckedCreateWithoutFormsInput>
  }

  export type usersUpsertWithoutFormInput = {
    update: XOR<usersUpdateWithoutFormInput, usersUncheckedUpdateWithoutFormInput>
    create: XOR<usersCreateWithoutFormInput, usersUncheckedCreateWithoutFormInput>
  }

  export type usersUpdateWithoutFormInput = {
    image?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isSuperUser?: BoolFieldUpdateOperationsInput | boolean
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    exam?: examUpdateManyWithoutUsersNestedInput
    examDownloadable?: examDownloadableUpdateManyWithoutUsersNestedInput
    formExams?: formExamsUpdateManyWithoutUsersNestedInput
    formReference?: formReferenceUpdateManyWithoutUsersNestedInput
    formReview?: formReviewUpdateManyWithoutUsersNestedInput
    note?: noteUpdateManyWithoutUsersNestedInput
    notesDownloadable?: notesDownloadableUpdateManyWithoutUsersNestedInput
    purchase?: purchaseUpdateManyWithoutUsersNestedInput
    question?: questionUpdateManyWithoutUsersNestedInput
    reference?: referenceUpdateManyWithoutUsersNestedInput
    review?: reviewUpdateManyWithoutUsersNestedInput
    subject?: subjectUpdateManyWithoutUsersNestedInput
    subjectExams?: subjectExamsUpdateManyWithoutUsersNestedInput
    subjectReference?: subjectReferenceUpdateManyWithoutUsersNestedInput
    subjectReview?: subjectReviewUpdateManyWithoutUsersNestedInput
    topic?: topicUpdateManyWithoutUsersNestedInput
    topicReview?: topicReviewUpdateManyWithoutUsersNestedInput
    vifurushi?: vifurushiUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutFormInput = {
    id?: IntFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isSuperUser?: BoolFieldUpdateOperationsInput | boolean
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    exam?: examUncheckedUpdateManyWithoutUsersNestedInput
    examDownloadable?: examDownloadableUncheckedUpdateManyWithoutUsersNestedInput
    formExams?: formExamsUncheckedUpdateManyWithoutUsersNestedInput
    formReference?: formReferenceUncheckedUpdateManyWithoutUsersNestedInput
    formReview?: formReviewUncheckedUpdateManyWithoutUsersNestedInput
    note?: noteUncheckedUpdateManyWithoutUsersNestedInput
    notesDownloadable?: notesDownloadableUncheckedUpdateManyWithoutUsersNestedInput
    purchase?: purchaseUncheckedUpdateManyWithoutUsersNestedInput
    question?: questionUncheckedUpdateManyWithoutUsersNestedInput
    reference?: referenceUncheckedUpdateManyWithoutUsersNestedInput
    review?: reviewUncheckedUpdateManyWithoutUsersNestedInput
    subject?: subjectUncheckedUpdateManyWithoutUsersNestedInput
    subjectExams?: subjectExamsUncheckedUpdateManyWithoutUsersNestedInput
    subjectReference?: subjectReferenceUncheckedUpdateManyWithoutUsersNestedInput
    subjectReview?: subjectReviewUncheckedUpdateManyWithoutUsersNestedInput
    topic?: topicUncheckedUpdateManyWithoutUsersNestedInput
    topicReview?: topicReviewUncheckedUpdateManyWithoutUsersNestedInput
    vifurushi?: vifurushiUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type noteUpsertWithWhereUniqueWithoutFormInput = {
    where: noteWhereUniqueInput
    update: XOR<noteUpdateWithoutFormInput, noteUncheckedUpdateWithoutFormInput>
    create: XOR<noteCreateWithoutFormInput, noteUncheckedCreateWithoutFormInput>
  }

  export type noteUpdateWithWhereUniqueWithoutFormInput = {
    where: noteWhereUniqueInput
    data: XOR<noteUpdateWithoutFormInput, noteUncheckedUpdateWithoutFormInput>
  }

  export type noteUpdateManyWithWhereWithoutFormInput = {
    where: noteScalarWhereInput
    data: XOR<noteUpdateManyMutationInput, noteUncheckedUpdateManyWithoutNoteInput>
  }

  export type notesDownloadableUpsertWithWhereUniqueWithoutFormInput = {
    where: notesDownloadableWhereUniqueInput
    update: XOR<notesDownloadableUpdateWithoutFormInput, notesDownloadableUncheckedUpdateWithoutFormInput>
    create: XOR<notesDownloadableCreateWithoutFormInput, notesDownloadableUncheckedCreateWithoutFormInput>
  }

  export type notesDownloadableUpdateWithWhereUniqueWithoutFormInput = {
    where: notesDownloadableWhereUniqueInput
    data: XOR<notesDownloadableUpdateWithoutFormInput, notesDownloadableUncheckedUpdateWithoutFormInput>
  }

  export type notesDownloadableUpdateManyWithWhereWithoutFormInput = {
    where: notesDownloadableScalarWhereInput
    data: XOR<notesDownloadableUpdateManyMutationInput, notesDownloadableUncheckedUpdateManyWithoutNotesDownloadableInput>
  }

  export type topicUpsertWithWhereUniqueWithoutFormInput = {
    where: topicWhereUniqueInput
    update: XOR<topicUpdateWithoutFormInput, topicUncheckedUpdateWithoutFormInput>
    create: XOR<topicCreateWithoutFormInput, topicUncheckedCreateWithoutFormInput>
  }

  export type topicUpdateWithWhereUniqueWithoutFormInput = {
    where: topicWhereUniqueInput
    data: XOR<topicUpdateWithoutFormInput, topicUncheckedUpdateWithoutFormInput>
  }

  export type topicUpdateManyWithWhereWithoutFormInput = {
    where: topicScalarWhereInput
    data: XOR<topicUpdateManyMutationInput, topicUncheckedUpdateManyWithoutTopicInput>
  }

  export type subjectUpsertWithWhereUniqueWithoutFormsInput = {
    where: subjectWhereUniqueInput
    update: XOR<subjectUpdateWithoutFormsInput, subjectUncheckedUpdateWithoutFormsInput>
    create: XOR<subjectCreateWithoutFormsInput, subjectUncheckedCreateWithoutFormsInput>
  }

  export type subjectUpdateWithWhereUniqueWithoutFormsInput = {
    where: subjectWhereUniqueInput
    data: XOR<subjectUpdateWithoutFormsInput, subjectUncheckedUpdateWithoutFormsInput>
  }

  export type subjectUpdateManyWithWhereWithoutFormsInput = {
    where: subjectScalarWhereInput
    data: XOR<subjectUpdateManyMutationInput, subjectUncheckedUpdateManyWithoutSubjectsInput>
  }

  export type formCreateWithoutTopicInput = {
    formName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users: usersCreateNestedOneWithoutFormInput
    note?: noteCreateNestedManyWithoutFormInput
    notesDownloadable?: notesDownloadableCreateNestedManyWithoutFormInput
    subjects?: subjectCreateNestedManyWithoutFormsInput
  }

  export type formUncheckedCreateWithoutTopicInput = {
    id?: number
    formName: string
    usersId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    note?: noteUncheckedCreateNestedManyWithoutFormInput
    notesDownloadable?: notesDownloadableUncheckedCreateNestedManyWithoutFormInput
    subjects?: subjectUncheckedCreateNestedManyWithoutFormsInput
  }

  export type formCreateOrConnectWithoutTopicInput = {
    where: formWhereUniqueInput
    create: XOR<formCreateWithoutTopicInput, formUncheckedCreateWithoutTopicInput>
  }

  export type subjectCreateWithoutTopicInput = {
    subjectName: string
    subjectDefinition: string
    imageLocation?: string | null
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users: usersCreateNestedOneWithoutSubjectInput
    note?: noteCreateNestedManyWithoutSubjectInput
    notesDownloadable?: notesDownloadableCreateNestedManyWithoutSubjectInput
    forms?: formCreateNestedManyWithoutSubjectsInput
  }

  export type subjectUncheckedCreateWithoutTopicInput = {
    id?: number
    subjectName: string
    subjectDefinition: string
    imageLocation?: string | null
    published?: boolean
    usersId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    note?: noteUncheckedCreateNestedManyWithoutSubjectInput
    notesDownloadable?: notesDownloadableUncheckedCreateNestedManyWithoutSubjectInput
    forms?: formUncheckedCreateNestedManyWithoutSubjectsInput
  }

  export type subjectCreateOrConnectWithoutTopicInput = {
    where: subjectWhereUniqueInput
    create: XOR<subjectCreateWithoutTopicInput, subjectUncheckedCreateWithoutTopicInput>
  }

  export type usersCreateWithoutTopicInput = {
    image?: string | null
    username: string
    password: string
    isAdmin?: boolean
    isSuperUser?: boolean
    dateJoined?: Date | string
    name: string
    updatedAt?: Date | string
    isOnline?: boolean
    exam?: examCreateNestedManyWithoutUsersInput
    examDownloadable?: examDownloadableCreateNestedManyWithoutUsersInput
    form?: formCreateNestedManyWithoutUsersInput
    formExams?: formExamsCreateNestedManyWithoutUsersInput
    formReference?: formReferenceCreateNestedManyWithoutUsersInput
    formReview?: formReviewCreateNestedManyWithoutUsersInput
    note?: noteCreateNestedManyWithoutUsersInput
    notesDownloadable?: notesDownloadableCreateNestedManyWithoutUsersInput
    purchase?: purchaseCreateNestedManyWithoutUsersInput
    question?: questionCreateNestedManyWithoutUsersInput
    reference?: referenceCreateNestedManyWithoutUsersInput
    review?: reviewCreateNestedManyWithoutUsersInput
    subject?: subjectCreateNestedManyWithoutUsersInput
    subjectExams?: subjectExamsCreateNestedManyWithoutUsersInput
    subjectReference?: subjectReferenceCreateNestedManyWithoutUsersInput
    subjectReview?: subjectReviewCreateNestedManyWithoutUsersInput
    topicReview?: topicReviewCreateNestedManyWithoutUsersInput
    vifurushi?: vifurushiCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutTopicInput = {
    id?: number
    image?: string | null
    username: string
    password: string
    isAdmin?: boolean
    isSuperUser?: boolean
    dateJoined?: Date | string
    name: string
    updatedAt?: Date | string
    isOnline?: boolean
    exam?: examUncheckedCreateNestedManyWithoutUsersInput
    examDownloadable?: examDownloadableUncheckedCreateNestedManyWithoutUsersInput
    form?: formUncheckedCreateNestedManyWithoutUsersInput
    formExams?: formExamsUncheckedCreateNestedManyWithoutUsersInput
    formReference?: formReferenceUncheckedCreateNestedManyWithoutUsersInput
    formReview?: formReviewUncheckedCreateNestedManyWithoutUsersInput
    note?: noteUncheckedCreateNestedManyWithoutUsersInput
    notesDownloadable?: notesDownloadableUncheckedCreateNestedManyWithoutUsersInput
    purchase?: purchaseUncheckedCreateNestedManyWithoutUsersInput
    question?: questionUncheckedCreateNestedManyWithoutUsersInput
    reference?: referenceUncheckedCreateNestedManyWithoutUsersInput
    review?: reviewUncheckedCreateNestedManyWithoutUsersInput
    subject?: subjectUncheckedCreateNestedManyWithoutUsersInput
    subjectExams?: subjectExamsUncheckedCreateNestedManyWithoutUsersInput
    subjectReference?: subjectReferenceUncheckedCreateNestedManyWithoutUsersInput
    subjectReview?: subjectReviewUncheckedCreateNestedManyWithoutUsersInput
    topicReview?: topicReviewUncheckedCreateNestedManyWithoutUsersInput
    vifurushi?: vifurushiUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutTopicInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutTopicInput, usersUncheckedCreateWithoutTopicInput>
  }

  export type noteCreateWithoutTopicInput = {
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    published?: boolean
    form: formCreateNestedOneWithoutNoteInput
    subject: subjectCreateNestedOneWithoutNoteInput
    users: usersCreateNestedOneWithoutNoteInput
  }

  export type noteUncheckedCreateWithoutTopicInput = {
    id?: number
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    published?: boolean
    subjectId: number
    formId: number
    usersId: number
  }

  export type noteCreateOrConnectWithoutTopicInput = {
    where: noteWhereUniqueInput
    create: XOR<noteCreateWithoutTopicInput, noteUncheckedCreateWithoutTopicInput>
  }

  export type formUpsertWithoutTopicInput = {
    update: XOR<formUpdateWithoutTopicInput, formUncheckedUpdateWithoutTopicInput>
    create: XOR<formCreateWithoutTopicInput, formUncheckedCreateWithoutTopicInput>
  }

  export type formUpdateWithoutTopicInput = {
    formName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutFormNestedInput
    note?: noteUpdateManyWithoutFormNestedInput
    notesDownloadable?: notesDownloadableUpdateManyWithoutFormNestedInput
    subjects?: subjectUpdateManyWithoutFormsNestedInput
  }

  export type formUncheckedUpdateWithoutTopicInput = {
    id?: IntFieldUpdateOperationsInput | number
    formName?: StringFieldUpdateOperationsInput | string
    usersId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: noteUncheckedUpdateManyWithoutFormNestedInput
    notesDownloadable?: notesDownloadableUncheckedUpdateManyWithoutFormNestedInput
    subjects?: subjectUncheckedUpdateManyWithoutFormsNestedInput
  }

  export type subjectUpsertWithoutTopicInput = {
    update: XOR<subjectUpdateWithoutTopicInput, subjectUncheckedUpdateWithoutTopicInput>
    create: XOR<subjectCreateWithoutTopicInput, subjectUncheckedCreateWithoutTopicInput>
  }

  export type subjectUpdateWithoutTopicInput = {
    subjectName?: StringFieldUpdateOperationsInput | string
    subjectDefinition?: StringFieldUpdateOperationsInput | string
    imageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutSubjectNestedInput
    note?: noteUpdateManyWithoutSubjectNestedInput
    notesDownloadable?: notesDownloadableUpdateManyWithoutSubjectNestedInput
    forms?: formUpdateManyWithoutSubjectsNestedInput
  }

  export type subjectUncheckedUpdateWithoutTopicInput = {
    id?: IntFieldUpdateOperationsInput | number
    subjectName?: StringFieldUpdateOperationsInput | string
    subjectDefinition?: StringFieldUpdateOperationsInput | string
    imageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    usersId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: noteUncheckedUpdateManyWithoutSubjectNestedInput
    notesDownloadable?: notesDownloadableUncheckedUpdateManyWithoutSubjectNestedInput
    forms?: formUncheckedUpdateManyWithoutSubjectsNestedInput
  }

  export type usersUpsertWithoutTopicInput = {
    update: XOR<usersUpdateWithoutTopicInput, usersUncheckedUpdateWithoutTopicInput>
    create: XOR<usersCreateWithoutTopicInput, usersUncheckedCreateWithoutTopicInput>
  }

  export type usersUpdateWithoutTopicInput = {
    image?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isSuperUser?: BoolFieldUpdateOperationsInput | boolean
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    exam?: examUpdateManyWithoutUsersNestedInput
    examDownloadable?: examDownloadableUpdateManyWithoutUsersNestedInput
    form?: formUpdateManyWithoutUsersNestedInput
    formExams?: formExamsUpdateManyWithoutUsersNestedInput
    formReference?: formReferenceUpdateManyWithoutUsersNestedInput
    formReview?: formReviewUpdateManyWithoutUsersNestedInput
    note?: noteUpdateManyWithoutUsersNestedInput
    notesDownloadable?: notesDownloadableUpdateManyWithoutUsersNestedInput
    purchase?: purchaseUpdateManyWithoutUsersNestedInput
    question?: questionUpdateManyWithoutUsersNestedInput
    reference?: referenceUpdateManyWithoutUsersNestedInput
    review?: reviewUpdateManyWithoutUsersNestedInput
    subject?: subjectUpdateManyWithoutUsersNestedInput
    subjectExams?: subjectExamsUpdateManyWithoutUsersNestedInput
    subjectReference?: subjectReferenceUpdateManyWithoutUsersNestedInput
    subjectReview?: subjectReviewUpdateManyWithoutUsersNestedInput
    topicReview?: topicReviewUpdateManyWithoutUsersNestedInput
    vifurushi?: vifurushiUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutTopicInput = {
    id?: IntFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isSuperUser?: BoolFieldUpdateOperationsInput | boolean
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    exam?: examUncheckedUpdateManyWithoutUsersNestedInput
    examDownloadable?: examDownloadableUncheckedUpdateManyWithoutUsersNestedInput
    form?: formUncheckedUpdateManyWithoutUsersNestedInput
    formExams?: formExamsUncheckedUpdateManyWithoutUsersNestedInput
    formReference?: formReferenceUncheckedUpdateManyWithoutUsersNestedInput
    formReview?: formReviewUncheckedUpdateManyWithoutUsersNestedInput
    note?: noteUncheckedUpdateManyWithoutUsersNestedInput
    notesDownloadable?: notesDownloadableUncheckedUpdateManyWithoutUsersNestedInput
    purchase?: purchaseUncheckedUpdateManyWithoutUsersNestedInput
    question?: questionUncheckedUpdateManyWithoutUsersNestedInput
    reference?: referenceUncheckedUpdateManyWithoutUsersNestedInput
    review?: reviewUncheckedUpdateManyWithoutUsersNestedInput
    subject?: subjectUncheckedUpdateManyWithoutUsersNestedInput
    subjectExams?: subjectExamsUncheckedUpdateManyWithoutUsersNestedInput
    subjectReference?: subjectReferenceUncheckedUpdateManyWithoutUsersNestedInput
    subjectReview?: subjectReviewUncheckedUpdateManyWithoutUsersNestedInput
    topicReview?: topicReviewUncheckedUpdateManyWithoutUsersNestedInput
    vifurushi?: vifurushiUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type noteUpsertWithoutTopicInput = {
    update: XOR<noteUpdateWithoutTopicInput, noteUncheckedUpdateWithoutTopicInput>
    create: XOR<noteCreateWithoutTopicInput, noteUncheckedCreateWithoutTopicInput>
  }

  export type noteUpdateWithoutTopicInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    published?: BoolFieldUpdateOperationsInput | boolean
    form?: formUpdateOneRequiredWithoutNoteNestedInput
    subject?: subjectUpdateOneRequiredWithoutNoteNestedInput
    users?: usersUpdateOneRequiredWithoutNoteNestedInput
  }

  export type noteUncheckedUpdateWithoutTopicInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    published?: BoolFieldUpdateOperationsInput | boolean
    subjectId?: IntFieldUpdateOperationsInput | number
    formId?: IntFieldUpdateOperationsInput | number
    usersId?: IntFieldUpdateOperationsInput | number
  }

  export type formCreateWithoutNoteInput = {
    formName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users: usersCreateNestedOneWithoutFormInput
    notesDownloadable?: notesDownloadableCreateNestedManyWithoutFormInput
    topic?: topicCreateNestedManyWithoutFormInput
    subjects?: subjectCreateNestedManyWithoutFormsInput
  }

  export type formUncheckedCreateWithoutNoteInput = {
    id?: number
    formName: string
    usersId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    notesDownloadable?: notesDownloadableUncheckedCreateNestedManyWithoutFormInput
    topic?: topicUncheckedCreateNestedManyWithoutFormInput
    subjects?: subjectUncheckedCreateNestedManyWithoutFormsInput
  }

  export type formCreateOrConnectWithoutNoteInput = {
    where: formWhereUniqueInput
    create: XOR<formCreateWithoutNoteInput, formUncheckedCreateWithoutNoteInput>
  }

  export type subjectCreateWithoutNoteInput = {
    subjectName: string
    subjectDefinition: string
    imageLocation?: string | null
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users: usersCreateNestedOneWithoutSubjectInput
    notesDownloadable?: notesDownloadableCreateNestedManyWithoutSubjectInput
    topic?: topicCreateNestedManyWithoutSubjectInput
    forms?: formCreateNestedManyWithoutSubjectsInput
  }

  export type subjectUncheckedCreateWithoutNoteInput = {
    id?: number
    subjectName: string
    subjectDefinition: string
    imageLocation?: string | null
    published?: boolean
    usersId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    notesDownloadable?: notesDownloadableUncheckedCreateNestedManyWithoutSubjectInput
    topic?: topicUncheckedCreateNestedManyWithoutSubjectInput
    forms?: formUncheckedCreateNestedManyWithoutSubjectsInput
  }

  export type subjectCreateOrConnectWithoutNoteInput = {
    where: subjectWhereUniqueInput
    create: XOR<subjectCreateWithoutNoteInput, subjectUncheckedCreateWithoutNoteInput>
  }

  export type topicCreateWithoutNoteInput = {
    topicName: string
    topicDefinition?: string | null
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    form: formCreateNestedOneWithoutTopicInput
    subject: subjectCreateNestedOneWithoutTopicInput
    users: usersCreateNestedOneWithoutTopicInput
  }

  export type topicUncheckedCreateWithoutNoteInput = {
    id?: number
    topicName: string
    topicDefinition?: string | null
    published?: boolean
    subjectId: number
    formId: number
    usersId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type topicCreateOrConnectWithoutNoteInput = {
    where: topicWhereUniqueInput
    create: XOR<topicCreateWithoutNoteInput, topicUncheckedCreateWithoutNoteInput>
  }

  export type usersCreateWithoutNoteInput = {
    image?: string | null
    username: string
    password: string
    isAdmin?: boolean
    isSuperUser?: boolean
    dateJoined?: Date | string
    name: string
    updatedAt?: Date | string
    isOnline?: boolean
    exam?: examCreateNestedManyWithoutUsersInput
    examDownloadable?: examDownloadableCreateNestedManyWithoutUsersInput
    form?: formCreateNestedManyWithoutUsersInput
    formExams?: formExamsCreateNestedManyWithoutUsersInput
    formReference?: formReferenceCreateNestedManyWithoutUsersInput
    formReview?: formReviewCreateNestedManyWithoutUsersInput
    notesDownloadable?: notesDownloadableCreateNestedManyWithoutUsersInput
    purchase?: purchaseCreateNestedManyWithoutUsersInput
    question?: questionCreateNestedManyWithoutUsersInput
    reference?: referenceCreateNestedManyWithoutUsersInput
    review?: reviewCreateNestedManyWithoutUsersInput
    subject?: subjectCreateNestedManyWithoutUsersInput
    subjectExams?: subjectExamsCreateNestedManyWithoutUsersInput
    subjectReference?: subjectReferenceCreateNestedManyWithoutUsersInput
    subjectReview?: subjectReviewCreateNestedManyWithoutUsersInput
    topic?: topicCreateNestedManyWithoutUsersInput
    topicReview?: topicReviewCreateNestedManyWithoutUsersInput
    vifurushi?: vifurushiCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutNoteInput = {
    id?: number
    image?: string | null
    username: string
    password: string
    isAdmin?: boolean
    isSuperUser?: boolean
    dateJoined?: Date | string
    name: string
    updatedAt?: Date | string
    isOnline?: boolean
    exam?: examUncheckedCreateNestedManyWithoutUsersInput
    examDownloadable?: examDownloadableUncheckedCreateNestedManyWithoutUsersInput
    form?: formUncheckedCreateNestedManyWithoutUsersInput
    formExams?: formExamsUncheckedCreateNestedManyWithoutUsersInput
    formReference?: formReferenceUncheckedCreateNestedManyWithoutUsersInput
    formReview?: formReviewUncheckedCreateNestedManyWithoutUsersInput
    notesDownloadable?: notesDownloadableUncheckedCreateNestedManyWithoutUsersInput
    purchase?: purchaseUncheckedCreateNestedManyWithoutUsersInput
    question?: questionUncheckedCreateNestedManyWithoutUsersInput
    reference?: referenceUncheckedCreateNestedManyWithoutUsersInput
    review?: reviewUncheckedCreateNestedManyWithoutUsersInput
    subject?: subjectUncheckedCreateNestedManyWithoutUsersInput
    subjectExams?: subjectExamsUncheckedCreateNestedManyWithoutUsersInput
    subjectReference?: subjectReferenceUncheckedCreateNestedManyWithoutUsersInput
    subjectReview?: subjectReviewUncheckedCreateNestedManyWithoutUsersInput
    topic?: topicUncheckedCreateNestedManyWithoutUsersInput
    topicReview?: topicReviewUncheckedCreateNestedManyWithoutUsersInput
    vifurushi?: vifurushiUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutNoteInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutNoteInput, usersUncheckedCreateWithoutNoteInput>
  }

  export type formUpsertWithoutNoteInput = {
    update: XOR<formUpdateWithoutNoteInput, formUncheckedUpdateWithoutNoteInput>
    create: XOR<formCreateWithoutNoteInput, formUncheckedCreateWithoutNoteInput>
  }

  export type formUpdateWithoutNoteInput = {
    formName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutFormNestedInput
    notesDownloadable?: notesDownloadableUpdateManyWithoutFormNestedInput
    topic?: topicUpdateManyWithoutFormNestedInput
    subjects?: subjectUpdateManyWithoutFormsNestedInput
  }

  export type formUncheckedUpdateWithoutNoteInput = {
    id?: IntFieldUpdateOperationsInput | number
    formName?: StringFieldUpdateOperationsInput | string
    usersId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notesDownloadable?: notesDownloadableUncheckedUpdateManyWithoutFormNestedInput
    topic?: topicUncheckedUpdateManyWithoutFormNestedInput
    subjects?: subjectUncheckedUpdateManyWithoutFormsNestedInput
  }

  export type subjectUpsertWithoutNoteInput = {
    update: XOR<subjectUpdateWithoutNoteInput, subjectUncheckedUpdateWithoutNoteInput>
    create: XOR<subjectCreateWithoutNoteInput, subjectUncheckedCreateWithoutNoteInput>
  }

  export type subjectUpdateWithoutNoteInput = {
    subjectName?: StringFieldUpdateOperationsInput | string
    subjectDefinition?: StringFieldUpdateOperationsInput | string
    imageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutSubjectNestedInput
    notesDownloadable?: notesDownloadableUpdateManyWithoutSubjectNestedInput
    topic?: topicUpdateManyWithoutSubjectNestedInput
    forms?: formUpdateManyWithoutSubjectsNestedInput
  }

  export type subjectUncheckedUpdateWithoutNoteInput = {
    id?: IntFieldUpdateOperationsInput | number
    subjectName?: StringFieldUpdateOperationsInput | string
    subjectDefinition?: StringFieldUpdateOperationsInput | string
    imageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    usersId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notesDownloadable?: notesDownloadableUncheckedUpdateManyWithoutSubjectNestedInput
    topic?: topicUncheckedUpdateManyWithoutSubjectNestedInput
    forms?: formUncheckedUpdateManyWithoutSubjectsNestedInput
  }

  export type topicUpsertWithoutNoteInput = {
    update: XOR<topicUpdateWithoutNoteInput, topicUncheckedUpdateWithoutNoteInput>
    create: XOR<topicCreateWithoutNoteInput, topicUncheckedCreateWithoutNoteInput>
  }

  export type topicUpdateWithoutNoteInput = {
    topicName?: StringFieldUpdateOperationsInput | string
    topicDefinition?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    form?: formUpdateOneRequiredWithoutTopicNestedInput
    subject?: subjectUpdateOneRequiredWithoutTopicNestedInput
    users?: usersUpdateOneRequiredWithoutTopicNestedInput
  }

  export type topicUncheckedUpdateWithoutNoteInput = {
    id?: IntFieldUpdateOperationsInput | number
    topicName?: StringFieldUpdateOperationsInput | string
    topicDefinition?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    subjectId?: IntFieldUpdateOperationsInput | number
    formId?: IntFieldUpdateOperationsInput | number
    usersId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersUpsertWithoutNoteInput = {
    update: XOR<usersUpdateWithoutNoteInput, usersUncheckedUpdateWithoutNoteInput>
    create: XOR<usersCreateWithoutNoteInput, usersUncheckedCreateWithoutNoteInput>
  }

  export type usersUpdateWithoutNoteInput = {
    image?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isSuperUser?: BoolFieldUpdateOperationsInput | boolean
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    exam?: examUpdateManyWithoutUsersNestedInput
    examDownloadable?: examDownloadableUpdateManyWithoutUsersNestedInput
    form?: formUpdateManyWithoutUsersNestedInput
    formExams?: formExamsUpdateManyWithoutUsersNestedInput
    formReference?: formReferenceUpdateManyWithoutUsersNestedInput
    formReview?: formReviewUpdateManyWithoutUsersNestedInput
    notesDownloadable?: notesDownloadableUpdateManyWithoutUsersNestedInput
    purchase?: purchaseUpdateManyWithoutUsersNestedInput
    question?: questionUpdateManyWithoutUsersNestedInput
    reference?: referenceUpdateManyWithoutUsersNestedInput
    review?: reviewUpdateManyWithoutUsersNestedInput
    subject?: subjectUpdateManyWithoutUsersNestedInput
    subjectExams?: subjectExamsUpdateManyWithoutUsersNestedInput
    subjectReference?: subjectReferenceUpdateManyWithoutUsersNestedInput
    subjectReview?: subjectReviewUpdateManyWithoutUsersNestedInput
    topic?: topicUpdateManyWithoutUsersNestedInput
    topicReview?: topicReviewUpdateManyWithoutUsersNestedInput
    vifurushi?: vifurushiUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutNoteInput = {
    id?: IntFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isSuperUser?: BoolFieldUpdateOperationsInput | boolean
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    exam?: examUncheckedUpdateManyWithoutUsersNestedInput
    examDownloadable?: examDownloadableUncheckedUpdateManyWithoutUsersNestedInput
    form?: formUncheckedUpdateManyWithoutUsersNestedInput
    formExams?: formExamsUncheckedUpdateManyWithoutUsersNestedInput
    formReference?: formReferenceUncheckedUpdateManyWithoutUsersNestedInput
    formReview?: formReviewUncheckedUpdateManyWithoutUsersNestedInput
    notesDownloadable?: notesDownloadableUncheckedUpdateManyWithoutUsersNestedInput
    purchase?: purchaseUncheckedUpdateManyWithoutUsersNestedInput
    question?: questionUncheckedUpdateManyWithoutUsersNestedInput
    reference?: referenceUncheckedUpdateManyWithoutUsersNestedInput
    review?: reviewUncheckedUpdateManyWithoutUsersNestedInput
    subject?: subjectUncheckedUpdateManyWithoutUsersNestedInput
    subjectExams?: subjectExamsUncheckedUpdateManyWithoutUsersNestedInput
    subjectReference?: subjectReferenceUncheckedUpdateManyWithoutUsersNestedInput
    subjectReview?: subjectReviewUncheckedUpdateManyWithoutUsersNestedInput
    topic?: topicUncheckedUpdateManyWithoutUsersNestedInput
    topicReview?: topicReviewUncheckedUpdateManyWithoutUsersNestedInput
    vifurushi?: vifurushiUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type formCreateWithoutNotesDownloadableInput = {
    formName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users: usersCreateNestedOneWithoutFormInput
    note?: noteCreateNestedManyWithoutFormInput
    topic?: topicCreateNestedManyWithoutFormInput
    subjects?: subjectCreateNestedManyWithoutFormsInput
  }

  export type formUncheckedCreateWithoutNotesDownloadableInput = {
    id?: number
    formName: string
    usersId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    note?: noteUncheckedCreateNestedManyWithoutFormInput
    topic?: topicUncheckedCreateNestedManyWithoutFormInput
    subjects?: subjectUncheckedCreateNestedManyWithoutFormsInput
  }

  export type formCreateOrConnectWithoutNotesDownloadableInput = {
    where: formWhereUniqueInput
    create: XOR<formCreateWithoutNotesDownloadableInput, formUncheckedCreateWithoutNotesDownloadableInput>
  }

  export type subjectCreateWithoutNotesDownloadableInput = {
    subjectName: string
    subjectDefinition: string
    imageLocation?: string | null
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users: usersCreateNestedOneWithoutSubjectInput
    note?: noteCreateNestedManyWithoutSubjectInput
    topic?: topicCreateNestedManyWithoutSubjectInput
    forms?: formCreateNestedManyWithoutSubjectsInput
  }

  export type subjectUncheckedCreateWithoutNotesDownloadableInput = {
    id?: number
    subjectName: string
    subjectDefinition: string
    imageLocation?: string | null
    published?: boolean
    usersId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    note?: noteUncheckedCreateNestedManyWithoutSubjectInput
    topic?: topicUncheckedCreateNestedManyWithoutSubjectInput
    forms?: formUncheckedCreateNestedManyWithoutSubjectsInput
  }

  export type subjectCreateOrConnectWithoutNotesDownloadableInput = {
    where: subjectWhereUniqueInput
    create: XOR<subjectCreateWithoutNotesDownloadableInput, subjectUncheckedCreateWithoutNotesDownloadableInput>
  }

  export type usersCreateWithoutNotesDownloadableInput = {
    image?: string | null
    username: string
    password: string
    isAdmin?: boolean
    isSuperUser?: boolean
    dateJoined?: Date | string
    name: string
    updatedAt?: Date | string
    isOnline?: boolean
    exam?: examCreateNestedManyWithoutUsersInput
    examDownloadable?: examDownloadableCreateNestedManyWithoutUsersInput
    form?: formCreateNestedManyWithoutUsersInput
    formExams?: formExamsCreateNestedManyWithoutUsersInput
    formReference?: formReferenceCreateNestedManyWithoutUsersInput
    formReview?: formReviewCreateNestedManyWithoutUsersInput
    note?: noteCreateNestedManyWithoutUsersInput
    purchase?: purchaseCreateNestedManyWithoutUsersInput
    question?: questionCreateNestedManyWithoutUsersInput
    reference?: referenceCreateNestedManyWithoutUsersInput
    review?: reviewCreateNestedManyWithoutUsersInput
    subject?: subjectCreateNestedManyWithoutUsersInput
    subjectExams?: subjectExamsCreateNestedManyWithoutUsersInput
    subjectReference?: subjectReferenceCreateNestedManyWithoutUsersInput
    subjectReview?: subjectReviewCreateNestedManyWithoutUsersInput
    topic?: topicCreateNestedManyWithoutUsersInput
    topicReview?: topicReviewCreateNestedManyWithoutUsersInput
    vifurushi?: vifurushiCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutNotesDownloadableInput = {
    id?: number
    image?: string | null
    username: string
    password: string
    isAdmin?: boolean
    isSuperUser?: boolean
    dateJoined?: Date | string
    name: string
    updatedAt?: Date | string
    isOnline?: boolean
    exam?: examUncheckedCreateNestedManyWithoutUsersInput
    examDownloadable?: examDownloadableUncheckedCreateNestedManyWithoutUsersInput
    form?: formUncheckedCreateNestedManyWithoutUsersInput
    formExams?: formExamsUncheckedCreateNestedManyWithoutUsersInput
    formReference?: formReferenceUncheckedCreateNestedManyWithoutUsersInput
    formReview?: formReviewUncheckedCreateNestedManyWithoutUsersInput
    note?: noteUncheckedCreateNestedManyWithoutUsersInput
    purchase?: purchaseUncheckedCreateNestedManyWithoutUsersInput
    question?: questionUncheckedCreateNestedManyWithoutUsersInput
    reference?: referenceUncheckedCreateNestedManyWithoutUsersInput
    review?: reviewUncheckedCreateNestedManyWithoutUsersInput
    subject?: subjectUncheckedCreateNestedManyWithoutUsersInput
    subjectExams?: subjectExamsUncheckedCreateNestedManyWithoutUsersInput
    subjectReference?: subjectReferenceUncheckedCreateNestedManyWithoutUsersInput
    subjectReview?: subjectReviewUncheckedCreateNestedManyWithoutUsersInput
    topic?: topicUncheckedCreateNestedManyWithoutUsersInput
    topicReview?: topicReviewUncheckedCreateNestedManyWithoutUsersInput
    vifurushi?: vifurushiUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutNotesDownloadableInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutNotesDownloadableInput, usersUncheckedCreateWithoutNotesDownloadableInput>
  }

  export type formUpsertWithoutNotesDownloadableInput = {
    update: XOR<formUpdateWithoutNotesDownloadableInput, formUncheckedUpdateWithoutNotesDownloadableInput>
    create: XOR<formCreateWithoutNotesDownloadableInput, formUncheckedCreateWithoutNotesDownloadableInput>
  }

  export type formUpdateWithoutNotesDownloadableInput = {
    formName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutFormNestedInput
    note?: noteUpdateManyWithoutFormNestedInput
    topic?: topicUpdateManyWithoutFormNestedInput
    subjects?: subjectUpdateManyWithoutFormsNestedInput
  }

  export type formUncheckedUpdateWithoutNotesDownloadableInput = {
    id?: IntFieldUpdateOperationsInput | number
    formName?: StringFieldUpdateOperationsInput | string
    usersId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: noteUncheckedUpdateManyWithoutFormNestedInput
    topic?: topicUncheckedUpdateManyWithoutFormNestedInput
    subjects?: subjectUncheckedUpdateManyWithoutFormsNestedInput
  }

  export type subjectUpsertWithoutNotesDownloadableInput = {
    update: XOR<subjectUpdateWithoutNotesDownloadableInput, subjectUncheckedUpdateWithoutNotesDownloadableInput>
    create: XOR<subjectCreateWithoutNotesDownloadableInput, subjectUncheckedCreateWithoutNotesDownloadableInput>
  }

  export type subjectUpdateWithoutNotesDownloadableInput = {
    subjectName?: StringFieldUpdateOperationsInput | string
    subjectDefinition?: StringFieldUpdateOperationsInput | string
    imageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutSubjectNestedInput
    note?: noteUpdateManyWithoutSubjectNestedInput
    topic?: topicUpdateManyWithoutSubjectNestedInput
    forms?: formUpdateManyWithoutSubjectsNestedInput
  }

  export type subjectUncheckedUpdateWithoutNotesDownloadableInput = {
    id?: IntFieldUpdateOperationsInput | number
    subjectName?: StringFieldUpdateOperationsInput | string
    subjectDefinition?: StringFieldUpdateOperationsInput | string
    imageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    usersId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: noteUncheckedUpdateManyWithoutSubjectNestedInput
    topic?: topicUncheckedUpdateManyWithoutSubjectNestedInput
    forms?: formUncheckedUpdateManyWithoutSubjectsNestedInput
  }

  export type usersUpsertWithoutNotesDownloadableInput = {
    update: XOR<usersUpdateWithoutNotesDownloadableInput, usersUncheckedUpdateWithoutNotesDownloadableInput>
    create: XOR<usersCreateWithoutNotesDownloadableInput, usersUncheckedCreateWithoutNotesDownloadableInput>
  }

  export type usersUpdateWithoutNotesDownloadableInput = {
    image?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isSuperUser?: BoolFieldUpdateOperationsInput | boolean
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    exam?: examUpdateManyWithoutUsersNestedInput
    examDownloadable?: examDownloadableUpdateManyWithoutUsersNestedInput
    form?: formUpdateManyWithoutUsersNestedInput
    formExams?: formExamsUpdateManyWithoutUsersNestedInput
    formReference?: formReferenceUpdateManyWithoutUsersNestedInput
    formReview?: formReviewUpdateManyWithoutUsersNestedInput
    note?: noteUpdateManyWithoutUsersNestedInput
    purchase?: purchaseUpdateManyWithoutUsersNestedInput
    question?: questionUpdateManyWithoutUsersNestedInput
    reference?: referenceUpdateManyWithoutUsersNestedInput
    review?: reviewUpdateManyWithoutUsersNestedInput
    subject?: subjectUpdateManyWithoutUsersNestedInput
    subjectExams?: subjectExamsUpdateManyWithoutUsersNestedInput
    subjectReference?: subjectReferenceUpdateManyWithoutUsersNestedInput
    subjectReview?: subjectReviewUpdateManyWithoutUsersNestedInput
    topic?: topicUpdateManyWithoutUsersNestedInput
    topicReview?: topicReviewUpdateManyWithoutUsersNestedInput
    vifurushi?: vifurushiUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutNotesDownloadableInput = {
    id?: IntFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isSuperUser?: BoolFieldUpdateOperationsInput | boolean
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    exam?: examUncheckedUpdateManyWithoutUsersNestedInput
    examDownloadable?: examDownloadableUncheckedUpdateManyWithoutUsersNestedInput
    form?: formUncheckedUpdateManyWithoutUsersNestedInput
    formExams?: formExamsUncheckedUpdateManyWithoutUsersNestedInput
    formReference?: formReferenceUncheckedUpdateManyWithoutUsersNestedInput
    formReview?: formReviewUncheckedUpdateManyWithoutUsersNestedInput
    note?: noteUncheckedUpdateManyWithoutUsersNestedInput
    purchase?: purchaseUncheckedUpdateManyWithoutUsersNestedInput
    question?: questionUncheckedUpdateManyWithoutUsersNestedInput
    reference?: referenceUncheckedUpdateManyWithoutUsersNestedInput
    review?: reviewUncheckedUpdateManyWithoutUsersNestedInput
    subject?: subjectUncheckedUpdateManyWithoutUsersNestedInput
    subjectExams?: subjectExamsUncheckedUpdateManyWithoutUsersNestedInput
    subjectReference?: subjectReferenceUncheckedUpdateManyWithoutUsersNestedInput
    subjectReview?: subjectReviewUncheckedUpdateManyWithoutUsersNestedInput
    topic?: topicUncheckedUpdateManyWithoutUsersNestedInput
    topicReview?: topicReviewUncheckedUpdateManyWithoutUsersNestedInput
    vifurushi?: vifurushiUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersCreateWithoutSubjectReviewInput = {
    image?: string | null
    username: string
    password: string
    isAdmin?: boolean
    isSuperUser?: boolean
    dateJoined?: Date | string
    name: string
    updatedAt?: Date | string
    isOnline?: boolean
    exam?: examCreateNestedManyWithoutUsersInput
    examDownloadable?: examDownloadableCreateNestedManyWithoutUsersInput
    form?: formCreateNestedManyWithoutUsersInput
    formExams?: formExamsCreateNestedManyWithoutUsersInput
    formReference?: formReferenceCreateNestedManyWithoutUsersInput
    formReview?: formReviewCreateNestedManyWithoutUsersInput
    note?: noteCreateNestedManyWithoutUsersInput
    notesDownloadable?: notesDownloadableCreateNestedManyWithoutUsersInput
    purchase?: purchaseCreateNestedManyWithoutUsersInput
    question?: questionCreateNestedManyWithoutUsersInput
    reference?: referenceCreateNestedManyWithoutUsersInput
    review?: reviewCreateNestedManyWithoutUsersInput
    subject?: subjectCreateNestedManyWithoutUsersInput
    subjectExams?: subjectExamsCreateNestedManyWithoutUsersInput
    subjectReference?: subjectReferenceCreateNestedManyWithoutUsersInput
    topic?: topicCreateNestedManyWithoutUsersInput
    topicReview?: topicReviewCreateNestedManyWithoutUsersInput
    vifurushi?: vifurushiCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutSubjectReviewInput = {
    id?: number
    image?: string | null
    username: string
    password: string
    isAdmin?: boolean
    isSuperUser?: boolean
    dateJoined?: Date | string
    name: string
    updatedAt?: Date | string
    isOnline?: boolean
    exam?: examUncheckedCreateNestedManyWithoutUsersInput
    examDownloadable?: examDownloadableUncheckedCreateNestedManyWithoutUsersInput
    form?: formUncheckedCreateNestedManyWithoutUsersInput
    formExams?: formExamsUncheckedCreateNestedManyWithoutUsersInput
    formReference?: formReferenceUncheckedCreateNestedManyWithoutUsersInput
    formReview?: formReviewUncheckedCreateNestedManyWithoutUsersInput
    note?: noteUncheckedCreateNestedManyWithoutUsersInput
    notesDownloadable?: notesDownloadableUncheckedCreateNestedManyWithoutUsersInput
    purchase?: purchaseUncheckedCreateNestedManyWithoutUsersInput
    question?: questionUncheckedCreateNestedManyWithoutUsersInput
    reference?: referenceUncheckedCreateNestedManyWithoutUsersInput
    review?: reviewUncheckedCreateNestedManyWithoutUsersInput
    subject?: subjectUncheckedCreateNestedManyWithoutUsersInput
    subjectExams?: subjectExamsUncheckedCreateNestedManyWithoutUsersInput
    subjectReference?: subjectReferenceUncheckedCreateNestedManyWithoutUsersInput
    topic?: topicUncheckedCreateNestedManyWithoutUsersInput
    topicReview?: topicReviewUncheckedCreateNestedManyWithoutUsersInput
    vifurushi?: vifurushiUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutSubjectReviewInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutSubjectReviewInput, usersUncheckedCreateWithoutSubjectReviewInput>
  }

  export type reviewCreateWithoutSubjectInput = {
    name: string
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    form: formReviewCreateNestedOneWithoutReviewInput
    topic: topicReviewCreateNestedOneWithoutReviewInput
    users: usersCreateNestedOneWithoutReviewInput
    question?: questionCreateNestedManyWithoutReviewInput
  }

  export type reviewUncheckedCreateWithoutSubjectInput = {
    id?: number
    name: string
    published?: boolean
    topicId: number
    formId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    usersId: number
    question?: questionUncheckedCreateNestedManyWithoutReviewInput
  }

  export type reviewCreateOrConnectWithoutSubjectInput = {
    where: reviewWhereUniqueInput
    create: XOR<reviewCreateWithoutSubjectInput, reviewUncheckedCreateWithoutSubjectInput>
  }

  export type reviewCreateManySubjectInputEnvelope = {
    data: Enumerable<reviewCreateManySubjectInput>
    skipDuplicates?: boolean
  }

  export type topicReviewCreateWithoutSubjectInput = {
    topicName: string
    topicDefinition?: string | null
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    form: formReviewCreateNestedOneWithoutTopicInput
    users: usersCreateNestedOneWithoutTopicReviewInput
    review?: reviewCreateNestedManyWithoutTopicInput
  }

  export type topicReviewUncheckedCreateWithoutSubjectInput = {
    id?: number
    topicName: string
    topicDefinition?: string | null
    published?: boolean
    formId: number
    usersId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    review?: reviewUncheckedCreateNestedManyWithoutTopicInput
  }

  export type topicReviewCreateOrConnectWithoutSubjectInput = {
    where: topicReviewWhereUniqueInput
    create: XOR<topicReviewCreateWithoutSubjectInput, topicReviewUncheckedCreateWithoutSubjectInput>
  }

  export type topicReviewCreateManySubjectInputEnvelope = {
    data: Enumerable<topicReviewCreateManySubjectInput>
    skipDuplicates?: boolean
  }

  export type formReviewCreateWithoutSubjectsInput = {
    formName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users: usersCreateNestedOneWithoutFormReviewInput
    review?: reviewCreateNestedManyWithoutFormInput
    topic?: topicReviewCreateNestedManyWithoutFormInput
  }

  export type formReviewUncheckedCreateWithoutSubjectsInput = {
    id?: number
    formName: string
    usersId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    review?: reviewUncheckedCreateNestedManyWithoutFormInput
    topic?: topicReviewUncheckedCreateNestedManyWithoutFormInput
  }

  export type formReviewCreateOrConnectWithoutSubjectsInput = {
    where: formReviewWhereUniqueInput
    create: XOR<formReviewCreateWithoutSubjectsInput, formReviewUncheckedCreateWithoutSubjectsInput>
  }

  export type usersUpsertWithoutSubjectReviewInput = {
    update: XOR<usersUpdateWithoutSubjectReviewInput, usersUncheckedUpdateWithoutSubjectReviewInput>
    create: XOR<usersCreateWithoutSubjectReviewInput, usersUncheckedCreateWithoutSubjectReviewInput>
  }

  export type usersUpdateWithoutSubjectReviewInput = {
    image?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isSuperUser?: BoolFieldUpdateOperationsInput | boolean
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    exam?: examUpdateManyWithoutUsersNestedInput
    examDownloadable?: examDownloadableUpdateManyWithoutUsersNestedInput
    form?: formUpdateManyWithoutUsersNestedInput
    formExams?: formExamsUpdateManyWithoutUsersNestedInput
    formReference?: formReferenceUpdateManyWithoutUsersNestedInput
    formReview?: formReviewUpdateManyWithoutUsersNestedInput
    note?: noteUpdateManyWithoutUsersNestedInput
    notesDownloadable?: notesDownloadableUpdateManyWithoutUsersNestedInput
    purchase?: purchaseUpdateManyWithoutUsersNestedInput
    question?: questionUpdateManyWithoutUsersNestedInput
    reference?: referenceUpdateManyWithoutUsersNestedInput
    review?: reviewUpdateManyWithoutUsersNestedInput
    subject?: subjectUpdateManyWithoutUsersNestedInput
    subjectExams?: subjectExamsUpdateManyWithoutUsersNestedInput
    subjectReference?: subjectReferenceUpdateManyWithoutUsersNestedInput
    topic?: topicUpdateManyWithoutUsersNestedInput
    topicReview?: topicReviewUpdateManyWithoutUsersNestedInput
    vifurushi?: vifurushiUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutSubjectReviewInput = {
    id?: IntFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isSuperUser?: BoolFieldUpdateOperationsInput | boolean
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    exam?: examUncheckedUpdateManyWithoutUsersNestedInput
    examDownloadable?: examDownloadableUncheckedUpdateManyWithoutUsersNestedInput
    form?: formUncheckedUpdateManyWithoutUsersNestedInput
    formExams?: formExamsUncheckedUpdateManyWithoutUsersNestedInput
    formReference?: formReferenceUncheckedUpdateManyWithoutUsersNestedInput
    formReview?: formReviewUncheckedUpdateManyWithoutUsersNestedInput
    note?: noteUncheckedUpdateManyWithoutUsersNestedInput
    notesDownloadable?: notesDownloadableUncheckedUpdateManyWithoutUsersNestedInput
    purchase?: purchaseUncheckedUpdateManyWithoutUsersNestedInput
    question?: questionUncheckedUpdateManyWithoutUsersNestedInput
    reference?: referenceUncheckedUpdateManyWithoutUsersNestedInput
    review?: reviewUncheckedUpdateManyWithoutUsersNestedInput
    subject?: subjectUncheckedUpdateManyWithoutUsersNestedInput
    subjectExams?: subjectExamsUncheckedUpdateManyWithoutUsersNestedInput
    subjectReference?: subjectReferenceUncheckedUpdateManyWithoutUsersNestedInput
    topic?: topicUncheckedUpdateManyWithoutUsersNestedInput
    topicReview?: topicReviewUncheckedUpdateManyWithoutUsersNestedInput
    vifurushi?: vifurushiUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type reviewUpsertWithWhereUniqueWithoutSubjectInput = {
    where: reviewWhereUniqueInput
    update: XOR<reviewUpdateWithoutSubjectInput, reviewUncheckedUpdateWithoutSubjectInput>
    create: XOR<reviewCreateWithoutSubjectInput, reviewUncheckedCreateWithoutSubjectInput>
  }

  export type reviewUpdateWithWhereUniqueWithoutSubjectInput = {
    where: reviewWhereUniqueInput
    data: XOR<reviewUpdateWithoutSubjectInput, reviewUncheckedUpdateWithoutSubjectInput>
  }

  export type reviewUpdateManyWithWhereWithoutSubjectInput = {
    where: reviewScalarWhereInput
    data: XOR<reviewUpdateManyMutationInput, reviewUncheckedUpdateManyWithoutReviewInput>
  }

  export type topicReviewUpsertWithWhereUniqueWithoutSubjectInput = {
    where: topicReviewWhereUniqueInput
    update: XOR<topicReviewUpdateWithoutSubjectInput, topicReviewUncheckedUpdateWithoutSubjectInput>
    create: XOR<topicReviewCreateWithoutSubjectInput, topicReviewUncheckedCreateWithoutSubjectInput>
  }

  export type topicReviewUpdateWithWhereUniqueWithoutSubjectInput = {
    where: topicReviewWhereUniqueInput
    data: XOR<topicReviewUpdateWithoutSubjectInput, topicReviewUncheckedUpdateWithoutSubjectInput>
  }

  export type topicReviewUpdateManyWithWhereWithoutSubjectInput = {
    where: topicReviewScalarWhereInput
    data: XOR<topicReviewUpdateManyMutationInput, topicReviewUncheckedUpdateManyWithoutTopicInput>
  }

  export type formReviewUpsertWithWhereUniqueWithoutSubjectsInput = {
    where: formReviewWhereUniqueInput
    update: XOR<formReviewUpdateWithoutSubjectsInput, formReviewUncheckedUpdateWithoutSubjectsInput>
    create: XOR<formReviewCreateWithoutSubjectsInput, formReviewUncheckedCreateWithoutSubjectsInput>
  }

  export type formReviewUpdateWithWhereUniqueWithoutSubjectsInput = {
    where: formReviewWhereUniqueInput
    data: XOR<formReviewUpdateWithoutSubjectsInput, formReviewUncheckedUpdateWithoutSubjectsInput>
  }

  export type formReviewUpdateManyWithWhereWithoutSubjectsInput = {
    where: formReviewScalarWhereInput
    data: XOR<formReviewUpdateManyMutationInput, formReviewUncheckedUpdateManyWithoutFormsInput>
  }

  export type usersCreateWithoutFormReviewInput = {
    image?: string | null
    username: string
    password: string
    isAdmin?: boolean
    isSuperUser?: boolean
    dateJoined?: Date | string
    name: string
    updatedAt?: Date | string
    isOnline?: boolean
    exam?: examCreateNestedManyWithoutUsersInput
    examDownloadable?: examDownloadableCreateNestedManyWithoutUsersInput
    form?: formCreateNestedManyWithoutUsersInput
    formExams?: formExamsCreateNestedManyWithoutUsersInput
    formReference?: formReferenceCreateNestedManyWithoutUsersInput
    note?: noteCreateNestedManyWithoutUsersInput
    notesDownloadable?: notesDownloadableCreateNestedManyWithoutUsersInput
    purchase?: purchaseCreateNestedManyWithoutUsersInput
    question?: questionCreateNestedManyWithoutUsersInput
    reference?: referenceCreateNestedManyWithoutUsersInput
    review?: reviewCreateNestedManyWithoutUsersInput
    subject?: subjectCreateNestedManyWithoutUsersInput
    subjectExams?: subjectExamsCreateNestedManyWithoutUsersInput
    subjectReference?: subjectReferenceCreateNestedManyWithoutUsersInput
    subjectReview?: subjectReviewCreateNestedManyWithoutUsersInput
    topic?: topicCreateNestedManyWithoutUsersInput
    topicReview?: topicReviewCreateNestedManyWithoutUsersInput
    vifurushi?: vifurushiCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutFormReviewInput = {
    id?: number
    image?: string | null
    username: string
    password: string
    isAdmin?: boolean
    isSuperUser?: boolean
    dateJoined?: Date | string
    name: string
    updatedAt?: Date | string
    isOnline?: boolean
    exam?: examUncheckedCreateNestedManyWithoutUsersInput
    examDownloadable?: examDownloadableUncheckedCreateNestedManyWithoutUsersInput
    form?: formUncheckedCreateNestedManyWithoutUsersInput
    formExams?: formExamsUncheckedCreateNestedManyWithoutUsersInput
    formReference?: formReferenceUncheckedCreateNestedManyWithoutUsersInput
    note?: noteUncheckedCreateNestedManyWithoutUsersInput
    notesDownloadable?: notesDownloadableUncheckedCreateNestedManyWithoutUsersInput
    purchase?: purchaseUncheckedCreateNestedManyWithoutUsersInput
    question?: questionUncheckedCreateNestedManyWithoutUsersInput
    reference?: referenceUncheckedCreateNestedManyWithoutUsersInput
    review?: reviewUncheckedCreateNestedManyWithoutUsersInput
    subject?: subjectUncheckedCreateNestedManyWithoutUsersInput
    subjectExams?: subjectExamsUncheckedCreateNestedManyWithoutUsersInput
    subjectReference?: subjectReferenceUncheckedCreateNestedManyWithoutUsersInput
    subjectReview?: subjectReviewUncheckedCreateNestedManyWithoutUsersInput
    topic?: topicUncheckedCreateNestedManyWithoutUsersInput
    topicReview?: topicReviewUncheckedCreateNestedManyWithoutUsersInput
    vifurushi?: vifurushiUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutFormReviewInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutFormReviewInput, usersUncheckedCreateWithoutFormReviewInput>
  }

  export type reviewCreateWithoutFormInput = {
    name: string
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    subject: subjectReviewCreateNestedOneWithoutReviewInput
    topic: topicReviewCreateNestedOneWithoutReviewInput
    users: usersCreateNestedOneWithoutReviewInput
    question?: questionCreateNestedManyWithoutReviewInput
  }

  export type reviewUncheckedCreateWithoutFormInput = {
    id?: number
    name: string
    published?: boolean
    topicId: number
    subjectId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    usersId: number
    question?: questionUncheckedCreateNestedManyWithoutReviewInput
  }

  export type reviewCreateOrConnectWithoutFormInput = {
    where: reviewWhereUniqueInput
    create: XOR<reviewCreateWithoutFormInput, reviewUncheckedCreateWithoutFormInput>
  }

  export type reviewCreateManyFormInputEnvelope = {
    data: Enumerable<reviewCreateManyFormInput>
    skipDuplicates?: boolean
  }

  export type topicReviewCreateWithoutFormInput = {
    topicName: string
    topicDefinition?: string | null
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    subject: subjectReviewCreateNestedOneWithoutTopicInput
    users: usersCreateNestedOneWithoutTopicReviewInput
    review?: reviewCreateNestedManyWithoutTopicInput
  }

  export type topicReviewUncheckedCreateWithoutFormInput = {
    id?: number
    topicName: string
    topicDefinition?: string | null
    published?: boolean
    subjectId: number
    usersId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    review?: reviewUncheckedCreateNestedManyWithoutTopicInput
  }

  export type topicReviewCreateOrConnectWithoutFormInput = {
    where: topicReviewWhereUniqueInput
    create: XOR<topicReviewCreateWithoutFormInput, topicReviewUncheckedCreateWithoutFormInput>
  }

  export type topicReviewCreateManyFormInputEnvelope = {
    data: Enumerable<topicReviewCreateManyFormInput>
    skipDuplicates?: boolean
  }

  export type subjectReviewCreateWithoutFormsInput = {
    subjectName: string
    subjectDefinition: string
    imageLocation?: string | null
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users: usersCreateNestedOneWithoutSubjectReviewInput
    review?: reviewCreateNestedManyWithoutSubjectInput
    topic?: topicReviewCreateNestedManyWithoutSubjectInput
  }

  export type subjectReviewUncheckedCreateWithoutFormsInput = {
    id?: number
    subjectName: string
    subjectDefinition: string
    imageLocation?: string | null
    published?: boolean
    usersId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    review?: reviewUncheckedCreateNestedManyWithoutSubjectInput
    topic?: topicReviewUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type subjectReviewCreateOrConnectWithoutFormsInput = {
    where: subjectReviewWhereUniqueInput
    create: XOR<subjectReviewCreateWithoutFormsInput, subjectReviewUncheckedCreateWithoutFormsInput>
  }

  export type usersUpsertWithoutFormReviewInput = {
    update: XOR<usersUpdateWithoutFormReviewInput, usersUncheckedUpdateWithoutFormReviewInput>
    create: XOR<usersCreateWithoutFormReviewInput, usersUncheckedCreateWithoutFormReviewInput>
  }

  export type usersUpdateWithoutFormReviewInput = {
    image?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isSuperUser?: BoolFieldUpdateOperationsInput | boolean
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    exam?: examUpdateManyWithoutUsersNestedInput
    examDownloadable?: examDownloadableUpdateManyWithoutUsersNestedInput
    form?: formUpdateManyWithoutUsersNestedInput
    formExams?: formExamsUpdateManyWithoutUsersNestedInput
    formReference?: formReferenceUpdateManyWithoutUsersNestedInput
    note?: noteUpdateManyWithoutUsersNestedInput
    notesDownloadable?: notesDownloadableUpdateManyWithoutUsersNestedInput
    purchase?: purchaseUpdateManyWithoutUsersNestedInput
    question?: questionUpdateManyWithoutUsersNestedInput
    reference?: referenceUpdateManyWithoutUsersNestedInput
    review?: reviewUpdateManyWithoutUsersNestedInput
    subject?: subjectUpdateManyWithoutUsersNestedInput
    subjectExams?: subjectExamsUpdateManyWithoutUsersNestedInput
    subjectReference?: subjectReferenceUpdateManyWithoutUsersNestedInput
    subjectReview?: subjectReviewUpdateManyWithoutUsersNestedInput
    topic?: topicUpdateManyWithoutUsersNestedInput
    topicReview?: topicReviewUpdateManyWithoutUsersNestedInput
    vifurushi?: vifurushiUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutFormReviewInput = {
    id?: IntFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isSuperUser?: BoolFieldUpdateOperationsInput | boolean
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    exam?: examUncheckedUpdateManyWithoutUsersNestedInput
    examDownloadable?: examDownloadableUncheckedUpdateManyWithoutUsersNestedInput
    form?: formUncheckedUpdateManyWithoutUsersNestedInput
    formExams?: formExamsUncheckedUpdateManyWithoutUsersNestedInput
    formReference?: formReferenceUncheckedUpdateManyWithoutUsersNestedInput
    note?: noteUncheckedUpdateManyWithoutUsersNestedInput
    notesDownloadable?: notesDownloadableUncheckedUpdateManyWithoutUsersNestedInput
    purchase?: purchaseUncheckedUpdateManyWithoutUsersNestedInput
    question?: questionUncheckedUpdateManyWithoutUsersNestedInput
    reference?: referenceUncheckedUpdateManyWithoutUsersNestedInput
    review?: reviewUncheckedUpdateManyWithoutUsersNestedInput
    subject?: subjectUncheckedUpdateManyWithoutUsersNestedInput
    subjectExams?: subjectExamsUncheckedUpdateManyWithoutUsersNestedInput
    subjectReference?: subjectReferenceUncheckedUpdateManyWithoutUsersNestedInput
    subjectReview?: subjectReviewUncheckedUpdateManyWithoutUsersNestedInput
    topic?: topicUncheckedUpdateManyWithoutUsersNestedInput
    topicReview?: topicReviewUncheckedUpdateManyWithoutUsersNestedInput
    vifurushi?: vifurushiUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type reviewUpsertWithWhereUniqueWithoutFormInput = {
    where: reviewWhereUniqueInput
    update: XOR<reviewUpdateWithoutFormInput, reviewUncheckedUpdateWithoutFormInput>
    create: XOR<reviewCreateWithoutFormInput, reviewUncheckedCreateWithoutFormInput>
  }

  export type reviewUpdateWithWhereUniqueWithoutFormInput = {
    where: reviewWhereUniqueInput
    data: XOR<reviewUpdateWithoutFormInput, reviewUncheckedUpdateWithoutFormInput>
  }

  export type reviewUpdateManyWithWhereWithoutFormInput = {
    where: reviewScalarWhereInput
    data: XOR<reviewUpdateManyMutationInput, reviewUncheckedUpdateManyWithoutReviewInput>
  }

  export type topicReviewUpsertWithWhereUniqueWithoutFormInput = {
    where: topicReviewWhereUniqueInput
    update: XOR<topicReviewUpdateWithoutFormInput, topicReviewUncheckedUpdateWithoutFormInput>
    create: XOR<topicReviewCreateWithoutFormInput, topicReviewUncheckedCreateWithoutFormInput>
  }

  export type topicReviewUpdateWithWhereUniqueWithoutFormInput = {
    where: topicReviewWhereUniqueInput
    data: XOR<topicReviewUpdateWithoutFormInput, topicReviewUncheckedUpdateWithoutFormInput>
  }

  export type topicReviewUpdateManyWithWhereWithoutFormInput = {
    where: topicReviewScalarWhereInput
    data: XOR<topicReviewUpdateManyMutationInput, topicReviewUncheckedUpdateManyWithoutTopicInput>
  }

  export type subjectReviewUpsertWithWhereUniqueWithoutFormsInput = {
    where: subjectReviewWhereUniqueInput
    update: XOR<subjectReviewUpdateWithoutFormsInput, subjectReviewUncheckedUpdateWithoutFormsInput>
    create: XOR<subjectReviewCreateWithoutFormsInput, subjectReviewUncheckedCreateWithoutFormsInput>
  }

  export type subjectReviewUpdateWithWhereUniqueWithoutFormsInput = {
    where: subjectReviewWhereUniqueInput
    data: XOR<subjectReviewUpdateWithoutFormsInput, subjectReviewUncheckedUpdateWithoutFormsInput>
  }

  export type subjectReviewUpdateManyWithWhereWithoutFormsInput = {
    where: subjectReviewScalarWhereInput
    data: XOR<subjectReviewUpdateManyMutationInput, subjectReviewUncheckedUpdateManyWithoutSubjectsInput>
  }

  export type formReviewCreateWithoutTopicInput = {
    formName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users: usersCreateNestedOneWithoutFormReviewInput
    review?: reviewCreateNestedManyWithoutFormInput
    subjects?: subjectReviewCreateNestedManyWithoutFormsInput
  }

  export type formReviewUncheckedCreateWithoutTopicInput = {
    id?: number
    formName: string
    usersId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    review?: reviewUncheckedCreateNestedManyWithoutFormInput
    subjects?: subjectReviewUncheckedCreateNestedManyWithoutFormsInput
  }

  export type formReviewCreateOrConnectWithoutTopicInput = {
    where: formReviewWhereUniqueInput
    create: XOR<formReviewCreateWithoutTopicInput, formReviewUncheckedCreateWithoutTopicInput>
  }

  export type subjectReviewCreateWithoutTopicInput = {
    subjectName: string
    subjectDefinition: string
    imageLocation?: string | null
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users: usersCreateNestedOneWithoutSubjectReviewInput
    review?: reviewCreateNestedManyWithoutSubjectInput
    forms?: formReviewCreateNestedManyWithoutSubjectsInput
  }

  export type subjectReviewUncheckedCreateWithoutTopicInput = {
    id?: number
    subjectName: string
    subjectDefinition: string
    imageLocation?: string | null
    published?: boolean
    usersId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    review?: reviewUncheckedCreateNestedManyWithoutSubjectInput
    forms?: formReviewUncheckedCreateNestedManyWithoutSubjectsInput
  }

  export type subjectReviewCreateOrConnectWithoutTopicInput = {
    where: subjectReviewWhereUniqueInput
    create: XOR<subjectReviewCreateWithoutTopicInput, subjectReviewUncheckedCreateWithoutTopicInput>
  }

  export type usersCreateWithoutTopicReviewInput = {
    image?: string | null
    username: string
    password: string
    isAdmin?: boolean
    isSuperUser?: boolean
    dateJoined?: Date | string
    name: string
    updatedAt?: Date | string
    isOnline?: boolean
    exam?: examCreateNestedManyWithoutUsersInput
    examDownloadable?: examDownloadableCreateNestedManyWithoutUsersInput
    form?: formCreateNestedManyWithoutUsersInput
    formExams?: formExamsCreateNestedManyWithoutUsersInput
    formReference?: formReferenceCreateNestedManyWithoutUsersInput
    formReview?: formReviewCreateNestedManyWithoutUsersInput
    note?: noteCreateNestedManyWithoutUsersInput
    notesDownloadable?: notesDownloadableCreateNestedManyWithoutUsersInput
    purchase?: purchaseCreateNestedManyWithoutUsersInput
    question?: questionCreateNestedManyWithoutUsersInput
    reference?: referenceCreateNestedManyWithoutUsersInput
    review?: reviewCreateNestedManyWithoutUsersInput
    subject?: subjectCreateNestedManyWithoutUsersInput
    subjectExams?: subjectExamsCreateNestedManyWithoutUsersInput
    subjectReference?: subjectReferenceCreateNestedManyWithoutUsersInput
    subjectReview?: subjectReviewCreateNestedManyWithoutUsersInput
    topic?: topicCreateNestedManyWithoutUsersInput
    vifurushi?: vifurushiCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutTopicReviewInput = {
    id?: number
    image?: string | null
    username: string
    password: string
    isAdmin?: boolean
    isSuperUser?: boolean
    dateJoined?: Date | string
    name: string
    updatedAt?: Date | string
    isOnline?: boolean
    exam?: examUncheckedCreateNestedManyWithoutUsersInput
    examDownloadable?: examDownloadableUncheckedCreateNestedManyWithoutUsersInput
    form?: formUncheckedCreateNestedManyWithoutUsersInput
    formExams?: formExamsUncheckedCreateNestedManyWithoutUsersInput
    formReference?: formReferenceUncheckedCreateNestedManyWithoutUsersInput
    formReview?: formReviewUncheckedCreateNestedManyWithoutUsersInput
    note?: noteUncheckedCreateNestedManyWithoutUsersInput
    notesDownloadable?: notesDownloadableUncheckedCreateNestedManyWithoutUsersInput
    purchase?: purchaseUncheckedCreateNestedManyWithoutUsersInput
    question?: questionUncheckedCreateNestedManyWithoutUsersInput
    reference?: referenceUncheckedCreateNestedManyWithoutUsersInput
    review?: reviewUncheckedCreateNestedManyWithoutUsersInput
    subject?: subjectUncheckedCreateNestedManyWithoutUsersInput
    subjectExams?: subjectExamsUncheckedCreateNestedManyWithoutUsersInput
    subjectReference?: subjectReferenceUncheckedCreateNestedManyWithoutUsersInput
    subjectReview?: subjectReviewUncheckedCreateNestedManyWithoutUsersInput
    topic?: topicUncheckedCreateNestedManyWithoutUsersInput
    vifurushi?: vifurushiUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutTopicReviewInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutTopicReviewInput, usersUncheckedCreateWithoutTopicReviewInput>
  }

  export type reviewCreateWithoutTopicInput = {
    name: string
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    form: formReviewCreateNestedOneWithoutReviewInput
    subject: subjectReviewCreateNestedOneWithoutReviewInput
    users: usersCreateNestedOneWithoutReviewInput
    question?: questionCreateNestedManyWithoutReviewInput
  }

  export type reviewUncheckedCreateWithoutTopicInput = {
    id?: number
    name: string
    published?: boolean
    subjectId: number
    formId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    usersId: number
    question?: questionUncheckedCreateNestedManyWithoutReviewInput
  }

  export type reviewCreateOrConnectWithoutTopicInput = {
    where: reviewWhereUniqueInput
    create: XOR<reviewCreateWithoutTopicInput, reviewUncheckedCreateWithoutTopicInput>
  }

  export type reviewCreateManyTopicInputEnvelope = {
    data: Enumerable<reviewCreateManyTopicInput>
    skipDuplicates?: boolean
  }

  export type formReviewUpsertWithoutTopicInput = {
    update: XOR<formReviewUpdateWithoutTopicInput, formReviewUncheckedUpdateWithoutTopicInput>
    create: XOR<formReviewCreateWithoutTopicInput, formReviewUncheckedCreateWithoutTopicInput>
  }

  export type formReviewUpdateWithoutTopicInput = {
    formName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutFormReviewNestedInput
    review?: reviewUpdateManyWithoutFormNestedInput
    subjects?: subjectReviewUpdateManyWithoutFormsNestedInput
  }

  export type formReviewUncheckedUpdateWithoutTopicInput = {
    id?: IntFieldUpdateOperationsInput | number
    formName?: StringFieldUpdateOperationsInput | string
    usersId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    review?: reviewUncheckedUpdateManyWithoutFormNestedInput
    subjects?: subjectReviewUncheckedUpdateManyWithoutFormsNestedInput
  }

  export type subjectReviewUpsertWithoutTopicInput = {
    update: XOR<subjectReviewUpdateWithoutTopicInput, subjectReviewUncheckedUpdateWithoutTopicInput>
    create: XOR<subjectReviewCreateWithoutTopicInput, subjectReviewUncheckedCreateWithoutTopicInput>
  }

  export type subjectReviewUpdateWithoutTopicInput = {
    subjectName?: StringFieldUpdateOperationsInput | string
    subjectDefinition?: StringFieldUpdateOperationsInput | string
    imageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutSubjectReviewNestedInput
    review?: reviewUpdateManyWithoutSubjectNestedInput
    forms?: formReviewUpdateManyWithoutSubjectsNestedInput
  }

  export type subjectReviewUncheckedUpdateWithoutTopicInput = {
    id?: IntFieldUpdateOperationsInput | number
    subjectName?: StringFieldUpdateOperationsInput | string
    subjectDefinition?: StringFieldUpdateOperationsInput | string
    imageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    usersId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    review?: reviewUncheckedUpdateManyWithoutSubjectNestedInput
    forms?: formReviewUncheckedUpdateManyWithoutSubjectsNestedInput
  }

  export type usersUpsertWithoutTopicReviewInput = {
    update: XOR<usersUpdateWithoutTopicReviewInput, usersUncheckedUpdateWithoutTopicReviewInput>
    create: XOR<usersCreateWithoutTopicReviewInput, usersUncheckedCreateWithoutTopicReviewInput>
  }

  export type usersUpdateWithoutTopicReviewInput = {
    image?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isSuperUser?: BoolFieldUpdateOperationsInput | boolean
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    exam?: examUpdateManyWithoutUsersNestedInput
    examDownloadable?: examDownloadableUpdateManyWithoutUsersNestedInput
    form?: formUpdateManyWithoutUsersNestedInput
    formExams?: formExamsUpdateManyWithoutUsersNestedInput
    formReference?: formReferenceUpdateManyWithoutUsersNestedInput
    formReview?: formReviewUpdateManyWithoutUsersNestedInput
    note?: noteUpdateManyWithoutUsersNestedInput
    notesDownloadable?: notesDownloadableUpdateManyWithoutUsersNestedInput
    purchase?: purchaseUpdateManyWithoutUsersNestedInput
    question?: questionUpdateManyWithoutUsersNestedInput
    reference?: referenceUpdateManyWithoutUsersNestedInput
    review?: reviewUpdateManyWithoutUsersNestedInput
    subject?: subjectUpdateManyWithoutUsersNestedInput
    subjectExams?: subjectExamsUpdateManyWithoutUsersNestedInput
    subjectReference?: subjectReferenceUpdateManyWithoutUsersNestedInput
    subjectReview?: subjectReviewUpdateManyWithoutUsersNestedInput
    topic?: topicUpdateManyWithoutUsersNestedInput
    vifurushi?: vifurushiUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutTopicReviewInput = {
    id?: IntFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isSuperUser?: BoolFieldUpdateOperationsInput | boolean
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    exam?: examUncheckedUpdateManyWithoutUsersNestedInput
    examDownloadable?: examDownloadableUncheckedUpdateManyWithoutUsersNestedInput
    form?: formUncheckedUpdateManyWithoutUsersNestedInput
    formExams?: formExamsUncheckedUpdateManyWithoutUsersNestedInput
    formReference?: formReferenceUncheckedUpdateManyWithoutUsersNestedInput
    formReview?: formReviewUncheckedUpdateManyWithoutUsersNestedInput
    note?: noteUncheckedUpdateManyWithoutUsersNestedInput
    notesDownloadable?: notesDownloadableUncheckedUpdateManyWithoutUsersNestedInput
    purchase?: purchaseUncheckedUpdateManyWithoutUsersNestedInput
    question?: questionUncheckedUpdateManyWithoutUsersNestedInput
    reference?: referenceUncheckedUpdateManyWithoutUsersNestedInput
    review?: reviewUncheckedUpdateManyWithoutUsersNestedInput
    subject?: subjectUncheckedUpdateManyWithoutUsersNestedInput
    subjectExams?: subjectExamsUncheckedUpdateManyWithoutUsersNestedInput
    subjectReference?: subjectReferenceUncheckedUpdateManyWithoutUsersNestedInput
    subjectReview?: subjectReviewUncheckedUpdateManyWithoutUsersNestedInput
    topic?: topicUncheckedUpdateManyWithoutUsersNestedInput
    vifurushi?: vifurushiUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type reviewUpsertWithWhereUniqueWithoutTopicInput = {
    where: reviewWhereUniqueInput
    update: XOR<reviewUpdateWithoutTopicInput, reviewUncheckedUpdateWithoutTopicInput>
    create: XOR<reviewCreateWithoutTopicInput, reviewUncheckedCreateWithoutTopicInput>
  }

  export type reviewUpdateWithWhereUniqueWithoutTopicInput = {
    where: reviewWhereUniqueInput
    data: XOR<reviewUpdateWithoutTopicInput, reviewUncheckedUpdateWithoutTopicInput>
  }

  export type reviewUpdateManyWithWhereWithoutTopicInput = {
    where: reviewScalarWhereInput
    data: XOR<reviewUpdateManyMutationInput, reviewUncheckedUpdateManyWithoutReviewInput>
  }

  export type formReviewCreateWithoutReviewInput = {
    formName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users: usersCreateNestedOneWithoutFormReviewInput
    topic?: topicReviewCreateNestedManyWithoutFormInput
    subjects?: subjectReviewCreateNestedManyWithoutFormsInput
  }

  export type formReviewUncheckedCreateWithoutReviewInput = {
    id?: number
    formName: string
    usersId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    topic?: topicReviewUncheckedCreateNestedManyWithoutFormInput
    subjects?: subjectReviewUncheckedCreateNestedManyWithoutFormsInput
  }

  export type formReviewCreateOrConnectWithoutReviewInput = {
    where: formReviewWhereUniqueInput
    create: XOR<formReviewCreateWithoutReviewInput, formReviewUncheckedCreateWithoutReviewInput>
  }

  export type subjectReviewCreateWithoutReviewInput = {
    subjectName: string
    subjectDefinition: string
    imageLocation?: string | null
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users: usersCreateNestedOneWithoutSubjectReviewInput
    topic?: topicReviewCreateNestedManyWithoutSubjectInput
    forms?: formReviewCreateNestedManyWithoutSubjectsInput
  }

  export type subjectReviewUncheckedCreateWithoutReviewInput = {
    id?: number
    subjectName: string
    subjectDefinition: string
    imageLocation?: string | null
    published?: boolean
    usersId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    topic?: topicReviewUncheckedCreateNestedManyWithoutSubjectInput
    forms?: formReviewUncheckedCreateNestedManyWithoutSubjectsInput
  }

  export type subjectReviewCreateOrConnectWithoutReviewInput = {
    where: subjectReviewWhereUniqueInput
    create: XOR<subjectReviewCreateWithoutReviewInput, subjectReviewUncheckedCreateWithoutReviewInput>
  }

  export type topicReviewCreateWithoutReviewInput = {
    topicName: string
    topicDefinition?: string | null
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    form: formReviewCreateNestedOneWithoutTopicInput
    subject: subjectReviewCreateNestedOneWithoutTopicInput
    users: usersCreateNestedOneWithoutTopicReviewInput
  }

  export type topicReviewUncheckedCreateWithoutReviewInput = {
    id?: number
    topicName: string
    topicDefinition?: string | null
    published?: boolean
    subjectId: number
    formId: number
    usersId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type topicReviewCreateOrConnectWithoutReviewInput = {
    where: topicReviewWhereUniqueInput
    create: XOR<topicReviewCreateWithoutReviewInput, topicReviewUncheckedCreateWithoutReviewInput>
  }

  export type usersCreateWithoutReviewInput = {
    image?: string | null
    username: string
    password: string
    isAdmin?: boolean
    isSuperUser?: boolean
    dateJoined?: Date | string
    name: string
    updatedAt?: Date | string
    isOnline?: boolean
    exam?: examCreateNestedManyWithoutUsersInput
    examDownloadable?: examDownloadableCreateNestedManyWithoutUsersInput
    form?: formCreateNestedManyWithoutUsersInput
    formExams?: formExamsCreateNestedManyWithoutUsersInput
    formReference?: formReferenceCreateNestedManyWithoutUsersInput
    formReview?: formReviewCreateNestedManyWithoutUsersInput
    note?: noteCreateNestedManyWithoutUsersInput
    notesDownloadable?: notesDownloadableCreateNestedManyWithoutUsersInput
    purchase?: purchaseCreateNestedManyWithoutUsersInput
    question?: questionCreateNestedManyWithoutUsersInput
    reference?: referenceCreateNestedManyWithoutUsersInput
    subject?: subjectCreateNestedManyWithoutUsersInput
    subjectExams?: subjectExamsCreateNestedManyWithoutUsersInput
    subjectReference?: subjectReferenceCreateNestedManyWithoutUsersInput
    subjectReview?: subjectReviewCreateNestedManyWithoutUsersInput
    topic?: topicCreateNestedManyWithoutUsersInput
    topicReview?: topicReviewCreateNestedManyWithoutUsersInput
    vifurushi?: vifurushiCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutReviewInput = {
    id?: number
    image?: string | null
    username: string
    password: string
    isAdmin?: boolean
    isSuperUser?: boolean
    dateJoined?: Date | string
    name: string
    updatedAt?: Date | string
    isOnline?: boolean
    exam?: examUncheckedCreateNestedManyWithoutUsersInput
    examDownloadable?: examDownloadableUncheckedCreateNestedManyWithoutUsersInput
    form?: formUncheckedCreateNestedManyWithoutUsersInput
    formExams?: formExamsUncheckedCreateNestedManyWithoutUsersInput
    formReference?: formReferenceUncheckedCreateNestedManyWithoutUsersInput
    formReview?: formReviewUncheckedCreateNestedManyWithoutUsersInput
    note?: noteUncheckedCreateNestedManyWithoutUsersInput
    notesDownloadable?: notesDownloadableUncheckedCreateNestedManyWithoutUsersInput
    purchase?: purchaseUncheckedCreateNestedManyWithoutUsersInput
    question?: questionUncheckedCreateNestedManyWithoutUsersInput
    reference?: referenceUncheckedCreateNestedManyWithoutUsersInput
    subject?: subjectUncheckedCreateNestedManyWithoutUsersInput
    subjectExams?: subjectExamsUncheckedCreateNestedManyWithoutUsersInput
    subjectReference?: subjectReferenceUncheckedCreateNestedManyWithoutUsersInput
    subjectReview?: subjectReviewUncheckedCreateNestedManyWithoutUsersInput
    topic?: topicUncheckedCreateNestedManyWithoutUsersInput
    topicReview?: topicReviewUncheckedCreateNestedManyWithoutUsersInput
    vifurushi?: vifurushiUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutReviewInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutReviewInput, usersUncheckedCreateWithoutReviewInput>
  }

  export type questionCreateWithoutReviewInput = {
    question: string
    published?: boolean
    answerDetails?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    questionFormat: questionFormatCreateNestedOneWithoutQuestionInput
    users: usersCreateNestedOneWithoutQuestionInput
    answer?: answerCreateNestedManyWithoutQuestionInput
  }

  export type questionUncheckedCreateWithoutReviewInput = {
    id?: number
    question: string
    published?: boolean
    answerDetails?: string
    questionFormatId: number
    usersId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    answer?: answerUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type questionCreateOrConnectWithoutReviewInput = {
    where: questionWhereUniqueInput
    create: XOR<questionCreateWithoutReviewInput, questionUncheckedCreateWithoutReviewInput>
  }

  export type questionCreateManyReviewInputEnvelope = {
    data: Enumerable<questionCreateManyReviewInput>
    skipDuplicates?: boolean
  }

  export type formReviewUpsertWithoutReviewInput = {
    update: XOR<formReviewUpdateWithoutReviewInput, formReviewUncheckedUpdateWithoutReviewInput>
    create: XOR<formReviewCreateWithoutReviewInput, formReviewUncheckedCreateWithoutReviewInput>
  }

  export type formReviewUpdateWithoutReviewInput = {
    formName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutFormReviewNestedInput
    topic?: topicReviewUpdateManyWithoutFormNestedInput
    subjects?: subjectReviewUpdateManyWithoutFormsNestedInput
  }

  export type formReviewUncheckedUpdateWithoutReviewInput = {
    id?: IntFieldUpdateOperationsInput | number
    formName?: StringFieldUpdateOperationsInput | string
    usersId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    topic?: topicReviewUncheckedUpdateManyWithoutFormNestedInput
    subjects?: subjectReviewUncheckedUpdateManyWithoutFormsNestedInput
  }

  export type subjectReviewUpsertWithoutReviewInput = {
    update: XOR<subjectReviewUpdateWithoutReviewInput, subjectReviewUncheckedUpdateWithoutReviewInput>
    create: XOR<subjectReviewCreateWithoutReviewInput, subjectReviewUncheckedCreateWithoutReviewInput>
  }

  export type subjectReviewUpdateWithoutReviewInput = {
    subjectName?: StringFieldUpdateOperationsInput | string
    subjectDefinition?: StringFieldUpdateOperationsInput | string
    imageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutSubjectReviewNestedInput
    topic?: topicReviewUpdateManyWithoutSubjectNestedInput
    forms?: formReviewUpdateManyWithoutSubjectsNestedInput
  }

  export type subjectReviewUncheckedUpdateWithoutReviewInput = {
    id?: IntFieldUpdateOperationsInput | number
    subjectName?: StringFieldUpdateOperationsInput | string
    subjectDefinition?: StringFieldUpdateOperationsInput | string
    imageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    usersId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    topic?: topicReviewUncheckedUpdateManyWithoutSubjectNestedInput
    forms?: formReviewUncheckedUpdateManyWithoutSubjectsNestedInput
  }

  export type topicReviewUpsertWithoutReviewInput = {
    update: XOR<topicReviewUpdateWithoutReviewInput, topicReviewUncheckedUpdateWithoutReviewInput>
    create: XOR<topicReviewCreateWithoutReviewInput, topicReviewUncheckedCreateWithoutReviewInput>
  }

  export type topicReviewUpdateWithoutReviewInput = {
    topicName?: StringFieldUpdateOperationsInput | string
    topicDefinition?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    form?: formReviewUpdateOneRequiredWithoutTopicNestedInput
    subject?: subjectReviewUpdateOneRequiredWithoutTopicNestedInput
    users?: usersUpdateOneRequiredWithoutTopicReviewNestedInput
  }

  export type topicReviewUncheckedUpdateWithoutReviewInput = {
    id?: IntFieldUpdateOperationsInput | number
    topicName?: StringFieldUpdateOperationsInput | string
    topicDefinition?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    subjectId?: IntFieldUpdateOperationsInput | number
    formId?: IntFieldUpdateOperationsInput | number
    usersId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersUpsertWithoutReviewInput = {
    update: XOR<usersUpdateWithoutReviewInput, usersUncheckedUpdateWithoutReviewInput>
    create: XOR<usersCreateWithoutReviewInput, usersUncheckedCreateWithoutReviewInput>
  }

  export type usersUpdateWithoutReviewInput = {
    image?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isSuperUser?: BoolFieldUpdateOperationsInput | boolean
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    exam?: examUpdateManyWithoutUsersNestedInput
    examDownloadable?: examDownloadableUpdateManyWithoutUsersNestedInput
    form?: formUpdateManyWithoutUsersNestedInput
    formExams?: formExamsUpdateManyWithoutUsersNestedInput
    formReference?: formReferenceUpdateManyWithoutUsersNestedInput
    formReview?: formReviewUpdateManyWithoutUsersNestedInput
    note?: noteUpdateManyWithoutUsersNestedInput
    notesDownloadable?: notesDownloadableUpdateManyWithoutUsersNestedInput
    purchase?: purchaseUpdateManyWithoutUsersNestedInput
    question?: questionUpdateManyWithoutUsersNestedInput
    reference?: referenceUpdateManyWithoutUsersNestedInput
    subject?: subjectUpdateManyWithoutUsersNestedInput
    subjectExams?: subjectExamsUpdateManyWithoutUsersNestedInput
    subjectReference?: subjectReferenceUpdateManyWithoutUsersNestedInput
    subjectReview?: subjectReviewUpdateManyWithoutUsersNestedInput
    topic?: topicUpdateManyWithoutUsersNestedInput
    topicReview?: topicReviewUpdateManyWithoutUsersNestedInput
    vifurushi?: vifurushiUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutReviewInput = {
    id?: IntFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isSuperUser?: BoolFieldUpdateOperationsInput | boolean
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    exam?: examUncheckedUpdateManyWithoutUsersNestedInput
    examDownloadable?: examDownloadableUncheckedUpdateManyWithoutUsersNestedInput
    form?: formUncheckedUpdateManyWithoutUsersNestedInput
    formExams?: formExamsUncheckedUpdateManyWithoutUsersNestedInput
    formReference?: formReferenceUncheckedUpdateManyWithoutUsersNestedInput
    formReview?: formReviewUncheckedUpdateManyWithoutUsersNestedInput
    note?: noteUncheckedUpdateManyWithoutUsersNestedInput
    notesDownloadable?: notesDownloadableUncheckedUpdateManyWithoutUsersNestedInput
    purchase?: purchaseUncheckedUpdateManyWithoutUsersNestedInput
    question?: questionUncheckedUpdateManyWithoutUsersNestedInput
    reference?: referenceUncheckedUpdateManyWithoutUsersNestedInput
    subject?: subjectUncheckedUpdateManyWithoutUsersNestedInput
    subjectExams?: subjectExamsUncheckedUpdateManyWithoutUsersNestedInput
    subjectReference?: subjectReferenceUncheckedUpdateManyWithoutUsersNestedInput
    subjectReview?: subjectReviewUncheckedUpdateManyWithoutUsersNestedInput
    topic?: topicUncheckedUpdateManyWithoutUsersNestedInput
    topicReview?: topicReviewUncheckedUpdateManyWithoutUsersNestedInput
    vifurushi?: vifurushiUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type questionUpsertWithWhereUniqueWithoutReviewInput = {
    where: questionWhereUniqueInput
    update: XOR<questionUpdateWithoutReviewInput, questionUncheckedUpdateWithoutReviewInput>
    create: XOR<questionCreateWithoutReviewInput, questionUncheckedCreateWithoutReviewInput>
  }

  export type questionUpdateWithWhereUniqueWithoutReviewInput = {
    where: questionWhereUniqueInput
    data: XOR<questionUpdateWithoutReviewInput, questionUncheckedUpdateWithoutReviewInput>
  }

  export type questionUpdateManyWithWhereWithoutReviewInput = {
    where: questionScalarWhereInput
    data: XOR<questionUpdateManyMutationInput, questionUncheckedUpdateManyWithoutQuestionInput>
  }

  export type questionFormatCreateWithoutQuestionInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type questionFormatUncheckedCreateWithoutQuestionInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type questionFormatCreateOrConnectWithoutQuestionInput = {
    where: questionFormatWhereUniqueInput
    create: XOR<questionFormatCreateWithoutQuestionInput, questionFormatUncheckedCreateWithoutQuestionInput>
  }

  export type reviewCreateWithoutQuestionInput = {
    name: string
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    form: formReviewCreateNestedOneWithoutReviewInput
    subject: subjectReviewCreateNestedOneWithoutReviewInput
    topic: topicReviewCreateNestedOneWithoutReviewInput
    users: usersCreateNestedOneWithoutReviewInput
  }

  export type reviewUncheckedCreateWithoutQuestionInput = {
    id?: number
    name: string
    published?: boolean
    topicId: number
    subjectId: number
    formId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    usersId: number
  }

  export type reviewCreateOrConnectWithoutQuestionInput = {
    where: reviewWhereUniqueInput
    create: XOR<reviewCreateWithoutQuestionInput, reviewUncheckedCreateWithoutQuestionInput>
  }

  export type usersCreateWithoutQuestionInput = {
    image?: string | null
    username: string
    password: string
    isAdmin?: boolean
    isSuperUser?: boolean
    dateJoined?: Date | string
    name: string
    updatedAt?: Date | string
    isOnline?: boolean
    exam?: examCreateNestedManyWithoutUsersInput
    examDownloadable?: examDownloadableCreateNestedManyWithoutUsersInput
    form?: formCreateNestedManyWithoutUsersInput
    formExams?: formExamsCreateNestedManyWithoutUsersInput
    formReference?: formReferenceCreateNestedManyWithoutUsersInput
    formReview?: formReviewCreateNestedManyWithoutUsersInput
    note?: noteCreateNestedManyWithoutUsersInput
    notesDownloadable?: notesDownloadableCreateNestedManyWithoutUsersInput
    purchase?: purchaseCreateNestedManyWithoutUsersInput
    reference?: referenceCreateNestedManyWithoutUsersInput
    review?: reviewCreateNestedManyWithoutUsersInput
    subject?: subjectCreateNestedManyWithoutUsersInput
    subjectExams?: subjectExamsCreateNestedManyWithoutUsersInput
    subjectReference?: subjectReferenceCreateNestedManyWithoutUsersInput
    subjectReview?: subjectReviewCreateNestedManyWithoutUsersInput
    topic?: topicCreateNestedManyWithoutUsersInput
    topicReview?: topicReviewCreateNestedManyWithoutUsersInput
    vifurushi?: vifurushiCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutQuestionInput = {
    id?: number
    image?: string | null
    username: string
    password: string
    isAdmin?: boolean
    isSuperUser?: boolean
    dateJoined?: Date | string
    name: string
    updatedAt?: Date | string
    isOnline?: boolean
    exam?: examUncheckedCreateNestedManyWithoutUsersInput
    examDownloadable?: examDownloadableUncheckedCreateNestedManyWithoutUsersInput
    form?: formUncheckedCreateNestedManyWithoutUsersInput
    formExams?: formExamsUncheckedCreateNestedManyWithoutUsersInput
    formReference?: formReferenceUncheckedCreateNestedManyWithoutUsersInput
    formReview?: formReviewUncheckedCreateNestedManyWithoutUsersInput
    note?: noteUncheckedCreateNestedManyWithoutUsersInput
    notesDownloadable?: notesDownloadableUncheckedCreateNestedManyWithoutUsersInput
    purchase?: purchaseUncheckedCreateNestedManyWithoutUsersInput
    reference?: referenceUncheckedCreateNestedManyWithoutUsersInput
    review?: reviewUncheckedCreateNestedManyWithoutUsersInput
    subject?: subjectUncheckedCreateNestedManyWithoutUsersInput
    subjectExams?: subjectExamsUncheckedCreateNestedManyWithoutUsersInput
    subjectReference?: subjectReferenceUncheckedCreateNestedManyWithoutUsersInput
    subjectReview?: subjectReviewUncheckedCreateNestedManyWithoutUsersInput
    topic?: topicUncheckedCreateNestedManyWithoutUsersInput
    topicReview?: topicReviewUncheckedCreateNestedManyWithoutUsersInput
    vifurushi?: vifurushiUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutQuestionInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutQuestionInput, usersUncheckedCreateWithoutQuestionInput>
  }

  export type answerCreateWithoutQuestionInput = {
    answer: string
    valid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type answerUncheckedCreateWithoutQuestionInput = {
    id?: number
    answer: string
    valid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type answerCreateOrConnectWithoutQuestionInput = {
    where: answerWhereUniqueInput
    create: XOR<answerCreateWithoutQuestionInput, answerUncheckedCreateWithoutQuestionInput>
  }

  export type answerCreateManyQuestionInputEnvelope = {
    data: Enumerable<answerCreateManyQuestionInput>
    skipDuplicates?: boolean
  }

  export type questionFormatUpsertWithoutQuestionInput = {
    update: XOR<questionFormatUpdateWithoutQuestionInput, questionFormatUncheckedUpdateWithoutQuestionInput>
    create: XOR<questionFormatCreateWithoutQuestionInput, questionFormatUncheckedCreateWithoutQuestionInput>
  }

  export type questionFormatUpdateWithoutQuestionInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type questionFormatUncheckedUpdateWithoutQuestionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type reviewUpsertWithoutQuestionInput = {
    update: XOR<reviewUpdateWithoutQuestionInput, reviewUncheckedUpdateWithoutQuestionInput>
    create: XOR<reviewCreateWithoutQuestionInput, reviewUncheckedCreateWithoutQuestionInput>
  }

  export type reviewUpdateWithoutQuestionInput = {
    name?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    form?: formReviewUpdateOneRequiredWithoutReviewNestedInput
    subject?: subjectReviewUpdateOneRequiredWithoutReviewNestedInput
    topic?: topicReviewUpdateOneRequiredWithoutReviewNestedInput
    users?: usersUpdateOneRequiredWithoutReviewNestedInput
  }

  export type reviewUncheckedUpdateWithoutQuestionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    topicId?: IntFieldUpdateOperationsInput | number
    subjectId?: IntFieldUpdateOperationsInput | number
    formId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usersId?: IntFieldUpdateOperationsInput | number
  }

  export type usersUpsertWithoutQuestionInput = {
    update: XOR<usersUpdateWithoutQuestionInput, usersUncheckedUpdateWithoutQuestionInput>
    create: XOR<usersCreateWithoutQuestionInput, usersUncheckedCreateWithoutQuestionInput>
  }

  export type usersUpdateWithoutQuestionInput = {
    image?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isSuperUser?: BoolFieldUpdateOperationsInput | boolean
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    exam?: examUpdateManyWithoutUsersNestedInput
    examDownloadable?: examDownloadableUpdateManyWithoutUsersNestedInput
    form?: formUpdateManyWithoutUsersNestedInput
    formExams?: formExamsUpdateManyWithoutUsersNestedInput
    formReference?: formReferenceUpdateManyWithoutUsersNestedInput
    formReview?: formReviewUpdateManyWithoutUsersNestedInput
    note?: noteUpdateManyWithoutUsersNestedInput
    notesDownloadable?: notesDownloadableUpdateManyWithoutUsersNestedInput
    purchase?: purchaseUpdateManyWithoutUsersNestedInput
    reference?: referenceUpdateManyWithoutUsersNestedInput
    review?: reviewUpdateManyWithoutUsersNestedInput
    subject?: subjectUpdateManyWithoutUsersNestedInput
    subjectExams?: subjectExamsUpdateManyWithoutUsersNestedInput
    subjectReference?: subjectReferenceUpdateManyWithoutUsersNestedInput
    subjectReview?: subjectReviewUpdateManyWithoutUsersNestedInput
    topic?: topicUpdateManyWithoutUsersNestedInput
    topicReview?: topicReviewUpdateManyWithoutUsersNestedInput
    vifurushi?: vifurushiUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutQuestionInput = {
    id?: IntFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isSuperUser?: BoolFieldUpdateOperationsInput | boolean
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    exam?: examUncheckedUpdateManyWithoutUsersNestedInput
    examDownloadable?: examDownloadableUncheckedUpdateManyWithoutUsersNestedInput
    form?: formUncheckedUpdateManyWithoutUsersNestedInput
    formExams?: formExamsUncheckedUpdateManyWithoutUsersNestedInput
    formReference?: formReferenceUncheckedUpdateManyWithoutUsersNestedInput
    formReview?: formReviewUncheckedUpdateManyWithoutUsersNestedInput
    note?: noteUncheckedUpdateManyWithoutUsersNestedInput
    notesDownloadable?: notesDownloadableUncheckedUpdateManyWithoutUsersNestedInput
    purchase?: purchaseUncheckedUpdateManyWithoutUsersNestedInput
    reference?: referenceUncheckedUpdateManyWithoutUsersNestedInput
    review?: reviewUncheckedUpdateManyWithoutUsersNestedInput
    subject?: subjectUncheckedUpdateManyWithoutUsersNestedInput
    subjectExams?: subjectExamsUncheckedUpdateManyWithoutUsersNestedInput
    subjectReference?: subjectReferenceUncheckedUpdateManyWithoutUsersNestedInput
    subjectReview?: subjectReviewUncheckedUpdateManyWithoutUsersNestedInput
    topic?: topicUncheckedUpdateManyWithoutUsersNestedInput
    topicReview?: topicReviewUncheckedUpdateManyWithoutUsersNestedInput
    vifurushi?: vifurushiUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type answerUpsertWithWhereUniqueWithoutQuestionInput = {
    where: answerWhereUniqueInput
    update: XOR<answerUpdateWithoutQuestionInput, answerUncheckedUpdateWithoutQuestionInput>
    create: XOR<answerCreateWithoutQuestionInput, answerUncheckedCreateWithoutQuestionInput>
  }

  export type answerUpdateWithWhereUniqueWithoutQuestionInput = {
    where: answerWhereUniqueInput
    data: XOR<answerUpdateWithoutQuestionInput, answerUncheckedUpdateWithoutQuestionInput>
  }

  export type answerUpdateManyWithWhereWithoutQuestionInput = {
    where: answerScalarWhereInput
    data: XOR<answerUpdateManyMutationInput, answerUncheckedUpdateManyWithoutAnswerInput>
  }

  export type answerScalarWhereInput = {
    AND?: Enumerable<answerScalarWhereInput>
    OR?: Enumerable<answerScalarWhereInput>
    NOT?: Enumerable<answerScalarWhereInput>
    id?: IntFilter | number
    answer?: StringFilter | string
    valid?: BoolFilter | boolean
    questionId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type questionCreateWithoutQuestionFormatInput = {
    question: string
    published?: boolean
    answerDetails?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    review: reviewCreateNestedOneWithoutQuestionInput
    users: usersCreateNestedOneWithoutQuestionInput
    answer?: answerCreateNestedManyWithoutQuestionInput
  }

  export type questionUncheckedCreateWithoutQuestionFormatInput = {
    id?: number
    question: string
    published?: boolean
    answerDetails?: string
    reviewId: number
    usersId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    answer?: answerUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type questionCreateOrConnectWithoutQuestionFormatInput = {
    where: questionWhereUniqueInput
    create: XOR<questionCreateWithoutQuestionFormatInput, questionUncheckedCreateWithoutQuestionFormatInput>
  }

  export type questionCreateManyQuestionFormatInputEnvelope = {
    data: Enumerable<questionCreateManyQuestionFormatInput>
    skipDuplicates?: boolean
  }

  export type questionUpsertWithWhereUniqueWithoutQuestionFormatInput = {
    where: questionWhereUniqueInput
    update: XOR<questionUpdateWithoutQuestionFormatInput, questionUncheckedUpdateWithoutQuestionFormatInput>
    create: XOR<questionCreateWithoutQuestionFormatInput, questionUncheckedCreateWithoutQuestionFormatInput>
  }

  export type questionUpdateWithWhereUniqueWithoutQuestionFormatInput = {
    where: questionWhereUniqueInput
    data: XOR<questionUpdateWithoutQuestionFormatInput, questionUncheckedUpdateWithoutQuestionFormatInput>
  }

  export type questionUpdateManyWithWhereWithoutQuestionFormatInput = {
    where: questionScalarWhereInput
    data: XOR<questionUpdateManyMutationInput, questionUncheckedUpdateManyWithoutQuestionInput>
  }

  export type questionCreateWithoutAnswerInput = {
    question: string
    published?: boolean
    answerDetails?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    questionFormat: questionFormatCreateNestedOneWithoutQuestionInput
    review: reviewCreateNestedOneWithoutQuestionInput
    users: usersCreateNestedOneWithoutQuestionInput
  }

  export type questionUncheckedCreateWithoutAnswerInput = {
    id?: number
    question: string
    published?: boolean
    answerDetails?: string
    questionFormatId: number
    reviewId: number
    usersId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type questionCreateOrConnectWithoutAnswerInput = {
    where: questionWhereUniqueInput
    create: XOR<questionCreateWithoutAnswerInput, questionUncheckedCreateWithoutAnswerInput>
  }

  export type questionUpsertWithoutAnswerInput = {
    update: XOR<questionUpdateWithoutAnswerInput, questionUncheckedUpdateWithoutAnswerInput>
    create: XOR<questionCreateWithoutAnswerInput, questionUncheckedCreateWithoutAnswerInput>
  }

  export type questionUpdateWithoutAnswerInput = {
    question?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    answerDetails?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questionFormat?: questionFormatUpdateOneRequiredWithoutQuestionNestedInput
    review?: reviewUpdateOneRequiredWithoutQuestionNestedInput
    users?: usersUpdateOneRequiredWithoutQuestionNestedInput
  }

  export type questionUncheckedUpdateWithoutAnswerInput = {
    id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    answerDetails?: StringFieldUpdateOperationsInput | string
    questionFormatId?: IntFieldUpdateOperationsInput | number
    reviewId?: IntFieldUpdateOperationsInput | number
    usersId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersCreateWithoutSubjectExamsInput = {
    image?: string | null
    username: string
    password: string
    isAdmin?: boolean
    isSuperUser?: boolean
    dateJoined?: Date | string
    name: string
    updatedAt?: Date | string
    isOnline?: boolean
    exam?: examCreateNestedManyWithoutUsersInput
    examDownloadable?: examDownloadableCreateNestedManyWithoutUsersInput
    form?: formCreateNestedManyWithoutUsersInput
    formExams?: formExamsCreateNestedManyWithoutUsersInput
    formReference?: formReferenceCreateNestedManyWithoutUsersInput
    formReview?: formReviewCreateNestedManyWithoutUsersInput
    note?: noteCreateNestedManyWithoutUsersInput
    notesDownloadable?: notesDownloadableCreateNestedManyWithoutUsersInput
    purchase?: purchaseCreateNestedManyWithoutUsersInput
    question?: questionCreateNestedManyWithoutUsersInput
    reference?: referenceCreateNestedManyWithoutUsersInput
    review?: reviewCreateNestedManyWithoutUsersInput
    subject?: subjectCreateNestedManyWithoutUsersInput
    subjectReference?: subjectReferenceCreateNestedManyWithoutUsersInput
    subjectReview?: subjectReviewCreateNestedManyWithoutUsersInput
    topic?: topicCreateNestedManyWithoutUsersInput
    topicReview?: topicReviewCreateNestedManyWithoutUsersInput
    vifurushi?: vifurushiCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutSubjectExamsInput = {
    id?: number
    image?: string | null
    username: string
    password: string
    isAdmin?: boolean
    isSuperUser?: boolean
    dateJoined?: Date | string
    name: string
    updatedAt?: Date | string
    isOnline?: boolean
    exam?: examUncheckedCreateNestedManyWithoutUsersInput
    examDownloadable?: examDownloadableUncheckedCreateNestedManyWithoutUsersInput
    form?: formUncheckedCreateNestedManyWithoutUsersInput
    formExams?: formExamsUncheckedCreateNestedManyWithoutUsersInput
    formReference?: formReferenceUncheckedCreateNestedManyWithoutUsersInput
    formReview?: formReviewUncheckedCreateNestedManyWithoutUsersInput
    note?: noteUncheckedCreateNestedManyWithoutUsersInput
    notesDownloadable?: notesDownloadableUncheckedCreateNestedManyWithoutUsersInput
    purchase?: purchaseUncheckedCreateNestedManyWithoutUsersInput
    question?: questionUncheckedCreateNestedManyWithoutUsersInput
    reference?: referenceUncheckedCreateNestedManyWithoutUsersInput
    review?: reviewUncheckedCreateNestedManyWithoutUsersInput
    subject?: subjectUncheckedCreateNestedManyWithoutUsersInput
    subjectReference?: subjectReferenceUncheckedCreateNestedManyWithoutUsersInput
    subjectReview?: subjectReviewUncheckedCreateNestedManyWithoutUsersInput
    topic?: topicUncheckedCreateNestedManyWithoutUsersInput
    topicReview?: topicReviewUncheckedCreateNestedManyWithoutUsersInput
    vifurushi?: vifurushiUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutSubjectExamsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutSubjectExamsInput, usersUncheckedCreateWithoutSubjectExamsInput>
  }

  export type examTypeCreateWithoutSubjectExamsInput = {
    name: string
    definition: string
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    formExams: formExamsCreateNestedOneWithoutExamTypeInput
    exam?: examCreateNestedManyWithoutExamTypeInput
  }

  export type examTypeUncheckedCreateWithoutSubjectExamsInput = {
    id?: number
    name: string
    definition: string
    published?: boolean
    formId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    exam?: examUncheckedCreateNestedManyWithoutExamTypeInput
  }

  export type examTypeCreateOrConnectWithoutSubjectExamsInput = {
    where: examTypeWhereUniqueInput
    create: XOR<examTypeCreateWithoutSubjectExamsInput, examTypeUncheckedCreateWithoutSubjectExamsInput>
  }

  export type examTypeCreateManySubjectExamsInputEnvelope = {
    data: Enumerable<examTypeCreateManySubjectExamsInput>
    skipDuplicates?: boolean
  }

  export type formExamsCreateWithoutSubjectsInput = {
    formName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users: usersCreateNestedOneWithoutFormExamsInput
    examType?: examTypeCreateNestedManyWithoutFormExamsInput
  }

  export type formExamsUncheckedCreateWithoutSubjectsInput = {
    id?: number
    formName: string
    usersId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    examType?: examTypeUncheckedCreateNestedManyWithoutFormExamsInput
  }

  export type formExamsCreateOrConnectWithoutSubjectsInput = {
    where: formExamsWhereUniqueInput
    create: XOR<formExamsCreateWithoutSubjectsInput, formExamsUncheckedCreateWithoutSubjectsInput>
  }

  export type usersUpsertWithoutSubjectExamsInput = {
    update: XOR<usersUpdateWithoutSubjectExamsInput, usersUncheckedUpdateWithoutSubjectExamsInput>
    create: XOR<usersCreateWithoutSubjectExamsInput, usersUncheckedCreateWithoutSubjectExamsInput>
  }

  export type usersUpdateWithoutSubjectExamsInput = {
    image?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isSuperUser?: BoolFieldUpdateOperationsInput | boolean
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    exam?: examUpdateManyWithoutUsersNestedInput
    examDownloadable?: examDownloadableUpdateManyWithoutUsersNestedInput
    form?: formUpdateManyWithoutUsersNestedInput
    formExams?: formExamsUpdateManyWithoutUsersNestedInput
    formReference?: formReferenceUpdateManyWithoutUsersNestedInput
    formReview?: formReviewUpdateManyWithoutUsersNestedInput
    note?: noteUpdateManyWithoutUsersNestedInput
    notesDownloadable?: notesDownloadableUpdateManyWithoutUsersNestedInput
    purchase?: purchaseUpdateManyWithoutUsersNestedInput
    question?: questionUpdateManyWithoutUsersNestedInput
    reference?: referenceUpdateManyWithoutUsersNestedInput
    review?: reviewUpdateManyWithoutUsersNestedInput
    subject?: subjectUpdateManyWithoutUsersNestedInput
    subjectReference?: subjectReferenceUpdateManyWithoutUsersNestedInput
    subjectReview?: subjectReviewUpdateManyWithoutUsersNestedInput
    topic?: topicUpdateManyWithoutUsersNestedInput
    topicReview?: topicReviewUpdateManyWithoutUsersNestedInput
    vifurushi?: vifurushiUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutSubjectExamsInput = {
    id?: IntFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isSuperUser?: BoolFieldUpdateOperationsInput | boolean
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    exam?: examUncheckedUpdateManyWithoutUsersNestedInput
    examDownloadable?: examDownloadableUncheckedUpdateManyWithoutUsersNestedInput
    form?: formUncheckedUpdateManyWithoutUsersNestedInput
    formExams?: formExamsUncheckedUpdateManyWithoutUsersNestedInput
    formReference?: formReferenceUncheckedUpdateManyWithoutUsersNestedInput
    formReview?: formReviewUncheckedUpdateManyWithoutUsersNestedInput
    note?: noteUncheckedUpdateManyWithoutUsersNestedInput
    notesDownloadable?: notesDownloadableUncheckedUpdateManyWithoutUsersNestedInput
    purchase?: purchaseUncheckedUpdateManyWithoutUsersNestedInput
    question?: questionUncheckedUpdateManyWithoutUsersNestedInput
    reference?: referenceUncheckedUpdateManyWithoutUsersNestedInput
    review?: reviewUncheckedUpdateManyWithoutUsersNestedInput
    subject?: subjectUncheckedUpdateManyWithoutUsersNestedInput
    subjectReference?: subjectReferenceUncheckedUpdateManyWithoutUsersNestedInput
    subjectReview?: subjectReviewUncheckedUpdateManyWithoutUsersNestedInput
    topic?: topicUncheckedUpdateManyWithoutUsersNestedInput
    topicReview?: topicReviewUncheckedUpdateManyWithoutUsersNestedInput
    vifurushi?: vifurushiUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type examTypeUpsertWithWhereUniqueWithoutSubjectExamsInput = {
    where: examTypeWhereUniqueInput
    update: XOR<examTypeUpdateWithoutSubjectExamsInput, examTypeUncheckedUpdateWithoutSubjectExamsInput>
    create: XOR<examTypeCreateWithoutSubjectExamsInput, examTypeUncheckedCreateWithoutSubjectExamsInput>
  }

  export type examTypeUpdateWithWhereUniqueWithoutSubjectExamsInput = {
    where: examTypeWhereUniqueInput
    data: XOR<examTypeUpdateWithoutSubjectExamsInput, examTypeUncheckedUpdateWithoutSubjectExamsInput>
  }

  export type examTypeUpdateManyWithWhereWithoutSubjectExamsInput = {
    where: examTypeScalarWhereInput
    data: XOR<examTypeUpdateManyMutationInput, examTypeUncheckedUpdateManyWithoutExamTypeInput>
  }

  export type examTypeScalarWhereInput = {
    AND?: Enumerable<examTypeScalarWhereInput>
    OR?: Enumerable<examTypeScalarWhereInput>
    NOT?: Enumerable<examTypeScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    definition?: StringFilter | string
    published?: BoolFilter | boolean
    subjectId?: IntFilter | number
    formId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type formExamsUpsertWithWhereUniqueWithoutSubjectsInput = {
    where: formExamsWhereUniqueInput
    update: XOR<formExamsUpdateWithoutSubjectsInput, formExamsUncheckedUpdateWithoutSubjectsInput>
    create: XOR<formExamsCreateWithoutSubjectsInput, formExamsUncheckedCreateWithoutSubjectsInput>
  }

  export type formExamsUpdateWithWhereUniqueWithoutSubjectsInput = {
    where: formExamsWhereUniqueInput
    data: XOR<formExamsUpdateWithoutSubjectsInput, formExamsUncheckedUpdateWithoutSubjectsInput>
  }

  export type formExamsUpdateManyWithWhereWithoutSubjectsInput = {
    where: formExamsScalarWhereInput
    data: XOR<formExamsUpdateManyMutationInput, formExamsUncheckedUpdateManyWithoutFormsInput>
  }

  export type usersCreateWithoutFormExamsInput = {
    image?: string | null
    username: string
    password: string
    isAdmin?: boolean
    isSuperUser?: boolean
    dateJoined?: Date | string
    name: string
    updatedAt?: Date | string
    isOnline?: boolean
    exam?: examCreateNestedManyWithoutUsersInput
    examDownloadable?: examDownloadableCreateNestedManyWithoutUsersInput
    form?: formCreateNestedManyWithoutUsersInput
    formReference?: formReferenceCreateNestedManyWithoutUsersInput
    formReview?: formReviewCreateNestedManyWithoutUsersInput
    note?: noteCreateNestedManyWithoutUsersInput
    notesDownloadable?: notesDownloadableCreateNestedManyWithoutUsersInput
    purchase?: purchaseCreateNestedManyWithoutUsersInput
    question?: questionCreateNestedManyWithoutUsersInput
    reference?: referenceCreateNestedManyWithoutUsersInput
    review?: reviewCreateNestedManyWithoutUsersInput
    subject?: subjectCreateNestedManyWithoutUsersInput
    subjectExams?: subjectExamsCreateNestedManyWithoutUsersInput
    subjectReference?: subjectReferenceCreateNestedManyWithoutUsersInput
    subjectReview?: subjectReviewCreateNestedManyWithoutUsersInput
    topic?: topicCreateNestedManyWithoutUsersInput
    topicReview?: topicReviewCreateNestedManyWithoutUsersInput
    vifurushi?: vifurushiCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutFormExamsInput = {
    id?: number
    image?: string | null
    username: string
    password: string
    isAdmin?: boolean
    isSuperUser?: boolean
    dateJoined?: Date | string
    name: string
    updatedAt?: Date | string
    isOnline?: boolean
    exam?: examUncheckedCreateNestedManyWithoutUsersInput
    examDownloadable?: examDownloadableUncheckedCreateNestedManyWithoutUsersInput
    form?: formUncheckedCreateNestedManyWithoutUsersInput
    formReference?: formReferenceUncheckedCreateNestedManyWithoutUsersInput
    formReview?: formReviewUncheckedCreateNestedManyWithoutUsersInput
    note?: noteUncheckedCreateNestedManyWithoutUsersInput
    notesDownloadable?: notesDownloadableUncheckedCreateNestedManyWithoutUsersInput
    purchase?: purchaseUncheckedCreateNestedManyWithoutUsersInput
    question?: questionUncheckedCreateNestedManyWithoutUsersInput
    reference?: referenceUncheckedCreateNestedManyWithoutUsersInput
    review?: reviewUncheckedCreateNestedManyWithoutUsersInput
    subject?: subjectUncheckedCreateNestedManyWithoutUsersInput
    subjectExams?: subjectExamsUncheckedCreateNestedManyWithoutUsersInput
    subjectReference?: subjectReferenceUncheckedCreateNestedManyWithoutUsersInput
    subjectReview?: subjectReviewUncheckedCreateNestedManyWithoutUsersInput
    topic?: topicUncheckedCreateNestedManyWithoutUsersInput
    topicReview?: topicReviewUncheckedCreateNestedManyWithoutUsersInput
    vifurushi?: vifurushiUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutFormExamsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutFormExamsInput, usersUncheckedCreateWithoutFormExamsInput>
  }

  export type examTypeCreateWithoutFormExamsInput = {
    name: string
    definition: string
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    subjectExams: subjectExamsCreateNestedOneWithoutExamTypeInput
    exam?: examCreateNestedManyWithoutExamTypeInput
  }

  export type examTypeUncheckedCreateWithoutFormExamsInput = {
    id?: number
    name: string
    definition: string
    published?: boolean
    subjectId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    exam?: examUncheckedCreateNestedManyWithoutExamTypeInput
  }

  export type examTypeCreateOrConnectWithoutFormExamsInput = {
    where: examTypeWhereUniqueInput
    create: XOR<examTypeCreateWithoutFormExamsInput, examTypeUncheckedCreateWithoutFormExamsInput>
  }

  export type examTypeCreateManyFormExamsInputEnvelope = {
    data: Enumerable<examTypeCreateManyFormExamsInput>
    skipDuplicates?: boolean
  }

  export type subjectExamsCreateWithoutFormsInput = {
    subjectName: string
    subjectDefinition: string
    imageLocation?: string | null
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users: usersCreateNestedOneWithoutSubjectExamsInput
    examType?: examTypeCreateNestedManyWithoutSubjectExamsInput
  }

  export type subjectExamsUncheckedCreateWithoutFormsInput = {
    id?: number
    subjectName: string
    subjectDefinition: string
    imageLocation?: string | null
    published?: boolean
    usersId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    examType?: examTypeUncheckedCreateNestedManyWithoutSubjectExamsInput
  }

  export type subjectExamsCreateOrConnectWithoutFormsInput = {
    where: subjectExamsWhereUniqueInput
    create: XOR<subjectExamsCreateWithoutFormsInput, subjectExamsUncheckedCreateWithoutFormsInput>
  }

  export type usersUpsertWithoutFormExamsInput = {
    update: XOR<usersUpdateWithoutFormExamsInput, usersUncheckedUpdateWithoutFormExamsInput>
    create: XOR<usersCreateWithoutFormExamsInput, usersUncheckedCreateWithoutFormExamsInput>
  }

  export type usersUpdateWithoutFormExamsInput = {
    image?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isSuperUser?: BoolFieldUpdateOperationsInput | boolean
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    exam?: examUpdateManyWithoutUsersNestedInput
    examDownloadable?: examDownloadableUpdateManyWithoutUsersNestedInput
    form?: formUpdateManyWithoutUsersNestedInput
    formReference?: formReferenceUpdateManyWithoutUsersNestedInput
    formReview?: formReviewUpdateManyWithoutUsersNestedInput
    note?: noteUpdateManyWithoutUsersNestedInput
    notesDownloadable?: notesDownloadableUpdateManyWithoutUsersNestedInput
    purchase?: purchaseUpdateManyWithoutUsersNestedInput
    question?: questionUpdateManyWithoutUsersNestedInput
    reference?: referenceUpdateManyWithoutUsersNestedInput
    review?: reviewUpdateManyWithoutUsersNestedInput
    subject?: subjectUpdateManyWithoutUsersNestedInput
    subjectExams?: subjectExamsUpdateManyWithoutUsersNestedInput
    subjectReference?: subjectReferenceUpdateManyWithoutUsersNestedInput
    subjectReview?: subjectReviewUpdateManyWithoutUsersNestedInput
    topic?: topicUpdateManyWithoutUsersNestedInput
    topicReview?: topicReviewUpdateManyWithoutUsersNestedInput
    vifurushi?: vifurushiUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutFormExamsInput = {
    id?: IntFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isSuperUser?: BoolFieldUpdateOperationsInput | boolean
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    exam?: examUncheckedUpdateManyWithoutUsersNestedInput
    examDownloadable?: examDownloadableUncheckedUpdateManyWithoutUsersNestedInput
    form?: formUncheckedUpdateManyWithoutUsersNestedInput
    formReference?: formReferenceUncheckedUpdateManyWithoutUsersNestedInput
    formReview?: formReviewUncheckedUpdateManyWithoutUsersNestedInput
    note?: noteUncheckedUpdateManyWithoutUsersNestedInput
    notesDownloadable?: notesDownloadableUncheckedUpdateManyWithoutUsersNestedInput
    purchase?: purchaseUncheckedUpdateManyWithoutUsersNestedInput
    question?: questionUncheckedUpdateManyWithoutUsersNestedInput
    reference?: referenceUncheckedUpdateManyWithoutUsersNestedInput
    review?: reviewUncheckedUpdateManyWithoutUsersNestedInput
    subject?: subjectUncheckedUpdateManyWithoutUsersNestedInput
    subjectExams?: subjectExamsUncheckedUpdateManyWithoutUsersNestedInput
    subjectReference?: subjectReferenceUncheckedUpdateManyWithoutUsersNestedInput
    subjectReview?: subjectReviewUncheckedUpdateManyWithoutUsersNestedInput
    topic?: topicUncheckedUpdateManyWithoutUsersNestedInput
    topicReview?: topicReviewUncheckedUpdateManyWithoutUsersNestedInput
    vifurushi?: vifurushiUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type examTypeUpsertWithWhereUniqueWithoutFormExamsInput = {
    where: examTypeWhereUniqueInput
    update: XOR<examTypeUpdateWithoutFormExamsInput, examTypeUncheckedUpdateWithoutFormExamsInput>
    create: XOR<examTypeCreateWithoutFormExamsInput, examTypeUncheckedCreateWithoutFormExamsInput>
  }

  export type examTypeUpdateWithWhereUniqueWithoutFormExamsInput = {
    where: examTypeWhereUniqueInput
    data: XOR<examTypeUpdateWithoutFormExamsInput, examTypeUncheckedUpdateWithoutFormExamsInput>
  }

  export type examTypeUpdateManyWithWhereWithoutFormExamsInput = {
    where: examTypeScalarWhereInput
    data: XOR<examTypeUpdateManyMutationInput, examTypeUncheckedUpdateManyWithoutExamTypeInput>
  }

  export type subjectExamsUpsertWithWhereUniqueWithoutFormsInput = {
    where: subjectExamsWhereUniqueInput
    update: XOR<subjectExamsUpdateWithoutFormsInput, subjectExamsUncheckedUpdateWithoutFormsInput>
    create: XOR<subjectExamsCreateWithoutFormsInput, subjectExamsUncheckedCreateWithoutFormsInput>
  }

  export type subjectExamsUpdateWithWhereUniqueWithoutFormsInput = {
    where: subjectExamsWhereUniqueInput
    data: XOR<subjectExamsUpdateWithoutFormsInput, subjectExamsUncheckedUpdateWithoutFormsInput>
  }

  export type subjectExamsUpdateManyWithWhereWithoutFormsInput = {
    where: subjectExamsScalarWhereInput
    data: XOR<subjectExamsUpdateManyMutationInput, subjectExamsUncheckedUpdateManyWithoutSubjectsInput>
  }

  export type formExamsCreateWithoutExamTypeInput = {
    formName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users: usersCreateNestedOneWithoutFormExamsInput
    subjects?: subjectExamsCreateNestedManyWithoutFormsInput
  }

  export type formExamsUncheckedCreateWithoutExamTypeInput = {
    id?: number
    formName: string
    usersId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    subjects?: subjectExamsUncheckedCreateNestedManyWithoutFormsInput
  }

  export type formExamsCreateOrConnectWithoutExamTypeInput = {
    where: formExamsWhereUniqueInput
    create: XOR<formExamsCreateWithoutExamTypeInput, formExamsUncheckedCreateWithoutExamTypeInput>
  }

  export type subjectExamsCreateWithoutExamTypeInput = {
    subjectName: string
    subjectDefinition: string
    imageLocation?: string | null
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users: usersCreateNestedOneWithoutSubjectExamsInput
    forms?: formExamsCreateNestedManyWithoutSubjectsInput
  }

  export type subjectExamsUncheckedCreateWithoutExamTypeInput = {
    id?: number
    subjectName: string
    subjectDefinition: string
    imageLocation?: string | null
    published?: boolean
    usersId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    forms?: formExamsUncheckedCreateNestedManyWithoutSubjectsInput
  }

  export type subjectExamsCreateOrConnectWithoutExamTypeInput = {
    where: subjectExamsWhereUniqueInput
    create: XOR<subjectExamsCreateWithoutExamTypeInput, subjectExamsUncheckedCreateWithoutExamTypeInput>
  }

  export type examCreateWithoutExamTypeInput = {
    description: string
    year: number
    hasAnswers?: boolean
    published?: boolean
    exam: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users: usersCreateNestedOneWithoutExamInput
    examDownloadable?: examDownloadableCreateNestedManyWithoutExamInput
  }

  export type examUncheckedCreateWithoutExamTypeInput = {
    id?: number
    description: string
    year: number
    hasAnswers?: boolean
    published?: boolean
    exam: string
    usersId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    examDownloadable?: examDownloadableUncheckedCreateNestedManyWithoutExamInput
  }

  export type examCreateOrConnectWithoutExamTypeInput = {
    where: examWhereUniqueInput
    create: XOR<examCreateWithoutExamTypeInput, examUncheckedCreateWithoutExamTypeInput>
  }

  export type examCreateManyExamTypeInputEnvelope = {
    data: Enumerable<examCreateManyExamTypeInput>
    skipDuplicates?: boolean
  }

  export type formExamsUpsertWithoutExamTypeInput = {
    update: XOR<formExamsUpdateWithoutExamTypeInput, formExamsUncheckedUpdateWithoutExamTypeInput>
    create: XOR<formExamsCreateWithoutExamTypeInput, formExamsUncheckedCreateWithoutExamTypeInput>
  }

  export type formExamsUpdateWithoutExamTypeInput = {
    formName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutFormExamsNestedInput
    subjects?: subjectExamsUpdateManyWithoutFormsNestedInput
  }

  export type formExamsUncheckedUpdateWithoutExamTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    formName?: StringFieldUpdateOperationsInput | string
    usersId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: subjectExamsUncheckedUpdateManyWithoutFormsNestedInput
  }

  export type subjectExamsUpsertWithoutExamTypeInput = {
    update: XOR<subjectExamsUpdateWithoutExamTypeInput, subjectExamsUncheckedUpdateWithoutExamTypeInput>
    create: XOR<subjectExamsCreateWithoutExamTypeInput, subjectExamsUncheckedCreateWithoutExamTypeInput>
  }

  export type subjectExamsUpdateWithoutExamTypeInput = {
    subjectName?: StringFieldUpdateOperationsInput | string
    subjectDefinition?: StringFieldUpdateOperationsInput | string
    imageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutSubjectExamsNestedInput
    forms?: formExamsUpdateManyWithoutSubjectsNestedInput
  }

  export type subjectExamsUncheckedUpdateWithoutExamTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    subjectName?: StringFieldUpdateOperationsInput | string
    subjectDefinition?: StringFieldUpdateOperationsInput | string
    imageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    usersId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    forms?: formExamsUncheckedUpdateManyWithoutSubjectsNestedInput
  }

  export type examUpsertWithWhereUniqueWithoutExamTypeInput = {
    where: examWhereUniqueInput
    update: XOR<examUpdateWithoutExamTypeInput, examUncheckedUpdateWithoutExamTypeInput>
    create: XOR<examCreateWithoutExamTypeInput, examUncheckedCreateWithoutExamTypeInput>
  }

  export type examUpdateWithWhereUniqueWithoutExamTypeInput = {
    where: examWhereUniqueInput
    data: XOR<examUpdateWithoutExamTypeInput, examUncheckedUpdateWithoutExamTypeInput>
  }

  export type examUpdateManyWithWhereWithoutExamTypeInput = {
    where: examScalarWhereInput
    data: XOR<examUpdateManyMutationInput, examUncheckedUpdateManyWithoutExamInput>
  }

  export type examTypeCreateWithoutExamInput = {
    name: string
    definition: string
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    formExams: formExamsCreateNestedOneWithoutExamTypeInput
    subjectExams: subjectExamsCreateNestedOneWithoutExamTypeInput
  }

  export type examTypeUncheckedCreateWithoutExamInput = {
    id?: number
    name: string
    definition: string
    published?: boolean
    subjectId: number
    formId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type examTypeCreateOrConnectWithoutExamInput = {
    where: examTypeWhereUniqueInput
    create: XOR<examTypeCreateWithoutExamInput, examTypeUncheckedCreateWithoutExamInput>
  }

  export type usersCreateWithoutExamInput = {
    image?: string | null
    username: string
    password: string
    isAdmin?: boolean
    isSuperUser?: boolean
    dateJoined?: Date | string
    name: string
    updatedAt?: Date | string
    isOnline?: boolean
    examDownloadable?: examDownloadableCreateNestedManyWithoutUsersInput
    form?: formCreateNestedManyWithoutUsersInput
    formExams?: formExamsCreateNestedManyWithoutUsersInput
    formReference?: formReferenceCreateNestedManyWithoutUsersInput
    formReview?: formReviewCreateNestedManyWithoutUsersInput
    note?: noteCreateNestedManyWithoutUsersInput
    notesDownloadable?: notesDownloadableCreateNestedManyWithoutUsersInput
    purchase?: purchaseCreateNestedManyWithoutUsersInput
    question?: questionCreateNestedManyWithoutUsersInput
    reference?: referenceCreateNestedManyWithoutUsersInput
    review?: reviewCreateNestedManyWithoutUsersInput
    subject?: subjectCreateNestedManyWithoutUsersInput
    subjectExams?: subjectExamsCreateNestedManyWithoutUsersInput
    subjectReference?: subjectReferenceCreateNestedManyWithoutUsersInput
    subjectReview?: subjectReviewCreateNestedManyWithoutUsersInput
    topic?: topicCreateNestedManyWithoutUsersInput
    topicReview?: topicReviewCreateNestedManyWithoutUsersInput
    vifurushi?: vifurushiCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutExamInput = {
    id?: number
    image?: string | null
    username: string
    password: string
    isAdmin?: boolean
    isSuperUser?: boolean
    dateJoined?: Date | string
    name: string
    updatedAt?: Date | string
    isOnline?: boolean
    examDownloadable?: examDownloadableUncheckedCreateNestedManyWithoutUsersInput
    form?: formUncheckedCreateNestedManyWithoutUsersInput
    formExams?: formExamsUncheckedCreateNestedManyWithoutUsersInput
    formReference?: formReferenceUncheckedCreateNestedManyWithoutUsersInput
    formReview?: formReviewUncheckedCreateNestedManyWithoutUsersInput
    note?: noteUncheckedCreateNestedManyWithoutUsersInput
    notesDownloadable?: notesDownloadableUncheckedCreateNestedManyWithoutUsersInput
    purchase?: purchaseUncheckedCreateNestedManyWithoutUsersInput
    question?: questionUncheckedCreateNestedManyWithoutUsersInput
    reference?: referenceUncheckedCreateNestedManyWithoutUsersInput
    review?: reviewUncheckedCreateNestedManyWithoutUsersInput
    subject?: subjectUncheckedCreateNestedManyWithoutUsersInput
    subjectExams?: subjectExamsUncheckedCreateNestedManyWithoutUsersInput
    subjectReference?: subjectReferenceUncheckedCreateNestedManyWithoutUsersInput
    subjectReview?: subjectReviewUncheckedCreateNestedManyWithoutUsersInput
    topic?: topicUncheckedCreateNestedManyWithoutUsersInput
    topicReview?: topicReviewUncheckedCreateNestedManyWithoutUsersInput
    vifurushi?: vifurushiUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutExamInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutExamInput, usersUncheckedCreateWithoutExamInput>
  }

  export type examDownloadableCreateWithoutExamInput = {
    link: string
    fileExtension: string
    published?: boolean
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users: usersCreateNestedOneWithoutExamDownloadableInput
  }

  export type examDownloadableUncheckedCreateWithoutExamInput = {
    id?: number
    link: string
    fileExtension: string
    published?: boolean
    usersId: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type examDownloadableCreateOrConnectWithoutExamInput = {
    where: examDownloadableWhereUniqueInput
    create: XOR<examDownloadableCreateWithoutExamInput, examDownloadableUncheckedCreateWithoutExamInput>
  }

  export type examDownloadableCreateManyExamInputEnvelope = {
    data: Enumerable<examDownloadableCreateManyExamInput>
    skipDuplicates?: boolean
  }

  export type examTypeUpsertWithoutExamInput = {
    update: XOR<examTypeUpdateWithoutExamInput, examTypeUncheckedUpdateWithoutExamInput>
    create: XOR<examTypeCreateWithoutExamInput, examTypeUncheckedCreateWithoutExamInput>
  }

  export type examTypeUpdateWithoutExamInput = {
    name?: StringFieldUpdateOperationsInput | string
    definition?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    formExams?: formExamsUpdateOneRequiredWithoutExamTypeNestedInput
    subjectExams?: subjectExamsUpdateOneRequiredWithoutExamTypeNestedInput
  }

  export type examTypeUncheckedUpdateWithoutExamInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    definition?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    subjectId?: IntFieldUpdateOperationsInput | number
    formId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersUpsertWithoutExamInput = {
    update: XOR<usersUpdateWithoutExamInput, usersUncheckedUpdateWithoutExamInput>
    create: XOR<usersCreateWithoutExamInput, usersUncheckedCreateWithoutExamInput>
  }

  export type usersUpdateWithoutExamInput = {
    image?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isSuperUser?: BoolFieldUpdateOperationsInput | boolean
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    examDownloadable?: examDownloadableUpdateManyWithoutUsersNestedInput
    form?: formUpdateManyWithoutUsersNestedInput
    formExams?: formExamsUpdateManyWithoutUsersNestedInput
    formReference?: formReferenceUpdateManyWithoutUsersNestedInput
    formReview?: formReviewUpdateManyWithoutUsersNestedInput
    note?: noteUpdateManyWithoutUsersNestedInput
    notesDownloadable?: notesDownloadableUpdateManyWithoutUsersNestedInput
    purchase?: purchaseUpdateManyWithoutUsersNestedInput
    question?: questionUpdateManyWithoutUsersNestedInput
    reference?: referenceUpdateManyWithoutUsersNestedInput
    review?: reviewUpdateManyWithoutUsersNestedInput
    subject?: subjectUpdateManyWithoutUsersNestedInput
    subjectExams?: subjectExamsUpdateManyWithoutUsersNestedInput
    subjectReference?: subjectReferenceUpdateManyWithoutUsersNestedInput
    subjectReview?: subjectReviewUpdateManyWithoutUsersNestedInput
    topic?: topicUpdateManyWithoutUsersNestedInput
    topicReview?: topicReviewUpdateManyWithoutUsersNestedInput
    vifurushi?: vifurushiUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutExamInput = {
    id?: IntFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isSuperUser?: BoolFieldUpdateOperationsInput | boolean
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    examDownloadable?: examDownloadableUncheckedUpdateManyWithoutUsersNestedInput
    form?: formUncheckedUpdateManyWithoutUsersNestedInput
    formExams?: formExamsUncheckedUpdateManyWithoutUsersNestedInput
    formReference?: formReferenceUncheckedUpdateManyWithoutUsersNestedInput
    formReview?: formReviewUncheckedUpdateManyWithoutUsersNestedInput
    note?: noteUncheckedUpdateManyWithoutUsersNestedInput
    notesDownloadable?: notesDownloadableUncheckedUpdateManyWithoutUsersNestedInput
    purchase?: purchaseUncheckedUpdateManyWithoutUsersNestedInput
    question?: questionUncheckedUpdateManyWithoutUsersNestedInput
    reference?: referenceUncheckedUpdateManyWithoutUsersNestedInput
    review?: reviewUncheckedUpdateManyWithoutUsersNestedInput
    subject?: subjectUncheckedUpdateManyWithoutUsersNestedInput
    subjectExams?: subjectExamsUncheckedUpdateManyWithoutUsersNestedInput
    subjectReference?: subjectReferenceUncheckedUpdateManyWithoutUsersNestedInput
    subjectReview?: subjectReviewUncheckedUpdateManyWithoutUsersNestedInput
    topic?: topicUncheckedUpdateManyWithoutUsersNestedInput
    topicReview?: topicReviewUncheckedUpdateManyWithoutUsersNestedInput
    vifurushi?: vifurushiUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type examDownloadableUpsertWithWhereUniqueWithoutExamInput = {
    where: examDownloadableWhereUniqueInput
    update: XOR<examDownloadableUpdateWithoutExamInput, examDownloadableUncheckedUpdateWithoutExamInput>
    create: XOR<examDownloadableCreateWithoutExamInput, examDownloadableUncheckedCreateWithoutExamInput>
  }

  export type examDownloadableUpdateWithWhereUniqueWithoutExamInput = {
    where: examDownloadableWhereUniqueInput
    data: XOR<examDownloadableUpdateWithoutExamInput, examDownloadableUncheckedUpdateWithoutExamInput>
  }

  export type examDownloadableUpdateManyWithWhereWithoutExamInput = {
    where: examDownloadableScalarWhereInput
    data: XOR<examDownloadableUpdateManyMutationInput, examDownloadableUncheckedUpdateManyWithoutExamDownloadableInput>
  }

  export type examCreateWithoutExamDownloadableInput = {
    description: string
    year: number
    hasAnswers?: boolean
    published?: boolean
    exam: string
    createdAt?: Date | string
    updatedAt?: Date | string
    examType: examTypeCreateNestedOneWithoutExamInput
    users: usersCreateNestedOneWithoutExamInput
  }

  export type examUncheckedCreateWithoutExamDownloadableInput = {
    id?: number
    description: string
    year: number
    hasAnswers?: boolean
    published?: boolean
    examTypeId: number
    exam: string
    usersId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type examCreateOrConnectWithoutExamDownloadableInput = {
    where: examWhereUniqueInput
    create: XOR<examCreateWithoutExamDownloadableInput, examUncheckedCreateWithoutExamDownloadableInput>
  }

  export type usersCreateWithoutExamDownloadableInput = {
    image?: string | null
    username: string
    password: string
    isAdmin?: boolean
    isSuperUser?: boolean
    dateJoined?: Date | string
    name: string
    updatedAt?: Date | string
    isOnline?: boolean
    exam?: examCreateNestedManyWithoutUsersInput
    form?: formCreateNestedManyWithoutUsersInput
    formExams?: formExamsCreateNestedManyWithoutUsersInput
    formReference?: formReferenceCreateNestedManyWithoutUsersInput
    formReview?: formReviewCreateNestedManyWithoutUsersInput
    note?: noteCreateNestedManyWithoutUsersInput
    notesDownloadable?: notesDownloadableCreateNestedManyWithoutUsersInput
    purchase?: purchaseCreateNestedManyWithoutUsersInput
    question?: questionCreateNestedManyWithoutUsersInput
    reference?: referenceCreateNestedManyWithoutUsersInput
    review?: reviewCreateNestedManyWithoutUsersInput
    subject?: subjectCreateNestedManyWithoutUsersInput
    subjectExams?: subjectExamsCreateNestedManyWithoutUsersInput
    subjectReference?: subjectReferenceCreateNestedManyWithoutUsersInput
    subjectReview?: subjectReviewCreateNestedManyWithoutUsersInput
    topic?: topicCreateNestedManyWithoutUsersInput
    topicReview?: topicReviewCreateNestedManyWithoutUsersInput
    vifurushi?: vifurushiCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutExamDownloadableInput = {
    id?: number
    image?: string | null
    username: string
    password: string
    isAdmin?: boolean
    isSuperUser?: boolean
    dateJoined?: Date | string
    name: string
    updatedAt?: Date | string
    isOnline?: boolean
    exam?: examUncheckedCreateNestedManyWithoutUsersInput
    form?: formUncheckedCreateNestedManyWithoutUsersInput
    formExams?: formExamsUncheckedCreateNestedManyWithoutUsersInput
    formReference?: formReferenceUncheckedCreateNestedManyWithoutUsersInput
    formReview?: formReviewUncheckedCreateNestedManyWithoutUsersInput
    note?: noteUncheckedCreateNestedManyWithoutUsersInput
    notesDownloadable?: notesDownloadableUncheckedCreateNestedManyWithoutUsersInput
    purchase?: purchaseUncheckedCreateNestedManyWithoutUsersInput
    question?: questionUncheckedCreateNestedManyWithoutUsersInput
    reference?: referenceUncheckedCreateNestedManyWithoutUsersInput
    review?: reviewUncheckedCreateNestedManyWithoutUsersInput
    subject?: subjectUncheckedCreateNestedManyWithoutUsersInput
    subjectExams?: subjectExamsUncheckedCreateNestedManyWithoutUsersInput
    subjectReference?: subjectReferenceUncheckedCreateNestedManyWithoutUsersInput
    subjectReview?: subjectReviewUncheckedCreateNestedManyWithoutUsersInput
    topic?: topicUncheckedCreateNestedManyWithoutUsersInput
    topicReview?: topicReviewUncheckedCreateNestedManyWithoutUsersInput
    vifurushi?: vifurushiUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutExamDownloadableInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutExamDownloadableInput, usersUncheckedCreateWithoutExamDownloadableInput>
  }

  export type examUpsertWithoutExamDownloadableInput = {
    update: XOR<examUpdateWithoutExamDownloadableInput, examUncheckedUpdateWithoutExamDownloadableInput>
    create: XOR<examCreateWithoutExamDownloadableInput, examUncheckedCreateWithoutExamDownloadableInput>
  }

  export type examUpdateWithoutExamDownloadableInput = {
    description?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    hasAnswers?: BoolFieldUpdateOperationsInput | boolean
    published?: BoolFieldUpdateOperationsInput | boolean
    exam?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examType?: examTypeUpdateOneRequiredWithoutExamNestedInput
    users?: usersUpdateOneRequiredWithoutExamNestedInput
  }

  export type examUncheckedUpdateWithoutExamDownloadableInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    hasAnswers?: BoolFieldUpdateOperationsInput | boolean
    published?: BoolFieldUpdateOperationsInput | boolean
    examTypeId?: IntFieldUpdateOperationsInput | number
    exam?: StringFieldUpdateOperationsInput | string
    usersId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersUpsertWithoutExamDownloadableInput = {
    update: XOR<usersUpdateWithoutExamDownloadableInput, usersUncheckedUpdateWithoutExamDownloadableInput>
    create: XOR<usersCreateWithoutExamDownloadableInput, usersUncheckedCreateWithoutExamDownloadableInput>
  }

  export type usersUpdateWithoutExamDownloadableInput = {
    image?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isSuperUser?: BoolFieldUpdateOperationsInput | boolean
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    exam?: examUpdateManyWithoutUsersNestedInput
    form?: formUpdateManyWithoutUsersNestedInput
    formExams?: formExamsUpdateManyWithoutUsersNestedInput
    formReference?: formReferenceUpdateManyWithoutUsersNestedInput
    formReview?: formReviewUpdateManyWithoutUsersNestedInput
    note?: noteUpdateManyWithoutUsersNestedInput
    notesDownloadable?: notesDownloadableUpdateManyWithoutUsersNestedInput
    purchase?: purchaseUpdateManyWithoutUsersNestedInput
    question?: questionUpdateManyWithoutUsersNestedInput
    reference?: referenceUpdateManyWithoutUsersNestedInput
    review?: reviewUpdateManyWithoutUsersNestedInput
    subject?: subjectUpdateManyWithoutUsersNestedInput
    subjectExams?: subjectExamsUpdateManyWithoutUsersNestedInput
    subjectReference?: subjectReferenceUpdateManyWithoutUsersNestedInput
    subjectReview?: subjectReviewUpdateManyWithoutUsersNestedInput
    topic?: topicUpdateManyWithoutUsersNestedInput
    topicReview?: topicReviewUpdateManyWithoutUsersNestedInput
    vifurushi?: vifurushiUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutExamDownloadableInput = {
    id?: IntFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isSuperUser?: BoolFieldUpdateOperationsInput | boolean
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    exam?: examUncheckedUpdateManyWithoutUsersNestedInput
    form?: formUncheckedUpdateManyWithoutUsersNestedInput
    formExams?: formExamsUncheckedUpdateManyWithoutUsersNestedInput
    formReference?: formReferenceUncheckedUpdateManyWithoutUsersNestedInput
    formReview?: formReviewUncheckedUpdateManyWithoutUsersNestedInput
    note?: noteUncheckedUpdateManyWithoutUsersNestedInput
    notesDownloadable?: notesDownloadableUncheckedUpdateManyWithoutUsersNestedInput
    purchase?: purchaseUncheckedUpdateManyWithoutUsersNestedInput
    question?: questionUncheckedUpdateManyWithoutUsersNestedInput
    reference?: referenceUncheckedUpdateManyWithoutUsersNestedInput
    review?: reviewUncheckedUpdateManyWithoutUsersNestedInput
    subject?: subjectUncheckedUpdateManyWithoutUsersNestedInput
    subjectExams?: subjectExamsUncheckedUpdateManyWithoutUsersNestedInput
    subjectReference?: subjectReferenceUncheckedUpdateManyWithoutUsersNestedInput
    subjectReview?: subjectReviewUncheckedUpdateManyWithoutUsersNestedInput
    topic?: topicUncheckedUpdateManyWithoutUsersNestedInput
    topicReview?: topicReviewUncheckedUpdateManyWithoutUsersNestedInput
    vifurushi?: vifurushiUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersCreateWithoutSubjectReferenceInput = {
    image?: string | null
    username: string
    password: string
    isAdmin?: boolean
    isSuperUser?: boolean
    dateJoined?: Date | string
    name: string
    updatedAt?: Date | string
    isOnline?: boolean
    exam?: examCreateNestedManyWithoutUsersInput
    examDownloadable?: examDownloadableCreateNestedManyWithoutUsersInput
    form?: formCreateNestedManyWithoutUsersInput
    formExams?: formExamsCreateNestedManyWithoutUsersInput
    formReference?: formReferenceCreateNestedManyWithoutUsersInput
    formReview?: formReviewCreateNestedManyWithoutUsersInput
    note?: noteCreateNestedManyWithoutUsersInput
    notesDownloadable?: notesDownloadableCreateNestedManyWithoutUsersInput
    purchase?: purchaseCreateNestedManyWithoutUsersInput
    question?: questionCreateNestedManyWithoutUsersInput
    reference?: referenceCreateNestedManyWithoutUsersInput
    review?: reviewCreateNestedManyWithoutUsersInput
    subject?: subjectCreateNestedManyWithoutUsersInput
    subjectExams?: subjectExamsCreateNestedManyWithoutUsersInput
    subjectReview?: subjectReviewCreateNestedManyWithoutUsersInput
    topic?: topicCreateNestedManyWithoutUsersInput
    topicReview?: topicReviewCreateNestedManyWithoutUsersInput
    vifurushi?: vifurushiCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutSubjectReferenceInput = {
    id?: number
    image?: string | null
    username: string
    password: string
    isAdmin?: boolean
    isSuperUser?: boolean
    dateJoined?: Date | string
    name: string
    updatedAt?: Date | string
    isOnline?: boolean
    exam?: examUncheckedCreateNestedManyWithoutUsersInput
    examDownloadable?: examDownloadableUncheckedCreateNestedManyWithoutUsersInput
    form?: formUncheckedCreateNestedManyWithoutUsersInput
    formExams?: formExamsUncheckedCreateNestedManyWithoutUsersInput
    formReference?: formReferenceUncheckedCreateNestedManyWithoutUsersInput
    formReview?: formReviewUncheckedCreateNestedManyWithoutUsersInput
    note?: noteUncheckedCreateNestedManyWithoutUsersInput
    notesDownloadable?: notesDownloadableUncheckedCreateNestedManyWithoutUsersInput
    purchase?: purchaseUncheckedCreateNestedManyWithoutUsersInput
    question?: questionUncheckedCreateNestedManyWithoutUsersInput
    reference?: referenceUncheckedCreateNestedManyWithoutUsersInput
    review?: reviewUncheckedCreateNestedManyWithoutUsersInput
    subject?: subjectUncheckedCreateNestedManyWithoutUsersInput
    subjectExams?: subjectExamsUncheckedCreateNestedManyWithoutUsersInput
    subjectReview?: subjectReviewUncheckedCreateNestedManyWithoutUsersInput
    topic?: topicUncheckedCreateNestedManyWithoutUsersInput
    topicReview?: topicReviewUncheckedCreateNestedManyWithoutUsersInput
    vifurushi?: vifurushiUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutSubjectReferenceInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutSubjectReferenceInput, usersUncheckedCreateWithoutSubjectReferenceInput>
  }

  export type referenceCreateWithoutSubjectReferenceInput = {
    name: string
    description: string
    data: string
    isPdf: boolean
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users: usersCreateNestedOneWithoutReferenceInput
    formReference?: formReferenceCreateNestedManyWithoutReferenceInput
  }

  export type referenceUncheckedCreateWithoutSubjectReferenceInput = {
    id?: number
    name: string
    description: string
    data: string
    isPdf: boolean
    published?: boolean
    usersId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    formReference?: formReferenceUncheckedCreateNestedManyWithoutReferenceInput
  }

  export type referenceCreateOrConnectWithoutSubjectReferenceInput = {
    where: referenceWhereUniqueInput
    create: XOR<referenceCreateWithoutSubjectReferenceInput, referenceUncheckedCreateWithoutSubjectReferenceInput>
  }

  export type referenceCreateManySubjectReferenceInputEnvelope = {
    data: Enumerable<referenceCreateManySubjectReferenceInput>
    skipDuplicates?: boolean
  }

  export type formReferenceCreateWithoutSubjectsInput = {
    formName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users: usersCreateNestedOneWithoutFormReferenceInput
    reference?: referenceCreateNestedManyWithoutFormReferenceInput
  }

  export type formReferenceUncheckedCreateWithoutSubjectsInput = {
    id?: number
    formName: string
    usersId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    reference?: referenceUncheckedCreateNestedManyWithoutFormReferenceInput
  }

  export type formReferenceCreateOrConnectWithoutSubjectsInput = {
    where: formReferenceWhereUniqueInput
    create: XOR<formReferenceCreateWithoutSubjectsInput, formReferenceUncheckedCreateWithoutSubjectsInput>
  }

  export type usersUpsertWithoutSubjectReferenceInput = {
    update: XOR<usersUpdateWithoutSubjectReferenceInput, usersUncheckedUpdateWithoutSubjectReferenceInput>
    create: XOR<usersCreateWithoutSubjectReferenceInput, usersUncheckedCreateWithoutSubjectReferenceInput>
  }

  export type usersUpdateWithoutSubjectReferenceInput = {
    image?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isSuperUser?: BoolFieldUpdateOperationsInput | boolean
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    exam?: examUpdateManyWithoutUsersNestedInput
    examDownloadable?: examDownloadableUpdateManyWithoutUsersNestedInput
    form?: formUpdateManyWithoutUsersNestedInput
    formExams?: formExamsUpdateManyWithoutUsersNestedInput
    formReference?: formReferenceUpdateManyWithoutUsersNestedInput
    formReview?: formReviewUpdateManyWithoutUsersNestedInput
    note?: noteUpdateManyWithoutUsersNestedInput
    notesDownloadable?: notesDownloadableUpdateManyWithoutUsersNestedInput
    purchase?: purchaseUpdateManyWithoutUsersNestedInput
    question?: questionUpdateManyWithoutUsersNestedInput
    reference?: referenceUpdateManyWithoutUsersNestedInput
    review?: reviewUpdateManyWithoutUsersNestedInput
    subject?: subjectUpdateManyWithoutUsersNestedInput
    subjectExams?: subjectExamsUpdateManyWithoutUsersNestedInput
    subjectReview?: subjectReviewUpdateManyWithoutUsersNestedInput
    topic?: topicUpdateManyWithoutUsersNestedInput
    topicReview?: topicReviewUpdateManyWithoutUsersNestedInput
    vifurushi?: vifurushiUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutSubjectReferenceInput = {
    id?: IntFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isSuperUser?: BoolFieldUpdateOperationsInput | boolean
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    exam?: examUncheckedUpdateManyWithoutUsersNestedInput
    examDownloadable?: examDownloadableUncheckedUpdateManyWithoutUsersNestedInput
    form?: formUncheckedUpdateManyWithoutUsersNestedInput
    formExams?: formExamsUncheckedUpdateManyWithoutUsersNestedInput
    formReference?: formReferenceUncheckedUpdateManyWithoutUsersNestedInput
    formReview?: formReviewUncheckedUpdateManyWithoutUsersNestedInput
    note?: noteUncheckedUpdateManyWithoutUsersNestedInput
    notesDownloadable?: notesDownloadableUncheckedUpdateManyWithoutUsersNestedInput
    purchase?: purchaseUncheckedUpdateManyWithoutUsersNestedInput
    question?: questionUncheckedUpdateManyWithoutUsersNestedInput
    reference?: referenceUncheckedUpdateManyWithoutUsersNestedInput
    review?: reviewUncheckedUpdateManyWithoutUsersNestedInput
    subject?: subjectUncheckedUpdateManyWithoutUsersNestedInput
    subjectExams?: subjectExamsUncheckedUpdateManyWithoutUsersNestedInput
    subjectReview?: subjectReviewUncheckedUpdateManyWithoutUsersNestedInput
    topic?: topicUncheckedUpdateManyWithoutUsersNestedInput
    topicReview?: topicReviewUncheckedUpdateManyWithoutUsersNestedInput
    vifurushi?: vifurushiUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type referenceUpsertWithWhereUniqueWithoutSubjectReferenceInput = {
    where: referenceWhereUniqueInput
    update: XOR<referenceUpdateWithoutSubjectReferenceInput, referenceUncheckedUpdateWithoutSubjectReferenceInput>
    create: XOR<referenceCreateWithoutSubjectReferenceInput, referenceUncheckedCreateWithoutSubjectReferenceInput>
  }

  export type referenceUpdateWithWhereUniqueWithoutSubjectReferenceInput = {
    where: referenceWhereUniqueInput
    data: XOR<referenceUpdateWithoutSubjectReferenceInput, referenceUncheckedUpdateWithoutSubjectReferenceInput>
  }

  export type referenceUpdateManyWithWhereWithoutSubjectReferenceInput = {
    where: referenceScalarWhereInput
    data: XOR<referenceUpdateManyMutationInput, referenceUncheckedUpdateManyWithoutReferenceInput>
  }

  export type formReferenceUpsertWithWhereUniqueWithoutSubjectsInput = {
    where: formReferenceWhereUniqueInput
    update: XOR<formReferenceUpdateWithoutSubjectsInput, formReferenceUncheckedUpdateWithoutSubjectsInput>
    create: XOR<formReferenceCreateWithoutSubjectsInput, formReferenceUncheckedCreateWithoutSubjectsInput>
  }

  export type formReferenceUpdateWithWhereUniqueWithoutSubjectsInput = {
    where: formReferenceWhereUniqueInput
    data: XOR<formReferenceUpdateWithoutSubjectsInput, formReferenceUncheckedUpdateWithoutSubjectsInput>
  }

  export type formReferenceUpdateManyWithWhereWithoutSubjectsInput = {
    where: formReferenceScalarWhereInput
    data: XOR<formReferenceUpdateManyMutationInput, formReferenceUncheckedUpdateManyWithoutFormsInput>
  }

  export type usersCreateWithoutFormReferenceInput = {
    image?: string | null
    username: string
    password: string
    isAdmin?: boolean
    isSuperUser?: boolean
    dateJoined?: Date | string
    name: string
    updatedAt?: Date | string
    isOnline?: boolean
    exam?: examCreateNestedManyWithoutUsersInput
    examDownloadable?: examDownloadableCreateNestedManyWithoutUsersInput
    form?: formCreateNestedManyWithoutUsersInput
    formExams?: formExamsCreateNestedManyWithoutUsersInput
    formReview?: formReviewCreateNestedManyWithoutUsersInput
    note?: noteCreateNestedManyWithoutUsersInput
    notesDownloadable?: notesDownloadableCreateNestedManyWithoutUsersInput
    purchase?: purchaseCreateNestedManyWithoutUsersInput
    question?: questionCreateNestedManyWithoutUsersInput
    reference?: referenceCreateNestedManyWithoutUsersInput
    review?: reviewCreateNestedManyWithoutUsersInput
    subject?: subjectCreateNestedManyWithoutUsersInput
    subjectExams?: subjectExamsCreateNestedManyWithoutUsersInput
    subjectReference?: subjectReferenceCreateNestedManyWithoutUsersInput
    subjectReview?: subjectReviewCreateNestedManyWithoutUsersInput
    topic?: topicCreateNestedManyWithoutUsersInput
    topicReview?: topicReviewCreateNestedManyWithoutUsersInput
    vifurushi?: vifurushiCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutFormReferenceInput = {
    id?: number
    image?: string | null
    username: string
    password: string
    isAdmin?: boolean
    isSuperUser?: boolean
    dateJoined?: Date | string
    name: string
    updatedAt?: Date | string
    isOnline?: boolean
    exam?: examUncheckedCreateNestedManyWithoutUsersInput
    examDownloadable?: examDownloadableUncheckedCreateNestedManyWithoutUsersInput
    form?: formUncheckedCreateNestedManyWithoutUsersInput
    formExams?: formExamsUncheckedCreateNestedManyWithoutUsersInput
    formReview?: formReviewUncheckedCreateNestedManyWithoutUsersInput
    note?: noteUncheckedCreateNestedManyWithoutUsersInput
    notesDownloadable?: notesDownloadableUncheckedCreateNestedManyWithoutUsersInput
    purchase?: purchaseUncheckedCreateNestedManyWithoutUsersInput
    question?: questionUncheckedCreateNestedManyWithoutUsersInput
    reference?: referenceUncheckedCreateNestedManyWithoutUsersInput
    review?: reviewUncheckedCreateNestedManyWithoutUsersInput
    subject?: subjectUncheckedCreateNestedManyWithoutUsersInput
    subjectExams?: subjectExamsUncheckedCreateNestedManyWithoutUsersInput
    subjectReference?: subjectReferenceUncheckedCreateNestedManyWithoutUsersInput
    subjectReview?: subjectReviewUncheckedCreateNestedManyWithoutUsersInput
    topic?: topicUncheckedCreateNestedManyWithoutUsersInput
    topicReview?: topicReviewUncheckedCreateNestedManyWithoutUsersInput
    vifurushi?: vifurushiUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutFormReferenceInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutFormReferenceInput, usersUncheckedCreateWithoutFormReferenceInput>
  }

  export type referenceCreateWithoutFormReferenceInput = {
    name: string
    description: string
    data: string
    isPdf: boolean
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    subjectReference: subjectReferenceCreateNestedOneWithoutReferenceInput
    users: usersCreateNestedOneWithoutReferenceInput
  }

  export type referenceUncheckedCreateWithoutFormReferenceInput = {
    id?: number
    name: string
    description: string
    data: string
    isPdf: boolean
    published?: boolean
    subjectId: number
    usersId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type referenceCreateOrConnectWithoutFormReferenceInput = {
    where: referenceWhereUniqueInput
    create: XOR<referenceCreateWithoutFormReferenceInput, referenceUncheckedCreateWithoutFormReferenceInput>
  }

  export type subjectReferenceCreateWithoutFormsInput = {
    subjectName: string
    subjectDefinition: string
    imageLocation?: string | null
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users: usersCreateNestedOneWithoutSubjectReferenceInput
    reference?: referenceCreateNestedManyWithoutSubjectReferenceInput
  }

  export type subjectReferenceUncheckedCreateWithoutFormsInput = {
    id?: number
    subjectName: string
    subjectDefinition: string
    imageLocation?: string | null
    published?: boolean
    usersId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    reference?: referenceUncheckedCreateNestedManyWithoutSubjectReferenceInput
  }

  export type subjectReferenceCreateOrConnectWithoutFormsInput = {
    where: subjectReferenceWhereUniqueInput
    create: XOR<subjectReferenceCreateWithoutFormsInput, subjectReferenceUncheckedCreateWithoutFormsInput>
  }

  export type usersUpsertWithoutFormReferenceInput = {
    update: XOR<usersUpdateWithoutFormReferenceInput, usersUncheckedUpdateWithoutFormReferenceInput>
    create: XOR<usersCreateWithoutFormReferenceInput, usersUncheckedCreateWithoutFormReferenceInput>
  }

  export type usersUpdateWithoutFormReferenceInput = {
    image?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isSuperUser?: BoolFieldUpdateOperationsInput | boolean
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    exam?: examUpdateManyWithoutUsersNestedInput
    examDownloadable?: examDownloadableUpdateManyWithoutUsersNestedInput
    form?: formUpdateManyWithoutUsersNestedInput
    formExams?: formExamsUpdateManyWithoutUsersNestedInput
    formReview?: formReviewUpdateManyWithoutUsersNestedInput
    note?: noteUpdateManyWithoutUsersNestedInput
    notesDownloadable?: notesDownloadableUpdateManyWithoutUsersNestedInput
    purchase?: purchaseUpdateManyWithoutUsersNestedInput
    question?: questionUpdateManyWithoutUsersNestedInput
    reference?: referenceUpdateManyWithoutUsersNestedInput
    review?: reviewUpdateManyWithoutUsersNestedInput
    subject?: subjectUpdateManyWithoutUsersNestedInput
    subjectExams?: subjectExamsUpdateManyWithoutUsersNestedInput
    subjectReference?: subjectReferenceUpdateManyWithoutUsersNestedInput
    subjectReview?: subjectReviewUpdateManyWithoutUsersNestedInput
    topic?: topicUpdateManyWithoutUsersNestedInput
    topicReview?: topicReviewUpdateManyWithoutUsersNestedInput
    vifurushi?: vifurushiUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutFormReferenceInput = {
    id?: IntFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isSuperUser?: BoolFieldUpdateOperationsInput | boolean
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    exam?: examUncheckedUpdateManyWithoutUsersNestedInput
    examDownloadable?: examDownloadableUncheckedUpdateManyWithoutUsersNestedInput
    form?: formUncheckedUpdateManyWithoutUsersNestedInput
    formExams?: formExamsUncheckedUpdateManyWithoutUsersNestedInput
    formReview?: formReviewUncheckedUpdateManyWithoutUsersNestedInput
    note?: noteUncheckedUpdateManyWithoutUsersNestedInput
    notesDownloadable?: notesDownloadableUncheckedUpdateManyWithoutUsersNestedInput
    purchase?: purchaseUncheckedUpdateManyWithoutUsersNestedInput
    question?: questionUncheckedUpdateManyWithoutUsersNestedInput
    reference?: referenceUncheckedUpdateManyWithoutUsersNestedInput
    review?: reviewUncheckedUpdateManyWithoutUsersNestedInput
    subject?: subjectUncheckedUpdateManyWithoutUsersNestedInput
    subjectExams?: subjectExamsUncheckedUpdateManyWithoutUsersNestedInput
    subjectReference?: subjectReferenceUncheckedUpdateManyWithoutUsersNestedInput
    subjectReview?: subjectReviewUncheckedUpdateManyWithoutUsersNestedInput
    topic?: topicUncheckedUpdateManyWithoutUsersNestedInput
    topicReview?: topicReviewUncheckedUpdateManyWithoutUsersNestedInput
    vifurushi?: vifurushiUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type referenceUpsertWithWhereUniqueWithoutFormReferenceInput = {
    where: referenceWhereUniqueInput
    update: XOR<referenceUpdateWithoutFormReferenceInput, referenceUncheckedUpdateWithoutFormReferenceInput>
    create: XOR<referenceCreateWithoutFormReferenceInput, referenceUncheckedCreateWithoutFormReferenceInput>
  }

  export type referenceUpdateWithWhereUniqueWithoutFormReferenceInput = {
    where: referenceWhereUniqueInput
    data: XOR<referenceUpdateWithoutFormReferenceInput, referenceUncheckedUpdateWithoutFormReferenceInput>
  }

  export type referenceUpdateManyWithWhereWithoutFormReferenceInput = {
    where: referenceScalarWhereInput
    data: XOR<referenceUpdateManyMutationInput, referenceUncheckedUpdateManyWithoutReferenceInput>
  }

  export type subjectReferenceUpsertWithWhereUniqueWithoutFormsInput = {
    where: subjectReferenceWhereUniqueInput
    update: XOR<subjectReferenceUpdateWithoutFormsInput, subjectReferenceUncheckedUpdateWithoutFormsInput>
    create: XOR<subjectReferenceCreateWithoutFormsInput, subjectReferenceUncheckedCreateWithoutFormsInput>
  }

  export type subjectReferenceUpdateWithWhereUniqueWithoutFormsInput = {
    where: subjectReferenceWhereUniqueInput
    data: XOR<subjectReferenceUpdateWithoutFormsInput, subjectReferenceUncheckedUpdateWithoutFormsInput>
  }

  export type subjectReferenceUpdateManyWithWhereWithoutFormsInput = {
    where: subjectReferenceScalarWhereInput
    data: XOR<subjectReferenceUpdateManyMutationInput, subjectReferenceUncheckedUpdateManyWithoutSubjectsInput>
  }

  export type subjectReferenceCreateWithoutReferenceInput = {
    subjectName: string
    subjectDefinition: string
    imageLocation?: string | null
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users: usersCreateNestedOneWithoutSubjectReferenceInput
    forms?: formReferenceCreateNestedManyWithoutSubjectsInput
  }

  export type subjectReferenceUncheckedCreateWithoutReferenceInput = {
    id?: number
    subjectName: string
    subjectDefinition: string
    imageLocation?: string | null
    published?: boolean
    usersId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    forms?: formReferenceUncheckedCreateNestedManyWithoutSubjectsInput
  }

  export type subjectReferenceCreateOrConnectWithoutReferenceInput = {
    where: subjectReferenceWhereUniqueInput
    create: XOR<subjectReferenceCreateWithoutReferenceInput, subjectReferenceUncheckedCreateWithoutReferenceInput>
  }

  export type usersCreateWithoutReferenceInput = {
    image?: string | null
    username: string
    password: string
    isAdmin?: boolean
    isSuperUser?: boolean
    dateJoined?: Date | string
    name: string
    updatedAt?: Date | string
    isOnline?: boolean
    exam?: examCreateNestedManyWithoutUsersInput
    examDownloadable?: examDownloadableCreateNestedManyWithoutUsersInput
    form?: formCreateNestedManyWithoutUsersInput
    formExams?: formExamsCreateNestedManyWithoutUsersInput
    formReference?: formReferenceCreateNestedManyWithoutUsersInput
    formReview?: formReviewCreateNestedManyWithoutUsersInput
    note?: noteCreateNestedManyWithoutUsersInput
    notesDownloadable?: notesDownloadableCreateNestedManyWithoutUsersInput
    purchase?: purchaseCreateNestedManyWithoutUsersInput
    question?: questionCreateNestedManyWithoutUsersInput
    review?: reviewCreateNestedManyWithoutUsersInput
    subject?: subjectCreateNestedManyWithoutUsersInput
    subjectExams?: subjectExamsCreateNestedManyWithoutUsersInput
    subjectReference?: subjectReferenceCreateNestedManyWithoutUsersInput
    subjectReview?: subjectReviewCreateNestedManyWithoutUsersInput
    topic?: topicCreateNestedManyWithoutUsersInput
    topicReview?: topicReviewCreateNestedManyWithoutUsersInput
    vifurushi?: vifurushiCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutReferenceInput = {
    id?: number
    image?: string | null
    username: string
    password: string
    isAdmin?: boolean
    isSuperUser?: boolean
    dateJoined?: Date | string
    name: string
    updatedAt?: Date | string
    isOnline?: boolean
    exam?: examUncheckedCreateNestedManyWithoutUsersInput
    examDownloadable?: examDownloadableUncheckedCreateNestedManyWithoutUsersInput
    form?: formUncheckedCreateNestedManyWithoutUsersInput
    formExams?: formExamsUncheckedCreateNestedManyWithoutUsersInput
    formReference?: formReferenceUncheckedCreateNestedManyWithoutUsersInput
    formReview?: formReviewUncheckedCreateNestedManyWithoutUsersInput
    note?: noteUncheckedCreateNestedManyWithoutUsersInput
    notesDownloadable?: notesDownloadableUncheckedCreateNestedManyWithoutUsersInput
    purchase?: purchaseUncheckedCreateNestedManyWithoutUsersInput
    question?: questionUncheckedCreateNestedManyWithoutUsersInput
    review?: reviewUncheckedCreateNestedManyWithoutUsersInput
    subject?: subjectUncheckedCreateNestedManyWithoutUsersInput
    subjectExams?: subjectExamsUncheckedCreateNestedManyWithoutUsersInput
    subjectReference?: subjectReferenceUncheckedCreateNestedManyWithoutUsersInput
    subjectReview?: subjectReviewUncheckedCreateNestedManyWithoutUsersInput
    topic?: topicUncheckedCreateNestedManyWithoutUsersInput
    topicReview?: topicReviewUncheckedCreateNestedManyWithoutUsersInput
    vifurushi?: vifurushiUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutReferenceInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutReferenceInput, usersUncheckedCreateWithoutReferenceInput>
  }

  export type formReferenceCreateWithoutReferenceInput = {
    formName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users: usersCreateNestedOneWithoutFormReferenceInput
    subjects?: subjectReferenceCreateNestedManyWithoutFormsInput
  }

  export type formReferenceUncheckedCreateWithoutReferenceInput = {
    id?: number
    formName: string
    usersId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    subjects?: subjectReferenceUncheckedCreateNestedManyWithoutFormsInput
  }

  export type formReferenceCreateOrConnectWithoutReferenceInput = {
    where: formReferenceWhereUniqueInput
    create: XOR<formReferenceCreateWithoutReferenceInput, formReferenceUncheckedCreateWithoutReferenceInput>
  }

  export type subjectReferenceUpsertWithoutReferenceInput = {
    update: XOR<subjectReferenceUpdateWithoutReferenceInput, subjectReferenceUncheckedUpdateWithoutReferenceInput>
    create: XOR<subjectReferenceCreateWithoutReferenceInput, subjectReferenceUncheckedCreateWithoutReferenceInput>
  }

  export type subjectReferenceUpdateWithoutReferenceInput = {
    subjectName?: StringFieldUpdateOperationsInput | string
    subjectDefinition?: StringFieldUpdateOperationsInput | string
    imageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutSubjectReferenceNestedInput
    forms?: formReferenceUpdateManyWithoutSubjectsNestedInput
  }

  export type subjectReferenceUncheckedUpdateWithoutReferenceInput = {
    id?: IntFieldUpdateOperationsInput | number
    subjectName?: StringFieldUpdateOperationsInput | string
    subjectDefinition?: StringFieldUpdateOperationsInput | string
    imageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    usersId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    forms?: formReferenceUncheckedUpdateManyWithoutSubjectsNestedInput
  }

  export type usersUpsertWithoutReferenceInput = {
    update: XOR<usersUpdateWithoutReferenceInput, usersUncheckedUpdateWithoutReferenceInput>
    create: XOR<usersCreateWithoutReferenceInput, usersUncheckedCreateWithoutReferenceInput>
  }

  export type usersUpdateWithoutReferenceInput = {
    image?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isSuperUser?: BoolFieldUpdateOperationsInput | boolean
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    exam?: examUpdateManyWithoutUsersNestedInput
    examDownloadable?: examDownloadableUpdateManyWithoutUsersNestedInput
    form?: formUpdateManyWithoutUsersNestedInput
    formExams?: formExamsUpdateManyWithoutUsersNestedInput
    formReference?: formReferenceUpdateManyWithoutUsersNestedInput
    formReview?: formReviewUpdateManyWithoutUsersNestedInput
    note?: noteUpdateManyWithoutUsersNestedInput
    notesDownloadable?: notesDownloadableUpdateManyWithoutUsersNestedInput
    purchase?: purchaseUpdateManyWithoutUsersNestedInput
    question?: questionUpdateManyWithoutUsersNestedInput
    review?: reviewUpdateManyWithoutUsersNestedInput
    subject?: subjectUpdateManyWithoutUsersNestedInput
    subjectExams?: subjectExamsUpdateManyWithoutUsersNestedInput
    subjectReference?: subjectReferenceUpdateManyWithoutUsersNestedInput
    subjectReview?: subjectReviewUpdateManyWithoutUsersNestedInput
    topic?: topicUpdateManyWithoutUsersNestedInput
    topicReview?: topicReviewUpdateManyWithoutUsersNestedInput
    vifurushi?: vifurushiUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutReferenceInput = {
    id?: IntFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isSuperUser?: BoolFieldUpdateOperationsInput | boolean
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    exam?: examUncheckedUpdateManyWithoutUsersNestedInput
    examDownloadable?: examDownloadableUncheckedUpdateManyWithoutUsersNestedInput
    form?: formUncheckedUpdateManyWithoutUsersNestedInput
    formExams?: formExamsUncheckedUpdateManyWithoutUsersNestedInput
    formReference?: formReferenceUncheckedUpdateManyWithoutUsersNestedInput
    formReview?: formReviewUncheckedUpdateManyWithoutUsersNestedInput
    note?: noteUncheckedUpdateManyWithoutUsersNestedInput
    notesDownloadable?: notesDownloadableUncheckedUpdateManyWithoutUsersNestedInput
    purchase?: purchaseUncheckedUpdateManyWithoutUsersNestedInput
    question?: questionUncheckedUpdateManyWithoutUsersNestedInput
    review?: reviewUncheckedUpdateManyWithoutUsersNestedInput
    subject?: subjectUncheckedUpdateManyWithoutUsersNestedInput
    subjectExams?: subjectExamsUncheckedUpdateManyWithoutUsersNestedInput
    subjectReference?: subjectReferenceUncheckedUpdateManyWithoutUsersNestedInput
    subjectReview?: subjectReviewUncheckedUpdateManyWithoutUsersNestedInput
    topic?: topicUncheckedUpdateManyWithoutUsersNestedInput
    topicReview?: topicReviewUncheckedUpdateManyWithoutUsersNestedInput
    vifurushi?: vifurushiUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type formReferenceUpsertWithWhereUniqueWithoutReferenceInput = {
    where: formReferenceWhereUniqueInput
    update: XOR<formReferenceUpdateWithoutReferenceInput, formReferenceUncheckedUpdateWithoutReferenceInput>
    create: XOR<formReferenceCreateWithoutReferenceInput, formReferenceUncheckedCreateWithoutReferenceInput>
  }

  export type formReferenceUpdateWithWhereUniqueWithoutReferenceInput = {
    where: formReferenceWhereUniqueInput
    data: XOR<formReferenceUpdateWithoutReferenceInput, formReferenceUncheckedUpdateWithoutReferenceInput>
  }

  export type formReferenceUpdateManyWithWhereWithoutReferenceInput = {
    where: formReferenceScalarWhereInput
    data: XOR<formReferenceUpdateManyMutationInput, formReferenceUncheckedUpdateManyWithoutFormReferenceInput>
  }

  export type examCreateManyUsersInput = {
    id?: number
    description: string
    year: number
    hasAnswers?: boolean
    published?: boolean
    examTypeId: number
    exam: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type examDownloadableCreateManyUsersInput = {
    id?: number
    link: string
    fileExtension: string
    published?: boolean
    examId: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type formCreateManyUsersInput = {
    id?: number
    formName: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type formExamsCreateManyUsersInput = {
    id?: number
    formName: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type formReferenceCreateManyUsersInput = {
    id?: number
    formName: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type formReviewCreateManyUsersInput = {
    id?: number
    formName: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type noteCreateManyUsersInput = {
    id?: number
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    published?: boolean
    subjectId: number
    formId: number
    topicId: number
  }

  export type notesDownloadableCreateManyUsersInput = {
    id?: number
    link: string
    fileExtension: string
    published?: boolean
    formId: number
    subjectId: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type purchaseCreateManyUsersInput = {
    id?: number
    name: string
    value: number
  }

  export type questionCreateManyUsersInput = {
    id?: number
    question: string
    published?: boolean
    answerDetails?: string
    questionFormatId: number
    reviewId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type referenceCreateManyUsersInput = {
    id?: number
    name: string
    description: string
    data: string
    isPdf: boolean
    published?: boolean
    subjectId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type reviewCreateManyUsersInput = {
    id?: number
    name: string
    published?: boolean
    topicId: number
    subjectId: number
    formId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type subjectCreateManyUsersInput = {
    id?: number
    subjectName: string
    subjectDefinition: string
    imageLocation?: string | null
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type subjectExamsCreateManyUsersInput = {
    id?: number
    subjectName: string
    subjectDefinition: string
    imageLocation?: string | null
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type subjectReferenceCreateManyUsersInput = {
    id?: number
    subjectName: string
    subjectDefinition: string
    imageLocation?: string | null
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type subjectReviewCreateManyUsersInput = {
    id?: number
    subjectName: string
    subjectDefinition: string
    imageLocation?: string | null
    published?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type topicCreateManyUsersInput = {
    id?: number
    topicName: string
    topicDefinition?: string | null
    published?: boolean
    subjectId: number
    formId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type topicReviewCreateManyUsersInput = {
    id?: number
    topicName: string
    topicDefinition?: string | null
    published?: boolean
    subjectId: number
    formId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type vifurushiCreateManyUsersInput = {
    id?: number
    name: string
    value: number
  }

  export type examUpdateWithoutUsersInput = {
    description?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    hasAnswers?: BoolFieldUpdateOperationsInput | boolean
    published?: BoolFieldUpdateOperationsInput | boolean
    exam?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examType?: examTypeUpdateOneRequiredWithoutExamNestedInput
    examDownloadable?: examDownloadableUpdateManyWithoutExamNestedInput
  }

  export type examUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    hasAnswers?: BoolFieldUpdateOperationsInput | boolean
    published?: BoolFieldUpdateOperationsInput | boolean
    examTypeId?: IntFieldUpdateOperationsInput | number
    exam?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examDownloadable?: examDownloadableUncheckedUpdateManyWithoutExamNestedInput
  }

  export type examUncheckedUpdateManyWithoutExamInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    hasAnswers?: BoolFieldUpdateOperationsInput | boolean
    published?: BoolFieldUpdateOperationsInput | boolean
    examTypeId?: IntFieldUpdateOperationsInput | number
    exam?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type examDownloadableUpdateWithoutUsersInput = {
    link?: StringFieldUpdateOperationsInput | string
    fileExtension?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exam?: examUpdateOneRequiredWithoutExamDownloadableNestedInput
  }

  export type examDownloadableUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    link?: StringFieldUpdateOperationsInput | string
    fileExtension?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    examId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type examDownloadableUncheckedUpdateManyWithoutExamDownloadableInput = {
    id?: IntFieldUpdateOperationsInput | number
    link?: StringFieldUpdateOperationsInput | string
    fileExtension?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    examId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type formUpdateWithoutUsersInput = {
    formName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: noteUpdateManyWithoutFormNestedInput
    notesDownloadable?: notesDownloadableUpdateManyWithoutFormNestedInput
    topic?: topicUpdateManyWithoutFormNestedInput
    subjects?: subjectUpdateManyWithoutFormsNestedInput
  }

  export type formUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    formName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: noteUncheckedUpdateManyWithoutFormNestedInput
    notesDownloadable?: notesDownloadableUncheckedUpdateManyWithoutFormNestedInput
    topic?: topicUncheckedUpdateManyWithoutFormNestedInput
    subjects?: subjectUncheckedUpdateManyWithoutFormsNestedInput
  }

  export type formUncheckedUpdateManyWithoutFormInput = {
    id?: IntFieldUpdateOperationsInput | number
    formName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type formExamsUpdateWithoutUsersInput = {
    formName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examType?: examTypeUpdateManyWithoutFormExamsNestedInput
    subjects?: subjectExamsUpdateManyWithoutFormsNestedInput
  }

  export type formExamsUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    formName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examType?: examTypeUncheckedUpdateManyWithoutFormExamsNestedInput
    subjects?: subjectExamsUncheckedUpdateManyWithoutFormsNestedInput
  }

  export type formExamsUncheckedUpdateManyWithoutFormExamsInput = {
    id?: IntFieldUpdateOperationsInput | number
    formName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type formReferenceUpdateWithoutUsersInput = {
    formName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: referenceUpdateManyWithoutFormReferenceNestedInput
    subjects?: subjectReferenceUpdateManyWithoutFormsNestedInput
  }

  export type formReferenceUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    formName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: referenceUncheckedUpdateManyWithoutFormReferenceNestedInput
    subjects?: subjectReferenceUncheckedUpdateManyWithoutFormsNestedInput
  }

  export type formReferenceUncheckedUpdateManyWithoutFormReferenceInput = {
    id?: IntFieldUpdateOperationsInput | number
    formName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type formReviewUpdateWithoutUsersInput = {
    formName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    review?: reviewUpdateManyWithoutFormNestedInput
    topic?: topicReviewUpdateManyWithoutFormNestedInput
    subjects?: subjectReviewUpdateManyWithoutFormsNestedInput
  }

  export type formReviewUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    formName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    review?: reviewUncheckedUpdateManyWithoutFormNestedInput
    topic?: topicReviewUncheckedUpdateManyWithoutFormNestedInput
    subjects?: subjectReviewUncheckedUpdateManyWithoutFormsNestedInput
  }

  export type formReviewUncheckedUpdateManyWithoutFormReviewInput = {
    id?: IntFieldUpdateOperationsInput | number
    formName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type noteUpdateWithoutUsersInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    published?: BoolFieldUpdateOperationsInput | boolean
    form?: formUpdateOneRequiredWithoutNoteNestedInput
    subject?: subjectUpdateOneRequiredWithoutNoteNestedInput
    topic?: topicUpdateOneRequiredWithoutNoteNestedInput
  }

  export type noteUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    published?: BoolFieldUpdateOperationsInput | boolean
    subjectId?: IntFieldUpdateOperationsInput | number
    formId?: IntFieldUpdateOperationsInput | number
    topicId?: IntFieldUpdateOperationsInput | number
  }

  export type noteUncheckedUpdateManyWithoutNoteInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    published?: BoolFieldUpdateOperationsInput | boolean
    subjectId?: IntFieldUpdateOperationsInput | number
    formId?: IntFieldUpdateOperationsInput | number
    topicId?: IntFieldUpdateOperationsInput | number
  }

  export type notesDownloadableUpdateWithoutUsersInput = {
    link?: StringFieldUpdateOperationsInput | string
    fileExtension?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    form?: formUpdateOneRequiredWithoutNotesDownloadableNestedInput
    subject?: subjectUpdateOneRequiredWithoutNotesDownloadableNestedInput
  }

  export type notesDownloadableUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    link?: StringFieldUpdateOperationsInput | string
    fileExtension?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    formId?: IntFieldUpdateOperationsInput | number
    subjectId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notesDownloadableUncheckedUpdateManyWithoutNotesDownloadableInput = {
    id?: IntFieldUpdateOperationsInput | number
    link?: StringFieldUpdateOperationsInput | string
    fileExtension?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    formId?: IntFieldUpdateOperationsInput | number
    subjectId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type purchaseUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
  }

  export type purchaseUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
  }

  export type purchaseUncheckedUpdateManyWithoutPurchaseInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
  }

  export type questionUpdateWithoutUsersInput = {
    question?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    answerDetails?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questionFormat?: questionFormatUpdateOneRequiredWithoutQuestionNestedInput
    review?: reviewUpdateOneRequiredWithoutQuestionNestedInput
    answer?: answerUpdateManyWithoutQuestionNestedInput
  }

  export type questionUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    answerDetails?: StringFieldUpdateOperationsInput | string
    questionFormatId?: IntFieldUpdateOperationsInput | number
    reviewId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answer?: answerUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type questionUncheckedUpdateManyWithoutQuestionInput = {
    id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    answerDetails?: StringFieldUpdateOperationsInput | string
    questionFormatId?: IntFieldUpdateOperationsInput | number
    reviewId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type referenceUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    isPdf?: BoolFieldUpdateOperationsInput | boolean
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subjectReference?: subjectReferenceUpdateOneRequiredWithoutReferenceNestedInput
    formReference?: formReferenceUpdateManyWithoutReferenceNestedInput
  }

  export type referenceUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    isPdf?: BoolFieldUpdateOperationsInput | boolean
    published?: BoolFieldUpdateOperationsInput | boolean
    subjectId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    formReference?: formReferenceUncheckedUpdateManyWithoutReferenceNestedInput
  }

  export type referenceUncheckedUpdateManyWithoutReferenceInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    isPdf?: BoolFieldUpdateOperationsInput | boolean
    published?: BoolFieldUpdateOperationsInput | boolean
    subjectId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type reviewUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    form?: formReviewUpdateOneRequiredWithoutReviewNestedInput
    subject?: subjectReviewUpdateOneRequiredWithoutReviewNestedInput
    topic?: topicReviewUpdateOneRequiredWithoutReviewNestedInput
    question?: questionUpdateManyWithoutReviewNestedInput
  }

  export type reviewUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    topicId?: IntFieldUpdateOperationsInput | number
    subjectId?: IntFieldUpdateOperationsInput | number
    formId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    question?: questionUncheckedUpdateManyWithoutReviewNestedInput
  }

  export type reviewUncheckedUpdateManyWithoutReviewInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    topicId?: IntFieldUpdateOperationsInput | number
    subjectId?: IntFieldUpdateOperationsInput | number
    formId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type subjectUpdateWithoutUsersInput = {
    subjectName?: StringFieldUpdateOperationsInput | string
    subjectDefinition?: StringFieldUpdateOperationsInput | string
    imageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: noteUpdateManyWithoutSubjectNestedInput
    notesDownloadable?: notesDownloadableUpdateManyWithoutSubjectNestedInput
    topic?: topicUpdateManyWithoutSubjectNestedInput
    forms?: formUpdateManyWithoutSubjectsNestedInput
  }

  export type subjectUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    subjectName?: StringFieldUpdateOperationsInput | string
    subjectDefinition?: StringFieldUpdateOperationsInput | string
    imageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: noteUncheckedUpdateManyWithoutSubjectNestedInput
    notesDownloadable?: notesDownloadableUncheckedUpdateManyWithoutSubjectNestedInput
    topic?: topicUncheckedUpdateManyWithoutSubjectNestedInput
    forms?: formUncheckedUpdateManyWithoutSubjectsNestedInput
  }

  export type subjectUncheckedUpdateManyWithoutSubjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    subjectName?: StringFieldUpdateOperationsInput | string
    subjectDefinition?: StringFieldUpdateOperationsInput | string
    imageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type subjectExamsUpdateWithoutUsersInput = {
    subjectName?: StringFieldUpdateOperationsInput | string
    subjectDefinition?: StringFieldUpdateOperationsInput | string
    imageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examType?: examTypeUpdateManyWithoutSubjectExamsNestedInput
    forms?: formExamsUpdateManyWithoutSubjectsNestedInput
  }

  export type subjectExamsUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    subjectName?: StringFieldUpdateOperationsInput | string
    subjectDefinition?: StringFieldUpdateOperationsInput | string
    imageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examType?: examTypeUncheckedUpdateManyWithoutSubjectExamsNestedInput
    forms?: formExamsUncheckedUpdateManyWithoutSubjectsNestedInput
  }

  export type subjectExamsUncheckedUpdateManyWithoutSubjectExamsInput = {
    id?: IntFieldUpdateOperationsInput | number
    subjectName?: StringFieldUpdateOperationsInput | string
    subjectDefinition?: StringFieldUpdateOperationsInput | string
    imageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type subjectReferenceUpdateWithoutUsersInput = {
    subjectName?: StringFieldUpdateOperationsInput | string
    subjectDefinition?: StringFieldUpdateOperationsInput | string
    imageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: referenceUpdateManyWithoutSubjectReferenceNestedInput
    forms?: formReferenceUpdateManyWithoutSubjectsNestedInput
  }

  export type subjectReferenceUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    subjectName?: StringFieldUpdateOperationsInput | string
    subjectDefinition?: StringFieldUpdateOperationsInput | string
    imageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: referenceUncheckedUpdateManyWithoutSubjectReferenceNestedInput
    forms?: formReferenceUncheckedUpdateManyWithoutSubjectsNestedInput
  }

  export type subjectReferenceUncheckedUpdateManyWithoutSubjectReferenceInput = {
    id?: IntFieldUpdateOperationsInput | number
    subjectName?: StringFieldUpdateOperationsInput | string
    subjectDefinition?: StringFieldUpdateOperationsInput | string
    imageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type subjectReviewUpdateWithoutUsersInput = {
    subjectName?: StringFieldUpdateOperationsInput | string
    subjectDefinition?: StringFieldUpdateOperationsInput | string
    imageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    review?: reviewUpdateManyWithoutSubjectNestedInput
    topic?: topicReviewUpdateManyWithoutSubjectNestedInput
    forms?: formReviewUpdateManyWithoutSubjectsNestedInput
  }

  export type subjectReviewUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    subjectName?: StringFieldUpdateOperationsInput | string
    subjectDefinition?: StringFieldUpdateOperationsInput | string
    imageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    review?: reviewUncheckedUpdateManyWithoutSubjectNestedInput
    topic?: topicReviewUncheckedUpdateManyWithoutSubjectNestedInput
    forms?: formReviewUncheckedUpdateManyWithoutSubjectsNestedInput
  }

  export type subjectReviewUncheckedUpdateManyWithoutSubjectReviewInput = {
    id?: IntFieldUpdateOperationsInput | number
    subjectName?: StringFieldUpdateOperationsInput | string
    subjectDefinition?: StringFieldUpdateOperationsInput | string
    imageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type topicUpdateWithoutUsersInput = {
    topicName?: StringFieldUpdateOperationsInput | string
    topicDefinition?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    form?: formUpdateOneRequiredWithoutTopicNestedInput
    subject?: subjectUpdateOneRequiredWithoutTopicNestedInput
    note?: noteUpdateOneWithoutTopicNestedInput
  }

  export type topicUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    topicName?: StringFieldUpdateOperationsInput | string
    topicDefinition?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    subjectId?: IntFieldUpdateOperationsInput | number
    formId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: noteUncheckedUpdateOneWithoutTopicNestedInput
  }

  export type topicUncheckedUpdateManyWithoutTopicInput = {
    id?: IntFieldUpdateOperationsInput | number
    topicName?: StringFieldUpdateOperationsInput | string
    topicDefinition?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    subjectId?: IntFieldUpdateOperationsInput | number
    formId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type topicReviewUpdateWithoutUsersInput = {
    topicName?: StringFieldUpdateOperationsInput | string
    topicDefinition?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    form?: formReviewUpdateOneRequiredWithoutTopicNestedInput
    subject?: subjectReviewUpdateOneRequiredWithoutTopicNestedInput
    review?: reviewUpdateManyWithoutTopicNestedInput
  }

  export type topicReviewUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    topicName?: StringFieldUpdateOperationsInput | string
    topicDefinition?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    subjectId?: IntFieldUpdateOperationsInput | number
    formId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    review?: reviewUncheckedUpdateManyWithoutTopicNestedInput
  }

  export type topicReviewUncheckedUpdateManyWithoutTopicReviewInput = {
    id?: IntFieldUpdateOperationsInput | number
    topicName?: StringFieldUpdateOperationsInput | string
    topicDefinition?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    subjectId?: IntFieldUpdateOperationsInput | number
    formId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vifurushiUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
  }

  export type vifurushiUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
  }

  export type vifurushiUncheckedUpdateManyWithoutVifurushiInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
  }

  export type noteCreateManySubjectInput = {
    id?: number
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    published?: boolean
    formId: number
    usersId: number
    topicId: number
  }

  export type notesDownloadableCreateManySubjectInput = {
    id?: number
    link: string
    fileExtension: string
    published?: boolean
    formId: number
    usersId: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type topicCreateManySubjectInput = {
    id?: number
    topicName: string
    topicDefinition?: string | null
    published?: boolean
    formId: number
    usersId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type noteUpdateWithoutSubjectInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    published?: BoolFieldUpdateOperationsInput | boolean
    form?: formUpdateOneRequiredWithoutNoteNestedInput
    topic?: topicUpdateOneRequiredWithoutNoteNestedInput
    users?: usersUpdateOneRequiredWithoutNoteNestedInput
  }

  export type noteUncheckedUpdateWithoutSubjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    published?: BoolFieldUpdateOperationsInput | boolean
    formId?: IntFieldUpdateOperationsInput | number
    usersId?: IntFieldUpdateOperationsInput | number
    topicId?: IntFieldUpdateOperationsInput | number
  }

  export type notesDownloadableUpdateWithoutSubjectInput = {
    link?: StringFieldUpdateOperationsInput | string
    fileExtension?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    form?: formUpdateOneRequiredWithoutNotesDownloadableNestedInput
    users?: usersUpdateOneRequiredWithoutNotesDownloadableNestedInput
  }

  export type notesDownloadableUncheckedUpdateWithoutSubjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    link?: StringFieldUpdateOperationsInput | string
    fileExtension?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    formId?: IntFieldUpdateOperationsInput | number
    usersId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type topicUpdateWithoutSubjectInput = {
    topicName?: StringFieldUpdateOperationsInput | string
    topicDefinition?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    form?: formUpdateOneRequiredWithoutTopicNestedInput
    users?: usersUpdateOneRequiredWithoutTopicNestedInput
    note?: noteUpdateOneWithoutTopicNestedInput
  }

  export type topicUncheckedUpdateWithoutSubjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    topicName?: StringFieldUpdateOperationsInput | string
    topicDefinition?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    formId?: IntFieldUpdateOperationsInput | number
    usersId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: noteUncheckedUpdateOneWithoutTopicNestedInput
  }

  export type formUpdateWithoutSubjectsInput = {
    formName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutFormNestedInput
    note?: noteUpdateManyWithoutFormNestedInput
    notesDownloadable?: notesDownloadableUpdateManyWithoutFormNestedInput
    topic?: topicUpdateManyWithoutFormNestedInput
  }

  export type formUncheckedUpdateWithoutSubjectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    formName?: StringFieldUpdateOperationsInput | string
    usersId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: noteUncheckedUpdateManyWithoutFormNestedInput
    notesDownloadable?: notesDownloadableUncheckedUpdateManyWithoutFormNestedInput
    topic?: topicUncheckedUpdateManyWithoutFormNestedInput
  }

  export type formUncheckedUpdateManyWithoutFormsInput = {
    id?: IntFieldUpdateOperationsInput | number
    formName?: StringFieldUpdateOperationsInput | string
    usersId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type noteCreateManyFormInput = {
    id?: number
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    published?: boolean
    subjectId: number
    usersId: number
    topicId: number
  }

  export type notesDownloadableCreateManyFormInput = {
    id?: number
    link: string
    fileExtension: string
    published?: boolean
    subjectId: number
    usersId: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type topicCreateManyFormInput = {
    id?: number
    topicName: string
    topicDefinition?: string | null
    published?: boolean
    subjectId: number
    usersId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type noteUpdateWithoutFormInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    published?: BoolFieldUpdateOperationsInput | boolean
    subject?: subjectUpdateOneRequiredWithoutNoteNestedInput
    topic?: topicUpdateOneRequiredWithoutNoteNestedInput
    users?: usersUpdateOneRequiredWithoutNoteNestedInput
  }

  export type noteUncheckedUpdateWithoutFormInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    published?: BoolFieldUpdateOperationsInput | boolean
    subjectId?: IntFieldUpdateOperationsInput | number
    usersId?: IntFieldUpdateOperationsInput | number
    topicId?: IntFieldUpdateOperationsInput | number
  }

  export type notesDownloadableUpdateWithoutFormInput = {
    link?: StringFieldUpdateOperationsInput | string
    fileExtension?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: subjectUpdateOneRequiredWithoutNotesDownloadableNestedInput
    users?: usersUpdateOneRequiredWithoutNotesDownloadableNestedInput
  }

  export type notesDownloadableUncheckedUpdateWithoutFormInput = {
    id?: IntFieldUpdateOperationsInput | number
    link?: StringFieldUpdateOperationsInput | string
    fileExtension?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    subjectId?: IntFieldUpdateOperationsInput | number
    usersId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type topicUpdateWithoutFormInput = {
    topicName?: StringFieldUpdateOperationsInput | string
    topicDefinition?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: subjectUpdateOneRequiredWithoutTopicNestedInput
    users?: usersUpdateOneRequiredWithoutTopicNestedInput
    note?: noteUpdateOneWithoutTopicNestedInput
  }

  export type topicUncheckedUpdateWithoutFormInput = {
    id?: IntFieldUpdateOperationsInput | number
    topicName?: StringFieldUpdateOperationsInput | string
    topicDefinition?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    subjectId?: IntFieldUpdateOperationsInput | number
    usersId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: noteUncheckedUpdateOneWithoutTopicNestedInput
  }

  export type subjectUpdateWithoutFormsInput = {
    subjectName?: StringFieldUpdateOperationsInput | string
    subjectDefinition?: StringFieldUpdateOperationsInput | string
    imageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutSubjectNestedInput
    note?: noteUpdateManyWithoutSubjectNestedInput
    notesDownloadable?: notesDownloadableUpdateManyWithoutSubjectNestedInput
    topic?: topicUpdateManyWithoutSubjectNestedInput
  }

  export type subjectUncheckedUpdateWithoutFormsInput = {
    id?: IntFieldUpdateOperationsInput | number
    subjectName?: StringFieldUpdateOperationsInput | string
    subjectDefinition?: StringFieldUpdateOperationsInput | string
    imageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    usersId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: noteUncheckedUpdateManyWithoutSubjectNestedInput
    notesDownloadable?: notesDownloadableUncheckedUpdateManyWithoutSubjectNestedInput
    topic?: topicUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type subjectUncheckedUpdateManyWithoutSubjectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    subjectName?: StringFieldUpdateOperationsInput | string
    subjectDefinition?: StringFieldUpdateOperationsInput | string
    imageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    usersId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type reviewCreateManySubjectInput = {
    id?: number
    name: string
    published?: boolean
    topicId: number
    formId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    usersId: number
  }

  export type topicReviewCreateManySubjectInput = {
    id?: number
    topicName: string
    topicDefinition?: string | null
    published?: boolean
    formId: number
    usersId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type reviewUpdateWithoutSubjectInput = {
    name?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    form?: formReviewUpdateOneRequiredWithoutReviewNestedInput
    topic?: topicReviewUpdateOneRequiredWithoutReviewNestedInput
    users?: usersUpdateOneRequiredWithoutReviewNestedInput
    question?: questionUpdateManyWithoutReviewNestedInput
  }

  export type reviewUncheckedUpdateWithoutSubjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    topicId?: IntFieldUpdateOperationsInput | number
    formId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usersId?: IntFieldUpdateOperationsInput | number
    question?: questionUncheckedUpdateManyWithoutReviewNestedInput
  }

  export type topicReviewUpdateWithoutSubjectInput = {
    topicName?: StringFieldUpdateOperationsInput | string
    topicDefinition?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    form?: formReviewUpdateOneRequiredWithoutTopicNestedInput
    users?: usersUpdateOneRequiredWithoutTopicReviewNestedInput
    review?: reviewUpdateManyWithoutTopicNestedInput
  }

  export type topicReviewUncheckedUpdateWithoutSubjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    topicName?: StringFieldUpdateOperationsInput | string
    topicDefinition?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    formId?: IntFieldUpdateOperationsInput | number
    usersId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    review?: reviewUncheckedUpdateManyWithoutTopicNestedInput
  }

  export type topicReviewUncheckedUpdateManyWithoutTopicInput = {
    id?: IntFieldUpdateOperationsInput | number
    topicName?: StringFieldUpdateOperationsInput | string
    topicDefinition?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    formId?: IntFieldUpdateOperationsInput | number
    usersId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type formReviewUpdateWithoutSubjectsInput = {
    formName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutFormReviewNestedInput
    review?: reviewUpdateManyWithoutFormNestedInput
    topic?: topicReviewUpdateManyWithoutFormNestedInput
  }

  export type formReviewUncheckedUpdateWithoutSubjectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    formName?: StringFieldUpdateOperationsInput | string
    usersId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    review?: reviewUncheckedUpdateManyWithoutFormNestedInput
    topic?: topicReviewUncheckedUpdateManyWithoutFormNestedInput
  }

  export type formReviewUncheckedUpdateManyWithoutFormsInput = {
    id?: IntFieldUpdateOperationsInput | number
    formName?: StringFieldUpdateOperationsInput | string
    usersId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type reviewCreateManyFormInput = {
    id?: number
    name: string
    published?: boolean
    topicId: number
    subjectId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    usersId: number
  }

  export type topicReviewCreateManyFormInput = {
    id?: number
    topicName: string
    topicDefinition?: string | null
    published?: boolean
    subjectId: number
    usersId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type reviewUpdateWithoutFormInput = {
    name?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: subjectReviewUpdateOneRequiredWithoutReviewNestedInput
    topic?: topicReviewUpdateOneRequiredWithoutReviewNestedInput
    users?: usersUpdateOneRequiredWithoutReviewNestedInput
    question?: questionUpdateManyWithoutReviewNestedInput
  }

  export type reviewUncheckedUpdateWithoutFormInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    topicId?: IntFieldUpdateOperationsInput | number
    subjectId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usersId?: IntFieldUpdateOperationsInput | number
    question?: questionUncheckedUpdateManyWithoutReviewNestedInput
  }

  export type topicReviewUpdateWithoutFormInput = {
    topicName?: StringFieldUpdateOperationsInput | string
    topicDefinition?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: subjectReviewUpdateOneRequiredWithoutTopicNestedInput
    users?: usersUpdateOneRequiredWithoutTopicReviewNestedInput
    review?: reviewUpdateManyWithoutTopicNestedInput
  }

  export type topicReviewUncheckedUpdateWithoutFormInput = {
    id?: IntFieldUpdateOperationsInput | number
    topicName?: StringFieldUpdateOperationsInput | string
    topicDefinition?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    subjectId?: IntFieldUpdateOperationsInput | number
    usersId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    review?: reviewUncheckedUpdateManyWithoutTopicNestedInput
  }

  export type subjectReviewUpdateWithoutFormsInput = {
    subjectName?: StringFieldUpdateOperationsInput | string
    subjectDefinition?: StringFieldUpdateOperationsInput | string
    imageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutSubjectReviewNestedInput
    review?: reviewUpdateManyWithoutSubjectNestedInput
    topic?: topicReviewUpdateManyWithoutSubjectNestedInput
  }

  export type subjectReviewUncheckedUpdateWithoutFormsInput = {
    id?: IntFieldUpdateOperationsInput | number
    subjectName?: StringFieldUpdateOperationsInput | string
    subjectDefinition?: StringFieldUpdateOperationsInput | string
    imageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    usersId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    review?: reviewUncheckedUpdateManyWithoutSubjectNestedInput
    topic?: topicReviewUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type subjectReviewUncheckedUpdateManyWithoutSubjectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    subjectName?: StringFieldUpdateOperationsInput | string
    subjectDefinition?: StringFieldUpdateOperationsInput | string
    imageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    usersId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type reviewCreateManyTopicInput = {
    id?: number
    name: string
    published?: boolean
    subjectId: number
    formId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    usersId: number
  }

  export type reviewUpdateWithoutTopicInput = {
    name?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    form?: formReviewUpdateOneRequiredWithoutReviewNestedInput
    subject?: subjectReviewUpdateOneRequiredWithoutReviewNestedInput
    users?: usersUpdateOneRequiredWithoutReviewNestedInput
    question?: questionUpdateManyWithoutReviewNestedInput
  }

  export type reviewUncheckedUpdateWithoutTopicInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    subjectId?: IntFieldUpdateOperationsInput | number
    formId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usersId?: IntFieldUpdateOperationsInput | number
    question?: questionUncheckedUpdateManyWithoutReviewNestedInput
  }

  export type questionCreateManyReviewInput = {
    id?: number
    question: string
    published?: boolean
    answerDetails?: string
    questionFormatId: number
    usersId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type questionUpdateWithoutReviewInput = {
    question?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    answerDetails?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questionFormat?: questionFormatUpdateOneRequiredWithoutQuestionNestedInput
    users?: usersUpdateOneRequiredWithoutQuestionNestedInput
    answer?: answerUpdateManyWithoutQuestionNestedInput
  }

  export type questionUncheckedUpdateWithoutReviewInput = {
    id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    answerDetails?: StringFieldUpdateOperationsInput | string
    questionFormatId?: IntFieldUpdateOperationsInput | number
    usersId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answer?: answerUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type answerCreateManyQuestionInput = {
    id?: number
    answer: string
    valid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type answerUpdateWithoutQuestionInput = {
    answer?: StringFieldUpdateOperationsInput | string
    valid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type answerUncheckedUpdateWithoutQuestionInput = {
    id?: IntFieldUpdateOperationsInput | number
    answer?: StringFieldUpdateOperationsInput | string
    valid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type answerUncheckedUpdateManyWithoutAnswerInput = {
    id?: IntFieldUpdateOperationsInput | number
    answer?: StringFieldUpdateOperationsInput | string
    valid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type questionCreateManyQuestionFormatInput = {
    id?: number
    question: string
    published?: boolean
    answerDetails?: string
    reviewId: number
    usersId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type questionUpdateWithoutQuestionFormatInput = {
    question?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    answerDetails?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    review?: reviewUpdateOneRequiredWithoutQuestionNestedInput
    users?: usersUpdateOneRequiredWithoutQuestionNestedInput
    answer?: answerUpdateManyWithoutQuestionNestedInput
  }

  export type questionUncheckedUpdateWithoutQuestionFormatInput = {
    id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    answerDetails?: StringFieldUpdateOperationsInput | string
    reviewId?: IntFieldUpdateOperationsInput | number
    usersId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answer?: answerUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type examTypeCreateManySubjectExamsInput = {
    id?: number
    name: string
    definition: string
    published?: boolean
    formId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type examTypeUpdateWithoutSubjectExamsInput = {
    name?: StringFieldUpdateOperationsInput | string
    definition?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    formExams?: formExamsUpdateOneRequiredWithoutExamTypeNestedInput
    exam?: examUpdateManyWithoutExamTypeNestedInput
  }

  export type examTypeUncheckedUpdateWithoutSubjectExamsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    definition?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    formId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exam?: examUncheckedUpdateManyWithoutExamTypeNestedInput
  }

  export type examTypeUncheckedUpdateManyWithoutExamTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    definition?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    formId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type formExamsUpdateWithoutSubjectsInput = {
    formName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutFormExamsNestedInput
    examType?: examTypeUpdateManyWithoutFormExamsNestedInput
  }

  export type formExamsUncheckedUpdateWithoutSubjectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    formName?: StringFieldUpdateOperationsInput | string
    usersId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examType?: examTypeUncheckedUpdateManyWithoutFormExamsNestedInput
  }

  export type formExamsUncheckedUpdateManyWithoutFormsInput = {
    id?: IntFieldUpdateOperationsInput | number
    formName?: StringFieldUpdateOperationsInput | string
    usersId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type examTypeCreateManyFormExamsInput = {
    id?: number
    name: string
    definition: string
    published?: boolean
    subjectId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type examTypeUpdateWithoutFormExamsInput = {
    name?: StringFieldUpdateOperationsInput | string
    definition?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subjectExams?: subjectExamsUpdateOneRequiredWithoutExamTypeNestedInput
    exam?: examUpdateManyWithoutExamTypeNestedInput
  }

  export type examTypeUncheckedUpdateWithoutFormExamsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    definition?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    subjectId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exam?: examUncheckedUpdateManyWithoutExamTypeNestedInput
  }

  export type subjectExamsUpdateWithoutFormsInput = {
    subjectName?: StringFieldUpdateOperationsInput | string
    subjectDefinition?: StringFieldUpdateOperationsInput | string
    imageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutSubjectExamsNestedInput
    examType?: examTypeUpdateManyWithoutSubjectExamsNestedInput
  }

  export type subjectExamsUncheckedUpdateWithoutFormsInput = {
    id?: IntFieldUpdateOperationsInput | number
    subjectName?: StringFieldUpdateOperationsInput | string
    subjectDefinition?: StringFieldUpdateOperationsInput | string
    imageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    usersId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examType?: examTypeUncheckedUpdateManyWithoutSubjectExamsNestedInput
  }

  export type subjectExamsUncheckedUpdateManyWithoutSubjectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    subjectName?: StringFieldUpdateOperationsInput | string
    subjectDefinition?: StringFieldUpdateOperationsInput | string
    imageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    usersId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type examCreateManyExamTypeInput = {
    id?: number
    description: string
    year: number
    hasAnswers?: boolean
    published?: boolean
    exam: string
    usersId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type examUpdateWithoutExamTypeInput = {
    description?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    hasAnswers?: BoolFieldUpdateOperationsInput | boolean
    published?: BoolFieldUpdateOperationsInput | boolean
    exam?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutExamNestedInput
    examDownloadable?: examDownloadableUpdateManyWithoutExamNestedInput
  }

  export type examUncheckedUpdateWithoutExamTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    hasAnswers?: BoolFieldUpdateOperationsInput | boolean
    published?: BoolFieldUpdateOperationsInput | boolean
    exam?: StringFieldUpdateOperationsInput | string
    usersId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examDownloadable?: examDownloadableUncheckedUpdateManyWithoutExamNestedInput
  }

  export type examDownloadableCreateManyExamInput = {
    id?: number
    link: string
    fileExtension: string
    published?: boolean
    usersId: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type examDownloadableUpdateWithoutExamInput = {
    link?: StringFieldUpdateOperationsInput | string
    fileExtension?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutExamDownloadableNestedInput
  }

  export type examDownloadableUncheckedUpdateWithoutExamInput = {
    id?: IntFieldUpdateOperationsInput | number
    link?: StringFieldUpdateOperationsInput | string
    fileExtension?: StringFieldUpdateOperationsInput | string
    published?: BoolFieldUpdateOperationsInput | boolean
    usersId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type referenceCreateManySubjectReferenceInput = {
    id?: number
    name: string
    description: string
    data: string
    isPdf: boolean
    published?: boolean
    usersId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type referenceUpdateWithoutSubjectReferenceInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    isPdf?: BoolFieldUpdateOperationsInput | boolean
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutReferenceNestedInput
    formReference?: formReferenceUpdateManyWithoutReferenceNestedInput
  }

  export type referenceUncheckedUpdateWithoutSubjectReferenceInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    isPdf?: BoolFieldUpdateOperationsInput | boolean
    published?: BoolFieldUpdateOperationsInput | boolean
    usersId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    formReference?: formReferenceUncheckedUpdateManyWithoutReferenceNestedInput
  }

  export type formReferenceUpdateWithoutSubjectsInput = {
    formName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutFormReferenceNestedInput
    reference?: referenceUpdateManyWithoutFormReferenceNestedInput
  }

  export type formReferenceUncheckedUpdateWithoutSubjectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    formName?: StringFieldUpdateOperationsInput | string
    usersId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: referenceUncheckedUpdateManyWithoutFormReferenceNestedInput
  }

  export type formReferenceUncheckedUpdateManyWithoutFormsInput = {
    id?: IntFieldUpdateOperationsInput | number
    formName?: StringFieldUpdateOperationsInput | string
    usersId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type referenceUpdateWithoutFormReferenceInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    isPdf?: BoolFieldUpdateOperationsInput | boolean
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subjectReference?: subjectReferenceUpdateOneRequiredWithoutReferenceNestedInput
    users?: usersUpdateOneRequiredWithoutReferenceNestedInput
  }

  export type referenceUncheckedUpdateWithoutFormReferenceInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    isPdf?: BoolFieldUpdateOperationsInput | boolean
    published?: BoolFieldUpdateOperationsInput | boolean
    subjectId?: IntFieldUpdateOperationsInput | number
    usersId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type subjectReferenceUpdateWithoutFormsInput = {
    subjectName?: StringFieldUpdateOperationsInput | string
    subjectDefinition?: StringFieldUpdateOperationsInput | string
    imageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutSubjectReferenceNestedInput
    reference?: referenceUpdateManyWithoutSubjectReferenceNestedInput
  }

  export type subjectReferenceUncheckedUpdateWithoutFormsInput = {
    id?: IntFieldUpdateOperationsInput | number
    subjectName?: StringFieldUpdateOperationsInput | string
    subjectDefinition?: StringFieldUpdateOperationsInput | string
    imageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    usersId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: referenceUncheckedUpdateManyWithoutSubjectReferenceNestedInput
  }

  export type subjectReferenceUncheckedUpdateManyWithoutSubjectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    subjectName?: StringFieldUpdateOperationsInput | string
    subjectDefinition?: StringFieldUpdateOperationsInput | string
    imageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    usersId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type formReferenceUpdateWithoutReferenceInput = {
    formName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutFormReferenceNestedInput
    subjects?: subjectReferenceUpdateManyWithoutFormsNestedInput
  }

  export type formReferenceUncheckedUpdateWithoutReferenceInput = {
    id?: IntFieldUpdateOperationsInput | number
    formName?: StringFieldUpdateOperationsInput | string
    usersId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: subjectReferenceUncheckedUpdateManyWithoutFormsNestedInput
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}