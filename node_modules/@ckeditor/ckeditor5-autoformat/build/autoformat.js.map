{"version":3,"sources":["webpack://CKEditor5.autoformat/./src/autoformat.js","webpack://CKEditor5.autoformat/./src/blockautoformatediting.js","webpack://CKEditor5.autoformat/./src/inlineautoformatediting.js","webpack://CKEditor5.autoformat/delegated \"./src/core.js\" from dll-reference CKEditor5.dll","webpack://CKEditor5.autoformat/delegated \"./src/engine.js\" from dll-reference CKEditor5.dll","webpack://CKEditor5.autoformat/delegated \"./src/typing.js\" from dll-reference CKEditor5.dll","webpack://CKEditor5.autoformat/delegated \"./src/utils.js\" from dll-reference CKEditor5.dll","webpack://CKEditor5.autoformat/external var \"CKEditor5.dll\"","webpack://CKEditor5.autoformat/webpack/bootstrap","webpack://CKEditor5.autoformat/webpack/runtime/define property getters","webpack://CKEditor5.autoformat/webpack/runtime/hasOwnProperty shorthand","webpack://CKEditor5.autoformat/webpack/runtime/make namespace object","webpack://CKEditor5.autoformat/./src/index.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAE4C;AACE;;AAEgB;AACE;;AAEhE;AACA;AACA;AACA,uCAAuC;AACvC,YAAY,mCAAmC;AAC/C;AACA;AACA;AACe,yBAAyB,sDAAM;AAC9C;AACA;AACA;AACA;AACA,WAAW,wDAAM;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wCAAwC,4BAA4B;AACpE;AACA;AACA,2BAA2B;AAC3B,6BAA6B;AAC7B,8BAA8B;AAC9B,iCAAiC;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG,mEAAsB;AACzB;;AAEA;AACA,GAAG,mEAAsB;AACzB;;AAEA;AACA,GAAG,mEAAsB;AACzB;;AAEA;AACA,GAAG,mEAAsB;AACzB;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,wCAAwC,oCAAoC;AAC5E,KAAK,wCAAwC,GAAG;AAChD,SAAS;AACT;AACA;AACA,2BAA2B;AAC3B,2BAA2B;AAC3B,yBAAyB;AACzB,yBAAyB;AACzB,2BAA2B;AAC3B,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,GAAG,oEAAuB;AAC1B,GAAG,oEAAuB;AAC1B;;AAEA;AACA;;AAEA;AACA;AACA,GAAG,oEAAuB;AAC1B,GAAG,oEAAuB;AAC1B;;AAEA;AACA;;AAEA,GAAG,oEAAuB;AAC1B;;AAEA;AACA;;AAEA,GAAG,oEAAuB;AAC1B;AACA;;AAEA;AACA,oCAAoC,qCAAqC;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sCAAsC,GAAG,QAAQ;;AAEjD,KAAK,mEAAsB;AAC3B;AACA;AACA;AACA;;AAEA,wCAAwC,mBAAmB;AAC3D,OAAO;AACP,MAAM;AACN;AACA;;AAEA;AACA,oCAAoC,+CAA+C;AACnF;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA,GAAG,mEAAsB;AACzB;AACA;;AAEA;AACA,oCAAoC,4CAA4C;AAChF;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG,mEAAsB;AACzB;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,KAAK;AACL;AACA;;AAEA;AACA,oCAAoC,2DAA2D;AAC/F;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA,GAAG,mEAAsB;AACzB;AACA;AACA;;AAEA;AACA;AACA,WAAW,kCAAkC;AAC7C,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AChPA;AACA;AACA;AACA;;AAEiD;AACL;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gGAAgG;AAC5G;AACA,QAAQ,+CAA+C;AACvD;AACA;AACA;AACA;;AAEA;AACA,oCAAoC,6EAA6E;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA,2BAA2B,cAAc;AACzC,OAAO;AACP,OAAO;AACP;AACA,WAAW,kCAAkC;AAC7C,WAAW,yCAAyC;AACpD,WAAW,QAAQ;AACnB;AACA,WAAW,iBAAiB;AAC5B;AACA,MAAM,QAAQ;AACd;AACe;AACf;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,gBAAgB,0DAAK;;AAErB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB,2DAAS;;AAE9B,kCAAkC,QAAQ;;AAE1C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL,IAAI;AACJ,GAAG;AACH;;;;;;;;;;;;;;;;AC5JA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,mGAAmG;AAC/G;AACA,QAAQ,+CAA+C;AACvD;AACA;AACA;AACA;;AAEA;AACA,iDAAiD,uCAAuC;AACxF;AACA;AACA,aAAa,2EAA2E;AACxF;AACA;AACA;AACA,WAAW,kCAAkC;AAC7C,WAAW,yCAAyC;AACpD,WAAW,iBAAiB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACe;AACf;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU,cAAc;AACxB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL,IAAI;AACJ,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,WAAW,uCAAuC;AAClD,WAAW,eAAe;AAC1B,WAAW,iCAAiC;AAC5C;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA,qBAAqB,8EAA8E;AACnG;AACA;AACA,WAAW,iCAAiC;AAC5C,WAAW,iCAAiC;AAC5C,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,EAAE;;AAEF,UAAU;AACV;;;;;;;;;;;ACzNA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;UCAA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEqD","file":"autoformat.js","sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module autoformat/autoformat\n */\n\nimport { Plugin } from 'ckeditor5/src/core';\nimport { Delete } from 'ckeditor5/src/typing';\n\nimport blockAutoformatEditing from './blockautoformatediting';\nimport inlineAutoformatEditing from './inlineautoformatediting';\n\n/**\n * Enables a set of predefined autoformatting actions.\n *\n * For a detailed overview, check the {@glink features/autoformat Autoformatting feature documentation}\n * and the {@glink api/autoformat package page}.\n *\n * @extends module:core/plugin~Plugin\n */\nexport default class Autoformat extends Plugin {\n\t/**\n\t * @inheritdoc\n\t */\n\tstatic get requires() {\n\t\treturn [ Delete ];\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get pluginName() {\n\t\treturn 'Autoformat';\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tafterInit() {\n\t\tthis._addListAutoformats();\n\t\tthis._addBasicStylesAutoformats();\n\t\tthis._addHeadingAutoformats();\n\t\tthis._addBlockQuoteAutoformats();\n\t\tthis._addCodeBlockAutoformats();\n\t\tthis._addHorizontalLineAutoformats();\n\t}\n\n\t/**\n\t * Adds autoformatting related to the {@link module:list/list~List}.\n\t *\n\t * When typed:\n\t * - `* ` or `- ` &ndash; A paragraph will be changed to a bulleted list.\n\t * - `1. ` or `1) ` &ndash; A paragraph will be changed to a numbered list (\"1\" can be any digit or a list of digits).\n\t * - `[] ` or `[ ] ` &ndash; A paragraph will be changed to a to-do list.\n\t * - `[x] ` or `[ x ] ` &ndash; A paragraph will be changed to a checked to-do list.\n\t *\n\t * @private\n\t */\n\t_addListAutoformats() {\n\t\tconst commands = this.editor.commands;\n\n\t\tif ( commands.get( 'bulletedList' ) ) {\n\t\t\tblockAutoformatEditing( this.editor, this, /^[*-]\\s$/, 'bulletedList' );\n\t\t}\n\n\t\tif ( commands.get( 'numberedList' ) ) {\n\t\t\tblockAutoformatEditing( this.editor, this, /^1[.|)]\\s$/, 'numberedList' );\n\t\t}\n\n\t\tif ( commands.get( 'todoList' ) ) {\n\t\t\tblockAutoformatEditing( this.editor, this, /^\\[\\s?\\]\\s$/, 'todoList' );\n\t\t}\n\n\t\tif ( commands.get( 'checkTodoList' ) ) {\n\t\t\tblockAutoformatEditing( this.editor, this, /^\\[\\s?x\\s?\\]\\s$/, () => {\n\t\t\t\tthis.editor.execute( 'todoList' );\n\t\t\t\tthis.editor.execute( 'checkTodoList' );\n\t\t\t} );\n\t\t}\n\t}\n\n\t/**\n\t * Adds autoformatting related to the {@link module:basic-styles/bold~Bold},\n\t * {@link module:basic-styles/italic~Italic}, {@link module:basic-styles/code~Code}\n\t * and {@link module:basic-styles/strikethrough~Strikethrough}\n\t *\n\t * When typed:\n\t * - `**foobar**` &ndash; `**` characters are removed and `foobar` is set to bold,\n\t * - `__foobar__` &ndash; `__` characters are removed and `foobar` is set to bold,\n\t * - `*foobar*` &ndash; `*` characters are removed and `foobar` is set to italic,\n\t * - `_foobar_` &ndash; `_` characters are removed and `foobar` is set to italic,\n\t * - ``` `foobar` &ndash; ``` ` ``` characters are removed and `foobar` is set to code,\n\t * - `~~foobar~~` &ndash; `~~` characters are removed and `foobar` is set to strikethrough.\n\t *\n\t * @private\n\t */\n\t_addBasicStylesAutoformats() {\n\t\tconst commands = this.editor.commands;\n\n\t\tif ( commands.get( 'bold' ) ) {\n\t\t\tconst boldCallback = getCallbackFunctionForInlineAutoformat( this.editor, 'bold' );\n\n\t\t\tinlineAutoformatEditing( this.editor, this, /(?:^|\\s)(\\*\\*)([^*]+)(\\*\\*)$/g, boldCallback );\n\t\t\tinlineAutoformatEditing( this.editor, this, /(?:^|\\s)(__)([^_]+)(__)$/g, boldCallback );\n\t\t}\n\n\t\tif ( commands.get( 'italic' ) ) {\n\t\t\tconst italicCallback = getCallbackFunctionForInlineAutoformat( this.editor, 'italic' );\n\n\t\t\t// The italic autoformatter cannot be triggered by the bold markers, so we need to check the\n\t\t\t// text before the pattern (e.g. `(?:^|[^\\*])`).\n\t\t\tinlineAutoformatEditing( this.editor, this, /(?:^|\\s)(\\*)([^*_]+)(\\*)$/g, italicCallback );\n\t\t\tinlineAutoformatEditing( this.editor, this, /(?:^|\\s)(_)([^_]+)(_)$/g, italicCallback );\n\t\t}\n\n\t\tif ( commands.get( 'code' ) ) {\n\t\t\tconst codeCallback = getCallbackFunctionForInlineAutoformat( this.editor, 'code' );\n\n\t\t\tinlineAutoformatEditing( this.editor, this, /(`)([^`]+)(`)$/g, codeCallback );\n\t\t}\n\n\t\tif ( commands.get( 'strikethrough' ) ) {\n\t\t\tconst strikethroughCallback = getCallbackFunctionForInlineAutoformat( this.editor, 'strikethrough' );\n\n\t\t\tinlineAutoformatEditing( this.editor, this, /(~~)([^~]+)(~~)$/g, strikethroughCallback );\n\t\t}\n\t}\n\n\t/**\n\t * Adds autoformatting related to {@link module:heading/heading~Heading}.\n\t *\n\t * It is using a number at the end of the command name to associate it with the proper trigger:\n\t *\n\t * * `heading` with value `heading1` will be executed when typing `#`,\n\t * * `heading` with value `heading2` will be executed when typing `##`,\n\t * * ... up to `heading6` and `######`.\n\t *\n\t * @private\n\t */\n\t_addHeadingAutoformats() {\n\t\tconst command = this.editor.commands.get( 'heading' );\n\n\t\tif ( command ) {\n\t\t\tcommand.modelElements\n\t\t\t\t.filter( name => name.match( /^heading[1-6]$/ ) )\n\t\t\t\t.forEach( modelName => {\n\t\t\t\t\tconst level = modelName[ 7 ];\n\t\t\t\t\tconst pattern = new RegExp( `^(#{${ level }})\\\\s$` );\n\n\t\t\t\t\tblockAutoformatEditing( this.editor, this, pattern, () => {\n\t\t\t\t\t\t// Should only be active if command is enabled and heading style associated with pattern is inactive.\n\t\t\t\t\t\tif ( !command.isEnabled || command.value === modelName ) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis.editor.execute( 'heading', { value: modelName } );\n\t\t\t\t\t} );\n\t\t\t\t} );\n\t\t}\n\t}\n\n\t/**\n\t * Adds autoformatting related to {@link module:block-quote/blockquote~BlockQuote}.\n\t *\n\t * When typed:\n\t * * `> ` &ndash; A paragraph will be changed to a block quote.\n\t *\n\t * @private\n\t */\n\t_addBlockQuoteAutoformats() {\n\t\tif ( this.editor.commands.get( 'blockQuote' ) ) {\n\t\t\tblockAutoformatEditing( this.editor, this, /^>\\s$/, 'blockQuote' );\n\t\t}\n\t}\n\n\t/**\n\t * Adds autoformatting related to {@link module:code-block/codeblock~CodeBlock}.\n\t *\n\t * When typed:\n\t * - `` ``` `` &ndash; A paragraph will be changed to a code block.\n\t *\n\t * @private\n\t */\n\t_addCodeBlockAutoformats() {\n\t\tconst editor = this.editor;\n\t\tconst selection = editor.model.document.selection;\n\n\t\tif ( editor.commands.get( 'codeBlock' ) ) {\n\t\t\tblockAutoformatEditing( editor, this, /^```$/, () => {\n\t\t\t\tif ( selection.getFirstPosition().parent.is( 'element', 'listItem' ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tthis.editor.execute( 'codeBlock', {\n\t\t\t\t\tusePreviousLanguageChoice: true\n\t\t\t\t} );\n\t\t\t} );\n\t\t}\n\t}\n\n\t/**\n\t * Adds autoformatting related to {@link module:horizontal-line/horizontalline~HorizontalLine}.\n\t *\n\t * When typed:\n\t * - `` --- `` &ndash; Will be replaced with a horizontal line.\n\t *\n\t * @private\n\t */\n\t_addHorizontalLineAutoformats() {\n\t\tif ( this.editor.commands.get( 'horizontalLine' ) ) {\n\t\t\tblockAutoformatEditing( this.editor, this, /^---$/, 'horizontalLine' );\n\t\t}\n\t}\n}\n\n// Helper function for getting `inlineAutoformatEditing` callbacks that checks if command is enabled.\n//\n// @param {module:core/editor/editor~Editor} editor\n// @param {String} attributeKey\n// @returns {Function}\nfunction getCallbackFunctionForInlineAutoformat( editor, attributeKey ) {\n\treturn ( writer, rangesToFormat ) => {\n\t\tconst command = editor.commands.get( attributeKey );\n\n\t\tif ( !command.isEnabled ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst validRanges = editor.model.schema.getValidRanges( rangesToFormat, attributeKey );\n\n\t\tfor ( const range of validRanges ) {\n\t\t\twriter.setAttribute( attributeKey, true, range );\n\t\t}\n\n\t\t// After applying attribute to the text, remove given attribute from the selection.\n\t\t// This way user is able to type a text without attribute used by auto formatter.\n\t\twriter.removeSelectionAttribute( attributeKey );\n\t};\n}\n","/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\nimport { LiveRange } from 'ckeditor5/src/engine';\nimport { first } from 'ckeditor5/src/utils';\n\n/**\n * The block autoformatting engine. It allows to format various block patterns. For example,\n * it can be configured to turn a paragraph starting with `*` and followed by a space into a list item.\n *\n * The autoformatting operation is integrated with the undo manager,\n * so the autoformatting step can be undone if the user's intention was not to format the text.\n *\n * See the {@link module:autoformat/blockautoformatediting~blockAutoformatEditing `blockAutoformatEditing`} documentation\n * to learn how to create custom block autoformatters. You can also use\n * the {@link module:autoformat/autoformat~Autoformat} feature which enables a set of default autoformatters\n * (lists, headings, bold and italic).\n *\n * @module autoformat/blockautoformatediting\n */\n\n/**\n * Creates a listener triggered on {@link module:engine/model/document~Document#event:change:data `change:data`} event in the document.\n * Calls the callback when inserted text matches the regular expression or the command name\n * if provided instead of the callback.\n *\n * Examples of usage:\n *\n * To convert a paragraph to heading 1 when `- ` is typed, using just the command name:\n *\n *\t\tblockAutoformatEditing( editor, plugin, /^\\- $/, 'heading1' );\n *\n * To convert a paragraph to heading 1 when `- ` is typed, using just the callback:\n *\n *\t\tblockAutoformatEditing( editor, plugin, /^\\- $/, ( context ) => {\n *\t\t\tconst { match } = context;\n *\t\t\tconst headingLevel = match[ 1 ].length;\n *\n *\t\t\teditor.execute( 'heading', {\n *\t\t\t\tformatId: `heading${ headingLevel }`\n *\t\t\t} );\n * \t\t} );\n *\n * @param {module:core/editor/editor~Editor} editor The editor instance.\n * @param {module:autoformat/autoformat~Autoformat} plugin The autoformat plugin instance.\n * @param {RegExp} pattern The regular expression to execute on just inserted text. The regular expression is tested against the text\n * from the beginning until the caret position.\n * @param {Function|String} callbackOrCommand The callback to execute or the command to run when the text is matched.\n * In case of providing the callback, it receives the following parameter:\n * * {Object} match RegExp.exec() result of matching the pattern to inserted text.\n */\nexport default function blockAutoformatEditing( editor, plugin, pattern, callbackOrCommand ) {\n\tlet callback;\n\tlet command = null;\n\n\tif ( typeof callbackOrCommand == 'function' ) {\n\t\tcallback = callbackOrCommand;\n\t} else {\n\t\t// We assume that the actual command name was provided.\n\t\tcommand = editor.commands.get( callbackOrCommand );\n\n\t\tcallback = () => {\n\t\t\teditor.execute( callbackOrCommand );\n\t\t};\n\t}\n\n\teditor.model.document.on( 'change:data', ( evt, batch ) => {\n\t\tif ( command && !command.isEnabled || !plugin.isEnabled ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst range = first( editor.model.document.selection.getRanges() );\n\n\t\tif ( !range.isCollapsed ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( batch.isUndo || !batch.isLocal ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst changes = Array.from( editor.model.document.differ.getChanges() );\n\t\tconst entry = changes[ 0 ];\n\n\t\t// Typing is represented by only a single change.\n\t\tif ( changes.length != 1 || entry.type !== 'insert' || entry.name != '$text' || entry.length != 1 ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst blockToFormat = entry.position.parent;\n\n\t\t// Block formatting should be disabled in codeBlocks (#5800).\n\t\tif ( blockToFormat.is( 'element', 'codeBlock' ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Only list commands and custom callbacks can be applied inside a list.\n\t\tif ( blockToFormat.is( 'element', 'listItem' ) &&\n\t\t\ttypeof callbackOrCommand !== 'function' &&\n\t\t\t![ 'numberedList', 'bulletedList', 'todoList' ].includes( callbackOrCommand )\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\t// In case a command is bound, do not re-execute it over an existing block style which would result with a style removal.\n\t\t// Instead just drop processing so that autoformat trigger text is not lost. E.g. writing \"# \" in a level 1 heading.\n\t\tif ( command && command.value === true ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst firstNode = blockToFormat.getChild( 0 );\n\t\tconst firstNodeRange = editor.model.createRangeOn( firstNode );\n\n\t\t// Range is only expected to be within or at the very end of the first text node.\n\t\tif ( !firstNodeRange.containsRange( range ) && !range.end.isEqual( firstNodeRange.end ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst match = pattern.exec( firstNode.data.substr( 0, range.end.offset ) );\n\n\t\t// ...and this text node's data match the pattern.\n\t\tif ( !match ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Use enqueueChange to create new batch to separate typing batch from the auto-format changes.\n\t\teditor.model.enqueueChange( writer => {\n\t\t\t// Matched range.\n\t\t\tconst start = writer.createPositionAt( blockToFormat, 0 );\n\t\t\tconst end = writer.createPositionAt( blockToFormat, match[ 0 ].length );\n\t\t\tconst range = new LiveRange( start, end );\n\n\t\t\tconst wasChanged = callback( { match } );\n\n\t\t\t// Remove matched text.\n\t\t\tif ( wasChanged !== false ) {\n\t\t\t\twriter.remove( range );\n\n\t\t\t\tconst selectionRange = editor.model.document.selection.getFirstRange();\n\t\t\t\tconst blockRange = writer.createRangeIn( blockToFormat );\n\n\t\t\t\t// If the block is empty and the document selection has been moved when\n\t\t\t\t// applying formatting (e.g. is now in newly created block).\n\t\t\t\tif ( blockToFormat.isEmpty && !blockRange.isEqual( selectionRange ) && !blockRange.containsRange( selectionRange, true ) ) {\n\t\t\t\t\twriter.remove( blockToFormat );\n\t\t\t\t}\n\t\t\t}\n\t\t\trange.detach();\n\n\t\t\teditor.model.enqueueChange( () => {\n\t\t\t\teditor.plugins.get( 'Delete' ).requestUndoOnBackspace();\n\t\t\t} );\n\t\t} );\n\t} );\n}\n","/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * The inline autoformatting engine. It allows to format various inline patterns. For example,\n * it can be configured to make \"foo\" bold when typed `**foo**` (the `**` markers will be removed).\n *\n * The autoformatting operation is integrated with the undo manager,\n * so the autoformatting step can be undone if the user's intention was not to format the text.\n *\n * See the {@link module:autoformat/inlineautoformatediting~inlineAutoformatEditing `inlineAutoformatEditing`} documentation\n * to learn how to create custom inline autoformatters. You can also use\n * the {@link module:autoformat/autoformat~Autoformat} feature which enables a set of default autoformatters\n * (lists, headings, bold and italic).\n *\n * @module autoformat/inlineautoformatediting\n */\n\n/**\n * Enables autoformatting mechanism for a given {@link module:core/editor/editor~Editor}.\n *\n * It formats the matched text by applying the given model attribute or by running the provided formatting callback.\n * On every {@link module:engine/model/document~Document#event:change:data data change} in the model document\n * the autoformatting engine checks the text on the left of the selection\n * and executes the provided action if the text matches given criteria (regular expression or callback).\n *\n * @param {module:core/editor/editor~Editor} editor The editor instance.\n * @param {module:autoformat/autoformat~Autoformat} plugin The autoformat plugin instance.\n * @param {Function|RegExp} testRegexpOrCallback The regular expression or callback to execute on text.\n * Provided regular expression *must* have three capture groups. The first and the third capture group\n * should match opening and closing delimiters. The second capture group should match the text to format.\n *\n *\t\t// Matches the `**bold text**` pattern.\n *\t\t// There are three capturing groups:\n *\t\t// - The first to match the starting `**` delimiter.\n *\t\t// - The second to match the text to format.\n *\t\t// - The third to match the ending `**` delimiter.\n *\t\tinlineAutoformatEditing( editor, plugin, /(\\*\\*)([^\\*]+?)(\\*\\*)$/g, formatCallback );\n *\n * When a function is provided instead of the regular expression, it will be executed with the text to match as a parameter.\n * The function should return proper \"ranges\" to delete and format.\n *\n *\t\t{\n *\t\t\tremove: [\n *\t\t\t\t[ 0, 1 ],\t// Remove the first letter from the given text.\n *\t\t\t\t[ 5, 6 ]\t// Remove the 6th letter from the given text.\n *\t\t\t],\n *\t\t\tformat: [\n *\t\t\t\t[ 1, 5 ]\t// Format all letters from 2nd to 5th.\n *\t\t\t]\n *\t\t}\n *\n * @param {Function} formatCallback A callback to apply actual formatting.\n * It should return `false` if changes should not be applied (e.g. if a command is disabled).\n *\n *\t\tinlineAutoformatEditing( editor, plugin, /(\\*\\*)([^\\*]+?)(\\*\\*)$/g, ( writer, rangesToFormat ) => {\n *\t\t\tconst command = editor.commands.get( 'bold' );\n *\n *\t\t\tif ( !command.isEnabled ) {\n *\t\t\t\treturn false;\n *\t\t\t}\n *\n *\t\t\tconst validRanges = editor.model.schema.getValidRanges( rangesToFormat, 'bold' );\n *\n *\t\t\tfor ( let range of validRanges ) {\n *\t\t\t\twriter.setAttribute( 'bold', true, range );\n *\t\t\t}\n *\t\t} );\n */\nexport default function inlineAutoformatEditing( editor, plugin, testRegexpOrCallback, formatCallback ) {\n\tlet regExp;\n\tlet testCallback;\n\n\tif ( testRegexpOrCallback instanceof RegExp ) {\n\t\tregExp = testRegexpOrCallback;\n\t} else {\n\t\ttestCallback = testRegexpOrCallback;\n\t}\n\n\t// A test callback run on changed text.\n\ttestCallback = testCallback || ( text => {\n\t\tlet result;\n\t\tconst remove = [];\n\t\tconst format = [];\n\n\t\twhile ( ( result = regExp.exec( text ) ) !== null ) {\n\t\t\t// There should be full match and 3 capture groups.\n\t\t\tif ( result && result.length < 4 ) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlet {\n\t\t\t\tindex,\n\t\t\t\t'1': leftDel,\n\t\t\t\t'2': content,\n\t\t\t\t'3': rightDel\n\t\t\t} = result;\n\n\t\t\t// Real matched string - there might be some non-capturing groups so we need to recalculate starting index.\n\t\t\tconst found = leftDel + content + rightDel;\n\t\t\tindex += result[ 0 ].length - found.length;\n\n\t\t\t// Start and End offsets of delimiters to remove.\n\t\t\tconst delStart = [\n\t\t\t\tindex,\n\t\t\t\tindex + leftDel.length\n\t\t\t];\n\t\t\tconst delEnd = [\n\t\t\t\tindex + leftDel.length + content.length,\n\t\t\t\tindex + leftDel.length + content.length + rightDel.length\n\t\t\t];\n\n\t\t\tremove.push( delStart );\n\t\t\tremove.push( delEnd );\n\n\t\t\tformat.push( [ index + leftDel.length, index + leftDel.length + content.length ] );\n\t\t}\n\n\t\treturn {\n\t\t\tremove,\n\t\t\tformat\n\t\t};\n\t} );\n\n\teditor.model.document.on( 'change:data', ( evt, batch ) => {\n\t\tif ( batch.isUndo || !batch.isLocal || !plugin.isEnabled ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst model = editor.model;\n\t\tconst selection = model.document.selection;\n\n\t\t// Do nothing if selection is not collapsed.\n\t\tif ( !selection.isCollapsed ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst changes = Array.from( model.document.differ.getChanges() );\n\t\tconst entry = changes[ 0 ];\n\n\t\t// Typing is represented by only a single change.\n\t\tif ( changes.length != 1 || entry.type !== 'insert' || entry.name != '$text' || entry.length != 1 ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst focus = selection.focus;\n\t\tconst block = focus.parent;\n\t\tconst { text, range } = getTextAfterCode( model.createRange( model.createPositionAt( block, 0 ), focus ), model );\n\t\tconst testOutput = testCallback( text );\n\t\tconst rangesToFormat = testOutputToRanges( range.start, testOutput.format, model );\n\t\tconst rangesToRemove = testOutputToRanges( range.start, testOutput.remove, model );\n\n\t\tif ( !( rangesToFormat.length && rangesToRemove.length ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Use enqueueChange to create new batch to separate typing batch from the auto-format changes.\n\t\tmodel.enqueueChange( writer => {\n\t\t\t// Apply format.\n\t\t\tconst hasChanged = formatCallback( writer, rangesToFormat );\n\n\t\t\t// Strict check on `false` to have backward compatibility (when callbacks were returning `undefined`).\n\t\t\tif ( hasChanged === false ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Remove delimiters - use reversed order to not mix the offsets while removing.\n\t\t\tfor ( const range of rangesToRemove.reverse() ) {\n\t\t\t\twriter.remove( range );\n\t\t\t}\n\n\t\t\tmodel.enqueueChange( () => {\n\t\t\t\teditor.plugins.get( 'Delete' ).requestUndoOnBackspace();\n\t\t\t} );\n\t\t} );\n\t} );\n}\n\n// Converts output of the test function provided to the inlineAutoformatEditing and converts it to the model ranges\n// inside provided block.\n//\n// @private\n// @param {module:engine/model/position~Position} start\n// @param {Array.<Array>} arrays\n// @param {module:engine/model/model~Model} model\nfunction testOutputToRanges( start, arrays, model ) {\n\treturn arrays\n\t\t.filter( array => ( array[ 0 ] !== undefined && array[ 1 ] !== undefined ) )\n\t\t.map( array => {\n\t\t\treturn model.createRange( start.getShiftedBy( array[ 0 ] ), start.getShiftedBy( array[ 1 ] ) );\n\t\t} );\n}\n\n// Returns the last text line after the last code element from the given range.\n// It is similar to {@link module:typing/utils/getlasttextline.getLastTextLine `getLastTextLine()`},\n// but it ignores any text before the last `code`.\n//\n// @param {module:engine/model/range~Range} range\n// @param {module:engine/model/model~Model} model\n// @returns {module:typing/utils/getlasttextline~LastTextLineData}\nfunction getTextAfterCode( range, model ) {\n\tlet start = range.start;\n\n\tconst text = Array.from( range.getItems() ).reduce( ( rangeText, node ) => {\n\t\t// Trim text to a last occurrence of an inline element and update range start.\n\t\tif ( !( node.is( '$text' ) || node.is( '$textProxy' ) ) || node.getAttribute( 'code' ) ) {\n\t\t\tstart = model.createPositionAfter( node );\n\n\t\t\treturn '';\n\t\t}\n\n\t\treturn rangeText + node.data;\n\t}, '' );\n\n\treturn { text, range: model.createRange( start, range.end ) };\n}\n","module.exports = (__webpack_require__(/*! dll-reference CKEditor5.dll */ \"dll-reference CKEditor5.dll\"))(\"./src/core.js\");","module.exports = (__webpack_require__(/*! dll-reference CKEditor5.dll */ \"dll-reference CKEditor5.dll\"))(\"./src/engine.js\");","module.exports = (__webpack_require__(/*! dll-reference CKEditor5.dll */ \"dll-reference CKEditor5.dll\"))(\"./src/typing.js\");","module.exports = (__webpack_require__(/*! dll-reference CKEditor5.dll */ \"dll-reference CKEditor5.dll\"))(\"./src/utils.js\");","module.exports = CKEditor5.dll;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module autoformat\n */\n\nexport { default as Autoformat } from './autoformat';\n"],"sourceRoot":""}